
---------------------------------- ng-Book - THE COMPLETE GUIDE TO ANGULAR ---------------------------------------

The official branding guidelines state that "AngularJS" is a term reserved for AngularJS 1.x, that is the early versions of "Angular"
Because the new version of Angular used TS (instead of JS) as the primary language, the 'JS' was dropped, leaving us with just Angular
For a long time, the only consistent way to distinguish the 2, was folks referred to the new Angular as Angular 2
However, the Angular team in 2017 switched to semantic versioning with a new major-release upgrade slated for every 6 months
Instead of calling the next versions Angular 4, Angular 5 and so on, the number is also dropped and it's just Angular
In this book, when we're referring to Angular we'll just say Angular / sometimes Angular X, just to avoid confusion
When we're talking about "the old-style JS Angular" we'll use the term AngularJS / AngularJS 1.x

I. WRITING YOUR 1st ANGULAR WEB APPLICATION

    ■ SIMPLE REDDIT CLONE

        In this chapter we're going to build an application, that allows the user to post an article (with a title and a URL) and then vote on the posts - u can think of this app, as the beginnings of a site like Reddit / Product Hunt
        In this simple app we're going to cover most of the essentials of Angular including:
            • Building custom components   • Accepting user input from forms   • Rendering lists of objects into views   • Intercepting user clicks and acting on them   • Deploying our app to a server
        By the time you're finished with this chapter you'll know how to take an empty folder, build a basic Angular application and deploy it to production
        After working through this chapter, u'll have a good grasp on how Angular applications are built and a solid foundation to build your own Angular app
        Here's a screenshot of what our app will look like when it's done:
        1st, a user will submit a new link and after submitting, the users will be able to upvote / downvote each article. Each link will have a score and we can vote on which links we find useful
(B)     In this project and throughout the book, we're going to use TS. TS is a superset of JS ES6, that adds types
        We're not going to talk about TS in depth in this chapter, but we'll go over TS more in depth in the next chapter
        Don't worry, if you're having trouble with some of the new syntax. If you're familiar with ES5 ("normal" JS) / ES6 (ES2015) u should be able to follow along and we'll talk more about TS in a bit

    ■ GETTING STARTED

        Node.js and npm
        To get started with Angular, u'll need to have Node.js installed. There are a couple of different ways u can install Node.js, so please refer to the Node.js website for detailed info
        Make sure you install Node 12.2.0 / higher. The Node Package Manager (npm for short) is installed as a part of Node.js
        To check, if npm is available, as a part of our development environment, we can open a terminal window and type:
            $ npm -v
        If a version number is not printed out and u receive an error, make sure to download a Node.js installer that includes npm. Your npm version should be 6.9.0 / higher
        
        TS
        Once u have Node.js setup, the next step is to install TS. Make sure u install at least version 3.7.4 / greater. To install it, run the following npm command:
            $ npm install -g TS
        Do I have to use TS ? No, u don't have to use TS to use Angular, but u probably should. Angular does have an ES5 API, but Angular is written in TS and generally that's what everyone is using
        We're going to use TS in this book, because it's great and it makes working with Angular easier. That said, it isn't strictly required.
        Browser
        We highly recommend using the Google Chrome Web Browser to develop Angular apps. We'll use the Chrome developer toolkit throughout this book. To follow along with our development and debugging we recommend downloading it now

    ■ SPECIAL INSTRUCTION FOR WINDOWS USERS

        Throughout this book, we will be using Unix/Mac commands in the terminal. Most of these commands, like ls and cd, are cross-platform. However, sometimes these commands are Unix/Mac-specific or contain Unix/Mac-specific flags (like ls -1p)
        As a result, be alert, that u may have to occasionally determine the equivalent of a Unix/Mac command for your shell. Fortunately, the amount of work we do in the terminal, is minimal and u will not encounter this issue often
(B)     Windows users should be aware, that our terminal examples use Unix/Mac commands
        
        Angular CLI
        Angular provides a utility to allow users to create and manage projects from the command line. It automates tasks like creating projects, adding new controllers, etc.
        It's generally a good idea to use Angular CLI, as it will help create and maintain common patterns across our application:
            $ npm install -g @angular/cli
        Once it's installed, u'll be able to run it from the command line using the ng command. When u do, you'll see a lot of output, which u can safely ignore
        If you're curious about all of the things, that Angular CLI can do, try out this command:
            $ ng help
        Don't worry about understanding all of the options - we'll be covering the important ones in this chapter. Now, that we have Angular CLI and its dependencies installed, let's use this tool to create our 1st application
        
        Example Project
        Open up the terminal and run the command to create a new project from scratch:
            $ ng new angular-hello-world
        Once u run it, u may be asked a few questions about your configuration preferences
        Np. if asked, if u want to add Angular routing, in this example say No, but u'll probably want to use it for a bigger project. When asked about what CSS framework u want to use, we'll just use CSS for now
        After u answer the questions, u'll see (roughly) following output:
            1 CREATE angular-hello-world/README.md (1034 bytes)
            2 CREATE angular-hello-world/angular.json (3504 bytes)
            3 CREATE angular-hello-world/package.json (1323 bytes)
            ...
            32 added 1146 packages in 105.319s
            33 Successfully initialized git
        This will run for a while, while it's installing npm dependencies. Once it finishes, we'll see a success message
        The exact files, that your project generates, may vary slightly, depending on the version of @angular/cli, that was installed
        There are a lot of files generated ! Don't worry about understanding all of them yet. Throughout the book we'll walk through what each 1 means and what it's used for
        
        Let's go inside the angular-hello-world directory, which the ng command created for us and see what has been created
        For now, the folder we're interested in, is "src", where we'll put our custom application code. Let's take a look at what was created there:
        Using your favorite text editor, let's open index.html. You should see this code:
            code/first-app/angular-hello-world/src/index.html
            1 <!doctype html>
            2 <html lang="en">
            3 <head>
                4 <meta charset="utf-8">
                5 <title>AngularHelloWorld</title>
                6 <base href="/">
                7
                8 <meta name="viewport" content="width=device-width, initial-scale=1">
                9 <link rel="icon" type="image/x-icon" href="favicon.ico">
            10 </head>
            11 <body>
                12 <app-root></app-root>
            13 </body>
            14 </html>
        Let's break it down a bit:
            code/first-app/angular-hello-world/src/index.html
            1 <!doctype html>
            2 <html lang="en">
            3 <head>
                4 <meta charset="utf-8">
                5 <title>AngularHelloWorld</title>
                6 <base href="/">
                7
                8 <meta name="viewport" content="width=device-width, initial-scale=1">
                9 <link rel="icon" type="image/x-icon" href="favicon.ico">
            10 </head>
        If you're familiar with writing HTML files, this 1st part is straightforward, we're declaring the core structure of the HTML document and a few bits of metadata, such as page charset, title, base href
        If we continue to the template body, we see the following:
            code/first-app/angular-hello-world/src/index.html
            10 </head>
            11 <body>
                12 <app-root></app-root>
            13 </body>
            14 </html>
(B)     The "app-root" tag is where our application will be rendered. But what is the "app-root" tag and where does it come from ? "app-root" is a component, that is defined by our Angular application
(B)     In Angular, we can define our own HTML tags and give them custom functionality. The "app-root" tag will be the "entry point" for our application on the page
        Let's try running this app as-is and then we'll dig in, to see how this component is defined
        
    ■ RUNNING THE APPLICATION
    
(B)     Before making any changes, let's load our app from the generated application into the browser. Angular CLI has a built in HTTP server, that we can use to run our app
        To use it, head back to the terminal and change directories into the root of our application:
            1 $ cd angular-hello-world
            2 $ ng serve
            3 ** NG Live Development Server is running on http://localhost:4200. **
            4 // ...
            5 // a bunch of other messages
            6 // ...
            7 Compiled successfully.
        Our application is now running on localhost port 4200. Let's open the browser and visit:
            http://localhost:4200
        Note, that if u get the message:
            1 Port 4200 is already in use. Use '--port' to specify a different port
        This means, that u already have another service running on port 4200. If this is the case, u can either 1. shut down the other service or 2. use the --port flag, when running ng serve:
            1 ng serve --port 9001
        The above command would change the URL u open in your browser to: http://localhost:9001
        Another thing to notice is that, on some machines, the domain localhost may not work. You may see a set of numbers, such as 127.0.0.1
        When u run "ng serve", it should show u what URL the server is running on, so be sure to read the messages on your machine to find your exact development URL
        Now, that we have the application setup and we know how to run it, it's time to start writing some code
        
        Making a Component
        1 of the big ideas behind Angular is the idea of "components"
        In our Angular apps, we write HTML markup, that becomes our interactive application, but the browser only understands a limited set of markup tags
        Built-ins like <select> or <form> or <video> all have functionality defined by our browser creator. What, if we want to teach the browser new tags ? 
        What, if we wanted to have a <weather> tag, that shows the weather ? Or what, if we want to create a <login> tag, that shows a login panel ?
(B)     This is the fundamental idea behind components: we will teach the browser new tags, that have custom functionality attached to them
        If u have a background in AngularJS 1.X, u can think of components, as the new version of directives
        Let's create our very 1st component. When we have this component written, we will be able to use it in our HTML document using the app-hello-world tag:
            1 <app-hello-world></app-hello-world>
        To create a new component using Angular CLI, we'll use the "generate" command. To generate the hello-world component:
            1 $ ng generate component hello-world
            2 CREATE src/app/hello-world/hello-world.component.css (0 bytes)
            3 CREATE src/app/hello-world/hello-world.component.html (30 bytes)
            4 CREATE src/app/hello-world/hello-world.component.spec.ts (657 bytes)
            5 CREATE src/app/hello-world/hello-world.component.ts (288 bytes)
            6 UPDATE src/app/app.module.ts (414 bytes)
(B)     So how do we actually define a new Component ? A basic Component has 2 parts:
            1. A Component decorator
            2. A component definition class
        Let's look at the component code and then take these 1 at a time. Open up our 1st TS file: src/app/hello-world/hello-world.component.ts        code/first-app/angular-hello-world/src/app/hello-world/hello-world.component.ts
            1 import { Component, OnInit } from '@angular/core';
            2
            3 @Component({
            4 selector: 'app-hello-world',
            5 templateUrl: './hello-world.component.html',
            6 styleUrls: ['./hello-world.component.css']
            7 })
            8 export class HelloWorldComponent implements OnInit {
            9
            10 constructor() { }
            11
            12 ngOnInit() {
            13 }
            14
            15 }
        This snippet may seem scary at 1st, but don't worry. We're going to walk through it step by step
        Notice, that we suffix our TS file with .ts instead of .js. The problem is, our browser doesn't know how to interpret TS files
(B)     To solve this gap, the "ng serve" command live-compiles our .ts to a .js file automatically
        
        Importing Dependencies
(B)     The "import" statement defines the modules we want to use to write our code. Here we're importing 2 things: Component and OnInit
        We import Component from the module "@angular/core". The "@angular/core" portion tells our program, where to find the dependencies, that we're looking for
        In this case, we're telling the compiler, that "@angular/core" defines and exports 2 JS/TS objects called Component and OnInit. Similarly, we import OnInit from the same module
(B)     As we'll learn later, OnInit helps us to run code, when we initialize the component. For now, don't worry about it
(B)     Notice, that the structure of this import is of the format "import { things } from wherever". In the { things } part, what we are doing, is called "destructuring"
        "Destructuring" is a feature provided by ES6 and TS. We will talk more about it in the next chapter
        The idea with "import" is a lot like import in Java or "require" in Ruby: we're pulling in these dependencies from another module and making these dependencies available for use in this file
        
        Component Decorators
        After importing our dependencies, we are declaring the component:                   code/first-app/angular-hello-world/src/app/hello-world/hello-world.component.ts
            3 @Component({
            4 selector: 'app-hello-world',
            5 templateUrl: './hello-world.component.html',
            6 styleUrls: ['./hello-world.component.css']
            7 })
        If you're new to TS, then the syntax of this next statement might seem a little foreign:
            1 @Component({
            2 // ...
            3 })
(B)     What is going on here ? These are called decorators. We can think of decorators as metadata added to our code. When we use @Component on the HelloWorld class, we are "decorating" HelloWorld as a Component
(B)     We want to be able to use this component in our markup by using a <app-hello-world> tag. To do that, we configure the "@Component" and specify the selector as app-hello-world
            1 @Component({
            2 selector: 'app-hello-world'
            3 // ... more here
            4 })
        The syntax of Angular's component selectors is similar to CSS selectors (though Angular components have some special syntax for selectors, which we'll cover later on)
        For now, know, that with this selector we're defining a new tag, that we can use in our markup. The selector property here indicates, which DOM element this component is going to use
(B)     In this case, any <app-hello-world></app-hello-world> tags, that appear within a template, will be compiled using the HelloWorldComponent class and get any attached functionality
        
        Adding a template with templateUrl
        In our component, we are specifying a templateUrl of ./hello-world.component.html. This means, that we will load our template from the file "hello-world.component.html" in the same directory, as our component
        Let's take a look at that file:                code/first-app/angular-hello-world/src/app/hello-world/hello-world.component.html
            1 <p>
            2 hello-world works!
            3 </p>
        Here we're defining a "p" tag with some basic text in the middle. When Angular loads this component, it will also read from this file and use it, as the template for our component
        
        Adding a template
(B)     We can define templates 2 ways, either by using the template key in our @Component object or by specifying a "templateUrl". We could add a template to our @Component by passing the template option:
            1 @Component({
            2 selector: 'app-hello-world',
            3 template: `
            4 <p>
            5 hello-world works inline!
            6 </p>
            7 `
            8 })
(B)     Notice, that we're defining our template string between backticks (` … `). This is a new (and fantastic) feature of ES6, that allows us to do multiline strings
        Using backticks for multiline strings makes it easy to put templates inside your code files. Should u really be putting templates in your code files ? 
(B)     The answer is: it depends. For a long time, the commonly held belief was, that u should keep your code and templates separate
        While this might be easier for some teams, for some projects it adds overhead, because u have switch between a lot of files
(B)     Personally, if our templates are shorter than a page, we much prefer to have the templates alongside the code (that is, within the .ts file)
        When we see both the logic and the view together, it's easy to understand, how they interact with one another
        The biggest drawback to mixing views and our code is, that many editors don't support syntax highlighting of the internal strings (yet)
        Hopefully, we'll see more editors supporting syntax highlighting HTML within template strings soon
        
        Adding CSS Styles with styleUrls
        Notice the key styleUrls:         styleUrls: ['./hello-world.component.css']
        This code says, that we want to use the CSS in the file hello-world.component.css, as the styles for this component
(B)     Angular uses a concept called "style-encapsulation", which means, that styles specified for a particular component only apply to that component
        We talk more about this in-depth later on in the book in the Styling section of Advanced Components
        For now, we're not going to use any component-local styles, so u can leave this as-is (or delete the key entirely)
(B)     You may have noticed, that this key is different from template in that, it accepts an array as it's argument - this is because we can load multiple stylesheets for a single component
        
        Loading Our Component
        Now, that we have our 1st component code filled out, how do we load it in our page ? 
(B)     If we visit our application again in the browser, we'll see that nothing changed - that's because we only created the component, but we're not using it yet
        In order to change that, we need to add our component tag to a template, that is already being rendered. Open the file:     first_app/angular-hello-world/src/app/app.component
        Remember, that because we configured our HelloWorldComponent with the selector "app-hello-world", we can use the <app-hello-world></app-hello-world> in our template
        Let's add the <app-hello-world> tag to "app.component.html"    Delete the content in app.component.html and replace it with:   code/first-app/angular-hello-world/src/app/app.component.html
            1 <h1>
            2 {{title}}
            3
            4 <app-hello-world></app-hello-world>
            5 </h1>
        Now refresh the page and take a look: Hello world works. It works!

    ■ ADDING DATA TO THE COMPONENT

        Right now, our component renders a static template, which means, our component isn't very interesting. Let's imagine, that we have an app, which will show a list of users and we want to show their names
        Before we render the whole list, we 1st need to render an individual user. So let's create a new component, that will show a user's name. To do this, we will use the "ng generate" command again:
            1 ng generate component user-item
        Remember, that in order to see a component we've created, we need to add it to a template. Let's add our app-user-item tag to app.component.html, so that we can see our changes, as we make them
        Modify app.component.html to look like this:              code/first-app/angular-hello-world/src/app/app.component.html
            1 <h1>
            2 {{title}}
            3
            4 <app-hello-world></app-hello-world>
            5
            6 <app-user-item></app-user-item>
            7 </h1>
        Then refresh the page and confirm, that u see the "user-item works!" text on the page. We want our UserItemComponent to show the name of a particular user
        Let's introduce "name" as a new property of our component. By having a "name" property, we will be able to reuse this component for different users (but keep the same markup, logic and styles)
        In order to add a name, we'll introduce a property on the UserItemComponent class to declare it has a local variable named "name"        code/first-app/angular-hello-world/src/app/user-item/user-item.component.ts
            8 export class UserItemComponent implements OnInit {
            9 name: string; // <-- added name property
            10
            11 constructor() {
            12 this.name = 'Felipe'; // set the name
            13 }
            14
            15 ngOnInit() {
            16 }
            17
            18 }
        We've changed 2 things:
        
        1. name Property
        On the UserItemComponent class we added a property. Notice, that the syntax is new relative to ES5 JS. When we write name: string; it means, that we're declaring the name property to be of type string
(A)     Being able to assign a type to a variable, is what gives TS it's name. By setting the type of this property to string, the compiler ensures, that "name" variable is a string and it will throw an error, if we try to assign, say, a number to this property
        This syntax is also the way, TS defines instance properties. By putting "name: string" in our code like this, we're giving every instance of UserItemComponent a property name
        
        2. A Constructor
(B)     On the UserItemComponent class we defined a constructor, i.e. a function, that is called, when we create new instances of this class. In our constructor, we can assign our "name" property by using this.name
        When we write:        code/first-app/angular-hello-world/src/app/user-item/user-item.component.ts
            11 constructor() {
            12 this.name = 'Felipe'; // set the name
            13 }
        we're saying, that whenever a new UserItemComponent is created, set the name to 'Felipe'
        
        Rendering The Template                                                  code/first-app/angular-hello-world/src/app/user-item/user-item.component.html
        When we have a property on a component, we can show that value in our template, by using 2 curly brackets {{ }} to display the value of the variable in our template        
            1 <p>
            2 Hello {{ name }}
            3 </p>
        On the template notice, that we added a new syntax: {{ name }}. The brackets are called template tags (or sometimes mustache tags).
        Whatever is between the template tags will be expanded as an expression. Here, because the template is bound to our Component, the name will expand to the value of this.name i.e. 'Felipe'

    ■ WORKING WITH ARRAYS

        Now we are able to say "Hello" to a single name, but what if we want to say "Hello" to a collection of names ?
        In Angular, we can iterate over a list of objects in our template, using the syntax *ngFor. The idea is that, we want to repeat the same markup for a collection of objects
        If you've worked with AngularJS 1.X before, you've probably used the "ng-repeat" directive. "NgFor" works much the same way
        Let's create a new component, that will render a list of users. We start by generating a new component:
            ng generate component user-list
        And let's replace our <app-user-item> tag with <app-user-list> in our app.component.html file:        code/first-app/angular-hello-world/src/app/app.component.html
            1 <h1>
            2 {{title}}
            3
            4 <app-hello-world></app-hello-world>
            5
            6 <app-user-list></app-user-list>
            7 </h1>
        In the same way we added a "name" property to our UserItemComponent, let's add a "names" property to this UserListComponent         code/first-app/angular-hello-world/src/app/user-list/user-list.component.ts
        However, instead of storing only a single string, let's set the type of this property to an ARRAY OF STRINGS. An array is notated by the [] after the type:
            8 export class UserListComponent implements OnInit {
            9 names: string[];
            10
            11 constructor() {
            12 this.names = ['Ari', 'Carlos', 'Felipe', 'Nate'];
            13 }
            14
            15 ngOnInit() {
            16 }
            17
            18 }
(B)     The 1st change to point out, is the new "string[]" property on our UserListComponent class. This syntax means, that "names" is typed as an Array of strings. Another way to write this would be "Array<string>"
        We changed our constructor to set the value of this.names to ['Ari', 'Carlos', 'Felipe', 'Nate']. Now, we can update our template to render this list of names. To do this, we will use *ngFor, which will:
            • iterate over a list of items and
            • generate a new tag for each 1
        Here's what our new template will look like:             code/first-app/angular-hello-world/src/app/user-list/user-list.component.html
            1 <ul>
            2 <li *ngFor="let name of names">Hello {{ name }}</li>
            3 </ul>
        We updated the template with 1 ul and 1 li with a new *ngFor="let name of names" attribute. The "*" character and "let" syntax can be a little overwhelming at 1st, so let's break it down:
(B)     The *ngFor syntax says, we want to use the NgFor directive on this attribute. You can think of NgFor akin to a "for" loop - the idea is, that we're creating a new DOM element for every item in a collection
        The value states: "let name of names". "names" is our array of names, as specified on the UserListComponent object. "let name" is called a reference
        When we say "let name of names", we're saying loop over each element in "names" and assign each 1 to a local variable called "name"
        The NgFor directive will render 1 "li" tag for each entry found on the "names" array and declare a local variable "name" to hold the current item being iterated
        This new variable will then be replaced inside the Hello {{ name }} snippet. We didn't have to call the reference variable "name". We could just as well have written:
            1 <li *ngFor="let foobar of names">Hello {{ foobar }}</li>
        But what about the reverse ? Quiz question: what would have happened, if we wrote:
            1 <li *ngFor="let name of foobar">Hello {{ name }}</li>
        Answer: We'd get an error, because "foobar" isn't a property on the component. NgFor repeats the element, that the ngFor is called
        That is, we put it on the "li" tag and not the "ul" tag, because we want to repeat the list element (li) and not the list itself (ul)
        Note, that the capitalization here isn't a typo: NgFor is the capitalization of the class, that implements the logic and ngFor is the "selector" for the attribute we want to use
        If you're feeling adventurous, u can learn a lot about how the Angular core team writes Components, by reading the source directly
        Np. u can find the source of the NgFor directive here: https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts

    ■ USING THE USER ITEM COMPONENT

        Remember, that earlier we created a UserItemComponent ? Instead of rendering each "name" within the UserListComponent, we ought to use UserItemComponent, as a child component 
        - that is, instead of rendering the text "Hello" and the "name" directly, we should let our UserItemComponent specify the template (and functionality) of each item in the list
        To do this, we need to do 3 things:
            1. Configure the UserListComponent to render to UserItemComponent (in the template)
            2. Configure the UserItemComponent to accept the "name" variable as an input and
            3. Configure the UserListComponent template to pass the "name" to the UserItemComponent
        
        1) Rendering the UserItemComponent
        Our UserItemComponent specifies the selector "app-user-item" - let's add that tag to our template:    code/first-app/angular-hello-world/src/app/user-list/user-list.component.html
            1 <ul>
                2 <li *ngFor="let name of names">
                    3 <app-user-item></app-user-item>
                4 </li>
            5 </ul>
        Notice, that we swapped out the text "Hello" and the "name" for the tag "app-user-item". If we reload our browser, this is what we will see:
        It repeats, but sth is wrong here - every name says "Felipe"! We need a way to pass data into the child component
        Thankfully, Angular provides a way to do this: the @Input decorator
        
        2) Accepting Inputs                         code/first-app/angular-hello-world/src/app/user-item/user-item.component.ts
        Remember, that in our UserItemComponent we had set "this.name = 'Felipe';" in the constructor of that component. Now, we need to change this component to accept a value for this property
            1 import {
            2 Component,
            3 OnInit,
            4 Input // <--- added this
            5 } from '@angular/core';
            6
            7 @Component({
            8 selector: 'app-user-item',
            9 templateUrl: './user-item.component.html',
            10 styleUrls: ['./user-item.component.css']
            11 })
            12 export class UserItemComponent implements OnInit {
            13 @Input() name: string; // <-- added Input annotation
            14
            15 constructor() {
            16 // removed setting name
            17 }
            18
            19 ngOnInit() {}
            20 }
        Notice, that we changed the "name" property to have a decorator of @Input. We talk a lot more about Inputs (and Outputs) in the next chapter, but for now, 
(B)     know, that this syntax allows us to pass in a value from the parent template. In order to use "Input", we also had to add it to the list of constants in import
        Lastly, we don't want to set a default value for "name", so we remove that from the constructor. So, now that we have a "name" Input, how do we actually use it ?
        
        3) Passing an Input value                           code/first-app/angular-hello-world/src/app/user-list/user-list.component.html
        To pass values to a component, we use the bracket [] syntax in our template:
            1 <ul>
                2 <li *ngFor="let name of names">
                    3 <app-user-item [name]="name"></app-user-item>
                4 </li>
            5 </ul>
        Notice, that we've added a new attribute on our app-user-item tag: [name]="name"
        In Angular, when we add an attribute in brackets like [foo] - we're saying, we want to pass a value to the input named "foo" on that component
        In this case, notice that the name on the right-hand side comes from the "let name of names" statement in ngFor. That is, consider if we had this instead:
            <li *ngFor="let individualUserName of names">
                <app-user-item [name]="individualUserName"></app-user-item>
            </li>
        The [name] part designates the Input on the UserItemComponent. Notice, that we're not passing the literal string "individualUserName", 
        instead we're passing the value of individualUserName, which is, on each pass, the value of an element of "names"
        We talk more about inputs and outputs in detail in the next chapter. For now, know, that we're:
            1. Iterating over "names"
            2. Creating a new UserItemComponent for each element in "names" and
            3. Passing the value of that "name" into the "name" Input property on the UserItemComponent
        Congratulations ! You've built your 1st Angular app with components !
        Of course, this app is very simple and we'd like to build much more sophisticated applications. Don't worry, in this book we'll show u, how to become an expert writing Angular apps
        In fact, in this chapter, we're going to build a voting-app (Reddit / Product Hunt). This app will feature user interaction and even more components !
        But before we start building a new app, let's take a closer look at how Angular apps are bootstrapped

    ■ BOOTSTRAPPING CRASH COURSE

        Every app has a main entry point. This application was built using Angular CLI (which is built on a tool called "Webpack"). We run this app:
            ng serve
        ng will look at the file angular.json to find the entry point to our app. Let's trace, how ng finds the components we just built
(A)     At a high level, it looks like this:
            • angular.json specifies a "main" file, which in this case is "main.ts"
            • "main.ts" is the entry-point for our app and it bootstraps our application
            • the bootstrap process boots an Angular module – we haven't talked about modules yet, but we will in a minute
            • we use the "AppModule" to bootstrap the app. "AppModule" is specified in src/app/app.module.ts
            • "AppModule" specifies, which component to use, as the top-level component. In this case, it is "AppComponent"
            • AppComponent has <app-user-list> tags in the template and this renders our list of users
        For now, the thing we want to focus on, is the Angular module system: "NgModule". Angular has a powerful concept of modules
        When u boot an Angular app, you're not booting a component directly, but instead u create an "NgModule", which points to the component u want to load
        Take a look at this code:                   code/first-app/angular-hello-world/src/app/app.module.ts
            9 @NgModule({
            10 declarations: [
            11 AppComponent,
            12 HelloWorldComponent,
            13 UserItemComponent,
            14 UserListComponent
            15 ],
            16 imports: [
            17 BrowserModule
            18 ],
            19 providers: [],
            20 bootstrap: [AppComponent]
            21 })
            22 export class AppModule { }
        The 1st thing we see, is an @NgModule decorator. Like all decorators, this @NgModule(...) code adds metadata to the class immediately following (in this case, AppModule)
(B)     @NgModule decorator has 4 keys:
        1) declarations - specifies the components, that are defined in this module
           This is an important idea in Angular: u have to declare components in a "NgModule", before u can use them in your templates
           You can think of an "NgModule" a bit like a "package" and declarations states what components are "owned by" this module
           You may have noticed that, when we used "ng generate", the tool automatically added our components to this declarations list ! 
           The idea is, that when we generated a new component, the ng tool assumed, we wanted it to belong to the current "NgModule"
        2) imports - describes, which dependencies this module has. We're creating a browser app, so we want to import the BrowserModule
           If your module depends on other modules, you list them here
                import vs. imports ? You might be asking the question: "What's the difference between importing a class at the top of the file and putting a module in imports?"
                The short answer is, that u put sth in your NgModule's imports, if you're going to be using it in your templates / with dependency injection
                We haven't talked about dependency injection, but rest assured, we will
        3) providers - is used for dependency injection. So to make a service available to be injected throughout our application, we will add it here. Learn more about this in the section on Dependency Injection
        4) bootstrap - tells Angular, that when this module is used to bootstrap an app, we need to load the AppComponent component as the top-level component

    ■ EXPANDING OUR APPLICATION

        Now, that we know how to create a basic application, let's build our Reddit clone. Before we start coding, it's a good idea to look over our app and break it down into its logical components
        We're going to make 2 components in this app:
            1. The overall application, which contains the form used to submit new articles (marked in magenta in the picture)
            2. Each article (marked in mint green)
        In a larger application, the form for submitting articles would probably become its own component
        However, having the form be its own component makes the data passing more complex, so we're going to simplify in this chapter and have only 2 components
        For now, 2 components will work fine, but we'll learn how to deal with more sophisticated data architectures in later chapters of this book
        But 1st thing's 1st, let's generate a new application, by running the same "ng new" command we ran before, 
        to create a new application passing it the name of the app we want to create (here, we'll create an application called "angular-reddit"):
            ng new angular-reddit
        We've provided a completed version of our angular-reddit in the example code download. If u ever need more context, be sure to check it out to see, how everything fits together
        
        Adding CSS
        1st thing we want to do, is add some CSS styling, so that our app isn't completely unstyled
        If you're building your app from scratch => u'll want to copy over a few files from our completed example in the "first_app/angular-reddit" folder
        Copy into your application's folder:      • src/index.html    • src/styles.css    • src/app/vendor   • src/assets/images        
        For this project, we're going to be using Semantic-UI¹⁹ to help with the styling. Semantic-UI is a CSS framework, similar to Zurb Foundation²⁰ or Twitter Bootstrap²¹
        We've included it in the sample code download, so all u need to do, is copy over the files specified above
        
        The Application Component
        Let's now build a new component, which will:        1. store our current list of articles        2. contain the form for submitting new articles
        We can find the main application component on the src/app/app.component.ts file
        Let's open this file. Again, we'll see the same initial contents we saw previously          code/first-app/angular-reddit/src/app/app.component.ts
            1 import { Component } from '@angular/core';
            2
            3 @Component({
            4 selector: 'app-root',
            5 templateUrl: './app.component.html',
            6 styleUrls: ['./app.component.css']
            7 })
            8 export class AppComponent {
            9 title = 'angular-reddit';
            10 }
        Notice, that the "title" property was automatically generated for us on the AppComponent. Remove that line, because we aren't using the component "title"
        Below we're going to be submitting new links that have a 'title', which could be confused with the AppComponent title that was auto-generated by Angular CLI
        Keep in mind that the form 'title' is a separate form field from the 'title' in the links below. Let's change the template a bit to include a form for adding links
        We'll use a bit of styling from the semantic-ui package to make the form look a bit nicer:          code/first-app/angular-reddit/src/app/app.component.html
            1 <form class="ui large form segment">
            2 <h3 class="ui header">Add a Link</h3>
            3
            4 <div class="field">
            5 <label for="title">Title:</label>
            6 <input name="title" id="title">
            7 </div>
            8 <div class="field">
            9 <label for="link">Link:</label>
            10 <input name="link" id="link">
            11 </div>
            12 </form>
        We're creating a template that defines two input tags: 1 for the title of the article and the other for the link URL. When we load the browser, u should see the rendered form:
        
        Adding Interaction
        Now, we have the form with input tags, but we don't have any way to submit the data. Let's add some interaction, by adding a submit button to our form
        When the form is submitted, we'll want to call a function to create and add a link. We can do this by adding an interaction event on the <button /> element
(B)     We tell Angular we want to respond to an event, by surrounding the event name in parentheses (). Np. to add a function call to the <button /> onClick event:
            1 <button (click)="addArticle(newtitle, newlink)"
            2 class="ui positive right floated button">
            3 Submit link
            4 </button>
        When the button is clicked, it will call a function called addArticle(), which we need to define on the AppComponent class:        code/first-app/angular-reddit/src/app/app.component.ts
            8 export class AppComponent {
            9 addArticle(title: HTMLInputElement, link: HTMLInputElement): boolean {
            10 console.log(`Adding article title: ${title.value} and link: ${link.value}`);
            11 return false;
            12 }
            13 }
        With the addArticle() function added to the AppComponent and the (click) event added to the <button /> element, this function will be called, when the button is clicked
        Notice, that the addArticle() function can accept 2 arguments: the "title" and the "link" arguments. We need to change our template button to pass those into the call to the addArticle()
        We do this by populating a template variable, by adding a special syntax to the input elements on our form:        code/first-app/angular-reddit/src/app/app.component.html
            1 <form class="ui large form segment">
            2 <h3 class="ui header">Add a Link</h3>
            3
            4 <div class="field">
            5 <label for="title">Title:</label>
            6 <input name="title" id="title" #newtitle> <!-- changed -->
            7 </div>
            8 <div class="field">
            9 <label for="link">Link:</label>
            10 <input name="link" id="link" #newlink> <!-- changed -->
            11 </div>
            12
            13 <!-- added this button -->
            14 <button (click)="addArticle(newtitle, newlink)"
            15 class="ui positive right floated button">
            16 Submit link
            17 </button>
            18
            19 </form>
        Notice, that in the input tags we used the # (hash) to tell Angular to assign those tags to a local variable
(B)     By adding the #newtitle and #newlink to the appropriate <input/> elements, we can pass them as variables into the addArticle() function on the button !
        To recap, what we've done, we've made 4 changes:
            1. Created a button tag in our markup, that shows the user where to click
            2. We created a function named "addArticle", that defines what we want to do, when the button is clicked
            3. We added a (click) attribute on the button, that says "call the function addArticle when this button is pressed"
            4. We added the attribute #newtitle and #newlink to the <input> tags
        
        Let's cover each 1 of these steps in reverse order:
        a) Binding inputs to values                      Notice in our 1st input tag we have the following:
            1 <input name="title" #newtitle>             This markup tells Angular to bind this <input> to the variable "newtitle". The #newtitle syntax is called a "resolve"
        The effect is, that this makes the variable "newtitle" available to the expressions within this view. "newtitle" is now an object, that represents this input DOM element (specifically, the type is HTMLInputElement)
(B)     Because "newtitle" is an object, that means we get the value of the input tag using "newtitle.value". Similarly we add #newlink to the other <input> tag, so that we'll be able to extract the value from it as well
        b) Binding actions to events
        On our button tag we add the attribute (click) to define, what should happen, when the button is clicked on
        When the (click) event happens, we call addArticle with 2 arguments: newtitle and newlink. Where did this function and 2 arguments come from ?
            1. addArticle is a function on our component definition class AppComponent
            2. newtitle comes from the resolve (#newtitle) on our <input> tag named title
            3. newlink comes from the resolve (#newlink) on our <input> tag named link
        All together:
            1 <button (click)="addArticle(newtitle, newlink)"
            2 class="ui positive right floated button">
            3 Submit link
            4 </button>                     The markup class="ui positive right floated button" comes from Semantic UI and it gives the button the pleasant green color
        c) Defining the Action Logic
        On our class AppComponent we define a new function called addArticle. It takes 2 arguments: title and link
(B)     Again, it's important to realize, that title and link are both objects of type HTMLInputElement and not the input values directly
        To get the value from the input, we have to call "title.value". For now, we're just going to console.log out those arguments      code/first-app/angular-reddit/src/app/app.component.ts
            9 addArticle(title: HTMLInputElement, link: HTMLInputElement): boolean {
            10 console.log(`Adding article title: ${title.value} and link: ${link.value}`);
            11 return false;
            12 }
(A)     Notice, that we're using backtick strings again. This is a really handy feature of ES6: backtick strings will expand template variables !
        Here we're putting ${title.value} in the string and this will be replaced with the value of title.value in the string
        Try it out ! Now, when u click the submit button, u can see, that the message is printed on the console
        
        Adding the Article Component
        Now we have a form to submit new articles, but we aren't showing the new articles anywhere
        Because every article submitted is going to be displayed as a list on the page, this is the perfect candidate for a new component
        Let's create a new component to represent the individual submitted articles - for that, let's use the "ng" tool to generate a new component:
            ng generate component article
        We have 3 parts to defining this new component:
            1. Define the ArticleComponent view in the template
            2. Define the ArticleComponent properties by annotating the class with @Component
            3. Define a component-definition class (ArticleComponent), which houses our component logic
        Let's talk through each part in detail:

        1) Creating the ArticleComponent template
        We define the template using the file article.component.html:               code/first-app/angular-reddit/src/app/article/article.component.html
            1 <div class="four wide column center aligned votes">
            2 <div class="ui statistic">
            3 <div class="value">
            4 {{ votes }}
            5 </div>
            6 <div class="label">
            7 Points
            8 </div>
            9 </div>
            10 </div>
            11 <div class="twelve wide column">
            12 <a class="ui large header" href="{{ link }}">
            13 {{ title }}
            14 </a>
            15 <ul class="ui big horizontal list voters">
            16 <li class="item">
            17 <a href (click)="voteUp()">
            18 <i class="arrow up icon"></i>
            19 upvote
            20 </a>
            21 </li>
            22 <li class="item">
            23 <a href (click)="voteDown()">
            24 <i class="arrow down icon"></i>
            25 downvote
            26 </a>
            27 </li>
            28 </ul>
            29 </div>
        There's a lot of markup here, so let's break it down:
        We have 2 columns:
            1. the number of votes on the left and            2. the article info on the right
        We specify these columns with the CSS classes 4 wide column and 12 wide column respectively (remember, that these come from SemanticUI's CSS)
        We're showing votes and the title with the template expansion strings {{ votes }} and {{ title }}
        The values come from the value of "votes" and "title" property of the ArticleComponent class, which we'll define in a minute
        Notice, that we can use template strings in attribute values, as in the "href" of the "a" tag: href="{{ link }}"
        In this case, the value of the "href" will be dynamically populated with the value of link from the component class
        On our upvote / downvote links we have an action. We use (click) to bind voteUp() / voteDown() to their respective buttons
        When the upvote button is pressed, the voteUp() function will be called on the ArticleComponent class (similarly with downvote and voteDown())
        
        2) Creating the ArticleComponent                          code/first-app/angular-reddit/src/app/article/article.component.ts
            7 @Component({
            8 selector: 'app-article',
            9 templateUrl: './article.component.html',
            10 styleUrls: ['./article.component.css'],
            11 })
        1st, we define a new Component with @Component. The selector says, that this component is placed on the page by using the tag <app-article> (i.e. the selector is a tag name)
        So, the most essential way to use this component, would be to place the following tag in our markup: <app-article></app-article> These tags will remain in our view, when the page is rendered
        
        3) Creating the ArticleComponent Definition Class
        Finally, we create the ArticleComponent definition class:                   code/first-app/angular-reddit/src/app/article/article.component.ts
            12 export class ArticleComponent implements OnInit {
            13 @HostBinding('attr.class') cssClass = 'row';
            14 votes: number;
            15 title: string;
            16 link: string;
            17
            18 constructor() {
            19 this.title = 'Angular';
            20 this.link = 'http://angular.io';
            21 this.votes = 10;
            22 }
            23
            24 voteUp() {
            25 this.votes += 1;
            26 }
            27
            28 voteDown() {
            29 this.votes -= 1;
            30 }
            31
            32 ngOnInit() {
            33 }
            34
            35 }
        Here we create 4 properties on ArticleComponent:
            1. cssClass - the CSS class we want to apply to the "host" of this component
            2. votes - a number representing the sum of all upvotes, minus the downvotes
            3. title - a string holding the title of the article
            4. link - a string holding the URL of the article
        We want each app-article to be on its own row. We're using Semantic UI and Semantic provides a CSS class for rows²² called row      ²²http://semantic-ui.com/collections/grid.html
(B)     In Angular, a component "host" is the element this component is attached to. We can set properties on the host element, by using the @HostBinding() decorator
        In this case, we're asking Angular to keep the value of the host elements class to be in sync with the property cssClass        
        We import HostBinding from the package @angular/core. Np. we can add HostBinding like this:
            1 import { Component, HostBinding } from '@angular/core';
        By using @HostBinding() the host element (the app-article tag) we want to set the class attribute to have "row"
        Using the @HostBinding() is nice, because it means, we can encapsulate the app-article markup within our component
(B)     That is, we don't have to both use an "app-article" tag and require a class="row" in the markup of the parent view
        By using the @HostBinding decorator, we're able to configure our host element from within the component
        In the constructor() we set some default attributes:                code/first-app/angular-reddit/src/app/article/article.component.ts
            18 constructor() {
            19 this.title = 'Angular';
            20 this.link = 'http://angular.io';
            21 this.votes = 10;
            22 }
        And we define 2 functions for voting, 1 for voting up voteUp and 1 for voting down voteDown:       code/first-app/angular-reddit/src/app/article/article.component.ts
            24 voteUp() {
            25 this.votes += 1;
            26 }
            27
            28 voteDown() {
            29 this.votes -= 1;
            30 }                        In voteUp we increment "this.votes" by 1. Similarly we decrement for voteDown
        
        4) Using the app-article Component
        In order to use this component and make the data visible, we have to add a <app-article></app-article> tag somewhere in our markup
        In this case, we want the AppComponent to render this new component, so let's update the code in that component. Add the <app-article> tag to the AppComponent's template, right after the closing </form> tag:
            1 <button (click)="addArticle(newtitle, newlink)"
            2 class="ui positive right floated button">
            3 Submit link
            4 </button>
            5 </form>
            6
            7 <div class="ui grid posts">
            8 <app-article>
            9 </app-article>
            10 </div>
        If we generated the ArticleComponent using Angular CLI (via "ng generate component"), by default it should have "told" Angular about our "app-article" tag (more on that below)
(B)     However, if we created this component "by hand" and we reload the browser now, we might see, that the <app-article> tag wasn't compiled. Oh no !
        Whenever hitting a problem like this, the 1st thing to do, is open up your browser's developer console
(B)     If we inspect our markup (see screenshot below), we can see, that the "app-article" tag is on our page, but it hasn't been compiled into markup. Why not ?
        This happens, because the AppComponent component doesn't know about the ArticleComponent component yet
            Angular 1 Note: if u've used Angular 1, it might be surprising, that our app doesn't know about our new app-article component. This is because in Angular 1, directives match globally
            However, in Angular u need to explicitly specify, which components (and therefore, which selectors) u want to use
            On the 1 hand, this requires a little more configuration. On the other hand, it's great for building scalable apps, because it means, we don't have to share our directive selectors in a global namespace
        In order to tell our AppComponent about our new ArticleComponent component, we need to add the ArticleComponent to the list of declarations in this "NgModule"
(B)     We add ArticleComponent to our declarations, because ArticleComponent is part of this module (AppModule)
(B)     However, if ArticleComponent were part of a different module, then we might import it with imports
        We'll discuss more about "NgModules" later on, but for now, know that when u create a new component, u have to put in a declarations in NgModules       code/first-app/angular-reddit/src/app/app.module.ts
            5 import { AppComponent } from "./app.component";
            6 import { ArticleComponent } from "./article/article.component";
            7
            8 @NgModule({
            9 declarations: [
            10 AppComponent,
            11 ArticleComponent // <-- added this
            12 ],
        See here, that we are:            1. importing ArticleComponent and then        2. Adding ArticleComponent to the list of declarations
        After you've added ArticleComponent to declarations in the NgModule, if we reload the browser, we should see the article properly rendered:
        However, clicking on the vote up / vote down links will cause the page to reload, instead of updating the article list
(B)     JS, by default, propagates the click event to all the parent components. Because the click event is propagated to parents, our browser is trying to follow the empty link, which tells the browser to reload
        To fix that, we need to make the click event handler to return "false". This will ensure, the browser won't try to refresh the page
        Let's update our code, so that each of the functions voteUp() and voteDown() return a boolean value of false (tells the browser not to propagate the event upwards):
            1 voteDown(): boolean {
            2 this.votes -= 1;
            3 return false;
            4 }
            5 // and similarly with `voteUp()`
        Now, when we click the links, we'll see, that the votes increase / decrease properly without a page refresh

    ■ RENDERING MULTIPLE ROWS

        Right now, we only have 1 article on the page and there's no way to render more, unless we paste another <app-article> tag
        And even, if we did that, all the articles would have the same content, so it wouldn't be very interesting
        
        Creating an Article class
        A good practice, when writing Angular code, is to try to isolate the data structures we are using, from the component code
        To do this, let's create a data structure, that represents a single article. Let's add a new file "article.model.ts" to define an Article class, that we can use        code/first-app/angular-reddit/src/app/article/article.model.ts
            1 export class Article {
            2 title: string;
            3 link: string;
            4 votes: number;
            5
            6 constructor(title: string, link: string, votes?: number) {
            7 this.title = title;
            8 this.link = link;
            9 this.votes = votes || 0;
            10 }
            11 }
        Here we are creating a new class, that represents an Article. Note, that this is a plain class and not an Angular component. In the Model-View-Controller pattern, this would be the Model
        Each article has a title, a link and a total for the votes. When creating a new article, we need the title and the link. The votes parameter is optional (denoted by the ? at the end of the name) and defaults to zero
        Now, let's update the ArticleComponent code to use our new Article class. Instead of storing the properties directly on the ArticleComponent component, let's store the properties on an instance of the Article class
        1st let's import the class:        code/first-app/angular-reddit/src/app/article/article.component.ts
            6 import { Article } from './article.model';
        Then let's use it:                 code/first-app/angular-reddit/src/app/article/article.component.ts
            13 export class ArticleComponent implements OnInit {
            14 @HostBinding('attr.class') cssClass = 'row';
            15 article: Article;
            16
            17 constructor() {
            18 this.article = new Article(
            19 'Angular',
            20 'http://angular.io',
            21 10);
            22 }
            23
            24 ngOnInit() {
            25 }
            26
            27 }
        Notice, what we've changed: instead of storing the title, link and votes properties directly on the component, we're storing a reference to an "article"
        What's neat, is that we've defined the type of article to be our new Article class
        When it comes to voteUp (and voteDown), we don't increment votes on the component, but rather, we need to increment the votes on the article
        However, this refactoring introduces another change: we need to update our view to get the template variables from the right location
        To do that, we need to change our template tags to read from article. That is, where before we had {{ votes }}, we need to change it to {{ article.votes }} and same with title and link:   code/first-app/angular-reddit/src/app/article/article.component.html
            1 <div class="four wide column center aligned votes">
            2 <div class="ui statistic">
            3 <div class="value">
            4 {{ article.votes }}
            5 </div>
            6 <div class="label">
            7 Points
            8 </div>
            9 </div>
            10 </div>
            11 <div class="twelve wide column">
            12 <a class="ui large header" href="{{ article.link }}">
            13 {{ article.title }}
            14 </a>
            15 <ul class="ui big horizontal list voters">
            16 <li class="item">
            17 <a href (click)="voteUp()">
            18 <i class="arrow up icon"></i>
            19 upvote
            20 </a>
            21 </li>
            22 <li class="item">
            23 <a href (click)="voteDown()">
            24 <i class="arrow down icon"></i>
            25 downvote
            26 </a>
            27 </li>
            28 </ul>
            29 </div>
        Reload the browser and everything still works. This situation is better, but sth in our code is still off:                   ²³http://en.wikipedia.org/wiki/Law_of_Demeter
        our voteUp and voteDown methods break the encapsulation of the Article class, by changing the article's internal properties directly
        voteUp and voteDown currently break the Law of Demeter²³, which says, that a given object should assume as little as possible about the structure / properties of other objects
        The problem is, that our ArticleComponent component knows too much about the Article class internals
        To fix that, let's add voteUp and voteDown methods on the Article class (we'll also add a domain function, which we'll talk about in a moment):       code/first-app/angular-reddit/src/app/article/article.model.ts
            1 export class Article {
            2 title: string;
            3 link: string;
            4 votes: number;
            5
            6 constructor(title: string, link: string, votes?: number) {
            7 this.title = title;
            8 this.link = link;
            9 this.votes = votes || 0;
            10 }
            11
            12 voteUp(): void {
            13 this.votes += 1;
            14 }
            15
            16 voteDown(): void {
            17 this.votes -= 1;
            18 }
            19
            20 // domain() is a utility function that extracts
            21 // the domain from a URL, which we'll explain shortly
            22 domain(): string {
            23 try {
            24 // e.g. http://foo.com/path/to/bar
            25 const domainAndPath: string = this.link.split('//')[1];
            26 // e.g. foo.com/path/to/bar
            27 return domainAndPath.split('/')[0];
            28 } catch (err) {
            29 return null;
            30 }
            31 }
            32 }
        We can then change ArticleComponent to call these methods:        code/first-app/angular-reddit/src/app/article/article.component.ts
            13 export class ArticleComponent implements OnInit {
            14 @HostBinding('attr.class') cssClass = 'row';
            15 article: Article;
            16
            17 constructor() {
            18 this.article = new Article(
            19 'Angular',
            20 'http://angular.io',
            21 10);
            22 }
            23
            24 voteUp(): boolean {
            25 this.article.voteUp();
            26 return false;
            27 }
            28
            29 voteDown(): boolean {
            30 this.article.voteDown();
            31 return false;
            32 }
            33
            34 ngOnInit() {
            35 }
            36
            37 }
        Why do we have a voteUp function in both the model and the component ? The reason we have a voteUp() and a voteDown() on both classes is, because each function does a slightly different thing
        The idea is, that the voteUp() on the ArticleComponent relates to the component view, whereas the Article model voteUp() defines what mutations happen in the model
        That is, it allows the Article class to encapsulate what functionality should happen to a model, when voting happens
        In a "real" app, the internals of the Article model would probably be more complicated, np. make an API request to a webserver and u wouldn't want to have that sort of modelspecific code in your component controller
        Similarly, in the ArticleComponent we return false; as a way to say "don't propagate the event" - this is a view-specific piece of logic 
        and we shouldn't allow the Article model's voteUp() function to have knowledge about that sort of view-specific API. That is, the Article model should allow voting apart from the specific view
        After reloading our browser, we'll notice everything works the same way, but we now have clearer, simpler code. Checkout our ArticleComponent component definition now: it's so short !
(B)     We've moved a lot of logic out of our component and into our models. The corresponding MVC guideline here might be Fat Models, Skinny Controllers²⁴
(B)     The idea is, that we want to move most of our logic to our models, so that our components do the minimum work possible
        
        Storing Multiple Articles
        Let's write the code, that allows us to have a list of multiple Articles. Let's start by changing "AppComponent" to have a collection of articles:      ²⁴http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model        code/first-app/angular-reddit/src/app/app.component.ts
            1 import { Component } from '@angular/core';
            2 import { Article } from './article/article.model'; // <-- import this
            3
            4 @Component({
            5 selector: 'app-root',
            6 templateUrl: './app.component.html',
            7 styleUrls: ['./app.component.css']
            8 })
            9 export class AppComponent {
            10 articles: Article[]; // <-- component property
            11
            12 constructor() {
            13 this.articles = [
            14 new Article('Angular', 'http://angular.io', 3),
            15 new Article('Fullstack', 'http://fullstack.io', 2),
            16 new Article('Angular Homepage', 'http://angular.io', 1),
            17 ];
            18 }
        Note, that the above code block is not the complete AppComponent class. We also have the addArticle function. Notice, that our AppComponent has the line:
            1 articles: Article[];
        The Article[] might look a little unfamiliar. We're saying here, that articles is an Array of Articles. Another way this could be written is Array<Article>
        The word for this pattern is generics. It's a concept seen in Java, C# and other languages. The idea is, that our collection (the Array) is typed
        That is, the Array is a collection, that will only hold objects of type Article. In order to have access to the Article class, we 1st have to import it, as we do up top
        We populate this Array by setting this.articles in the constructor:        code/first-app/angular-reddit/src/app/app.component.ts
            12 constructor() {
            13 this.articles = [
            14 new Article('Angular', 'http://angular.io', 3),
            15 new Article('Fullstack', 'http://fullstack.io', 2),
            16 new Article('Angular Homepage', 'http://angular.io', 1),
            17 ];
            18 }
        Configuring the ArticleComponent with inputs
        Now, that we have a list of Article models, how can we pass them to our Article-Component component ?
        Here again we use Inputs. Previously, we had our ArticleComponent class defined like this:        code/first-app/angular-reddit/src/app/article/article.component.ts
            13 export class ArticleComponent implements OnInit {
            14 @HostBinding('attr.class') cssClass = 'row';
            15 article: Article;
            16
            17 constructor() {
            18 this.article = new Article(
            19 'Angular',
            20 'http://angular.io',
            21 10);
            22 }
        The problem here is, that we've hard coded a particular Article in the constructor. The point of making components is not only encapsulation, but also reusability
        What we would really like to do, is to configure the Article we want to display. If np. we had 2 articles, article1 and article2, 
        we would like to be able to reuse the app-article component, by passing an Article as a "parameter" to the component like this:
            1 <app-article [article]="article1"></app-article>
            2 <app-article [article]="article2"></app-article>
        Angular allows us to do this, by using the Input decorator on a property of a Component:
            1 class ArticleComponent {
            2 @Input() article: Article;
            3 // ...
        Now, if we have an Article in a variable myArticle, we could pass it to our ArticleComponent in our view. Remember, we can pass a variable in an element, by surrounding it in square brackets [variableName], like so:
            1 <app-article [article]="myArticle"></app-article>
        Notice the syntax here: we put the name of the input in brackets as in: [article] and the value of the attribute is what we want to pass into that input
        Then and this is important, the this.article on the ArticleComponent instance will be set to myArticle. We can think about the variable myArticle, as being passed as a parameter (i.e. input) to our components
        Here's what our ArticleComponent component now looks like using @Input:        code/first-app/angular-reddit/src/app/article/article.component.ts
            1 import {
            2 Component,
            3 OnInit,
            4 Input, // <-- added,
            5 HostBinding
            6 } from '@angular/core';
            7 import { Article } from './article.model'; // <-- added
            8
            9 @Component({
            10 selector: 'app-article',
            11 templateUrl: './article.component.html',
            12 styleUrls: ['./article.component.css']
            13 })
            14 export class ArticleComponent implements OnInit {
            15 @HostBinding('attr.class') cssClass = 'row';
            16 @Input() article: Article;
            17
            18 constructor() {
            19 // article is populated by the Input now,
            20 // so we don't need anything here
            21 }
            22
            23 voteUp(): boolean {
            24 this.article.voteUp();
            25 return false;
            26 }
            27
            28 voteDown(): boolean {
            29 this.article.voteDown();
            30 return false;
            31 }
            32
            33 ngOnInit() {
            34 }
            35
            36 }
        Don't forget to import!
        Notice, that we import the Input class from @angular/core. We've also imported our Article model, as we did with the AppComponent earlier
        
        Rendering a List of Articles
        Earlier we configured our AppComponent to store an array of articles. Now, let's configure AppComponent to render all the articles
        To do so, instead of having the <app-article> tag alone, we are going to use the NgFor directive to iterate over the list of articles and render a app-article for each 1:
        Let's add this in the template of the AppComponent @Component, just below the closing <form> tag:
        
        Submit link
            </button>
            </form>
            <!-- start adding here -->
            <div class="ui grid posts">
            <app-article
            *ngFor="let article of articles"
            [article]="article">
            </app-article>
            </div>
            <!-- end adding here -->
        Remember, when we rendered a list of names as a bullet list using the NgFor directive earlier in the chapter ? This syntax also works for rendering multiple components
        The *ngFor="let article of articles" syntax will iterate through the list of articles and create the local variable article (for each item in the list)
        To specify the article input on a component, we are using the [inputName]="inputValue" expression
        In this case, we're saying, that we want to set the article input to the value of the local variable article set by ngFor
        We are using the variable article many times in that previous code snippet, it's (potentially) clearer, if we rename the temporary variable created by NgFor to foobar:
            1 <app-article
            2 *ngFor="let foobar of articles"
            3 [article]="foobar">
            4 </app-article>
        So here we have 3 variables:
            1. "articles" which is an Array of Articles, defined on the AppComponent
            2. "foobar" which is a single element of articles (an Article), defined by NgFor
            3. "article" which is the name of the field defined on inputs of the
        ArticleComponent
        Basically, NgFor generates a temporary variable foobar and then we're passing it in to app-article
        Reloading our browser now, we will see all articles will be rendered: Multiple articles being rendered

    ■ ADDING NEW ARTICLES

        Now, we need to change addArticle to actually add new articles, when the button is pressed. Change the addArticle method to match the following:        code/first-app/angular-reddit/src/app/app.component.ts
            20 addArticle(title: HTMLInputElement, link: HTMLInputElement): boolean {
            21 console.log(`Adding article title: ${title.value} and link: ${link.value}`);
            22 this.articles.push(new Article(title.value, link.value, 0));
            23 title.value = '';
            24 link.value = '';
            25 return false;
            26 }
        This will:
            1. create a new Article instance with the submitted title and URL            2. add it to the array of Articles and            3. clear the input field values
        How are we clearing the input field values ? Well, if u recall, title and link are HTMLInputElement objects. That means, we can set their properties
        When we change the value property, the input tag on our page changes. After adding a new article in our input fields and clicking the Submit Link, we will see the new article added !

    ■ FINISHING TOUCHES

        Displaying the Article Domain
        As a nice touch, let's add a hint next to the link, that shows the domain, where the user will be redirected to, when the link is clicked
        Let's add a domain method to the Article class:        code/first-app/angular-reddit/src/app/article/article.model.ts
            22 domain(): string {
            23 try {
            24 // e.g. http://foo.com/path/to/bar
            25 const domainAndPath: string = this.link.split('//')[1];
            26 // e.g. foo.com/path/to/bar
            27 return domainAndPath.split('/')[0];
            28 } catch (err) {
            29 return null;
            30 }
            31 }
        Let's add a call to this function on the ArticleComponent's template:
            1 <div class="twelve wide column">
            2 <a class="ui large header" href="{{ article.link }}">
            3 {{ article.title }}
            4 </a>
            5 <!-- right here -->
            6 <div class="meta">({{ article.domain() }})</div>
            7 <ul class="ui big horizontal list voters">
            8 <li class="item">
            9 <a href (click)="voteUp()">
        And now, when we reload the browser, we will see the domain name of each URL (note: URL must include http:// )
        
        Re-sorting Based on Score
        Clicking and voting on articles, we'll see, that sth doesn't feel quite right: our articles don't sort based on the score ! We definitely want to see the highest-rated items on top and the lower ranking ones sink to the bottom
        We're storing the articles in an Array in our AppComponent class, but that Array is unsorted. An easy way to handle this, is to create a new method sortedArticles on AppComponent:       code/first-app/angular-reddit/src/app/app.component.ts
            28 sortedArticles(): Article[] {
            29 return this.articles.sort((a: Article, b: Article) => b.votes - a.votes);
            30 }
        ES6 Arrow Function
        The above code snippet uses "arrow" (=>) functions from ES6. You can read more about arrow functions here²⁵         ²⁵https://developer.mozilla.org/en-US/docs/Web/JS/Reference/Functions/Arrow_functions
        sort() We're also calling the sort() function, which is a built-in, which u can read about here²⁶                    ²⁶https://developer.mozilla.org/en-US/docs/Web/JS/Reference/Global_Objects/Array/sort
        In our ngFor, we can iterate over sortedArticles() (instead of articles directly):
            1 <div class="ui grid posts">
            2 <app-article
            3 *ngFor="let article of sortedArticles()"
            4 [article]="article">
            5 </app-article>
            6 </div>
                            
    ■ DEPLOYMENT

        Now, that we have an app that runs, let's get it live on the internet, so that we can share it with our friends !
        Deployment and performance in production-ready apps is an intermediate topic, that we'll cover in a future chapter. For now, we're going to gloss over the details and just show, how easy a basic deployment can be
(A)     Deploying our app is the act of pushing our code to a server, where it can be accessed by others. Broadly speaking, the idea is that we're going to:
            • compile all of our TS code into JS (which the browser can read)
            • bundle all of our JS code files into 1 or 2 files
            • and then upload our JS, HTML, CSS and images to a server
        Ultimately, this Angular app is an HTML file, that loads JS code. So, we need to upload our code to a computer somewhere on the internet. But 1st, let's build our Angular app
        
        Building Our App for Production
        The Angular CLI tool we used to generate this app, can be used to build our app for production. In fact, we just type a single command. In first_app/angular-reddit, type the following:
(B)         ng build --prod
        This command tells the ng tool to build our application for a production environment. This command will run for a little while and when it finishes, u should have a "dist" folder on your disk
            1 $ ls dist/angular-reddit
            2 136B assets/
            3 5.3K favicon.ico
            4 27K flags.9c74e172f87984c48ddf.png
            5 306K icons.2980083682e94d33a66e.svg
            6 119K icons.706450d7bba6374ca02f.ttf
            7 55K icons.97493d3f11c0a3bd5cbd.woff2
            8 70K icons.d9ee23d59d0e0e727b51.woff
            9 59K icons.f7c2b4b747b1a225eb8d.eot
            10 1.1K index.html
            11 1.4K inline.44deb5fed75ee6385e18.bundle.js
            12 17K main.c683e6eda100e8873d71.bundle.js
            13 82K polyfills.b81504c68200c7bfeb16.bundle.js
            14 503K styles.7f23e351d688b00e8a5b.bundle.css
            15 440K vendor.cc4297c08c0803bddc87.bundle.js
(B)     These files are the full compiled result of your app. Notice, that there is a long string of characters in the middle of each file such as:
            1 main.c683e6eda100e8873d71.bundle.js
(B)     Those characters are a hash of the content (and may not match on your computer). If u look at each file, u can see, that we have some icons, the index.html, a main.js, a polyfills.js, a vendor.js and some styles.css
        Now all the need to do, is upload these to our server
        
        Uploading to a Server                                                                                  ²⁷https://zeit.co/now
        There are lots of ways to host your HTML and JS. For this demo, we're going to use the easiest way possible: now²⁷. If u don't want to use "now", you're free to use whatever method u want
        Np. u can host sites on Heroku, AWS S3, upload files to your own server via FTP, etc. The important thing is, that the server exposes all of the files in our dist folder onto the internet
        
(A)     UWAGA !!! Uruchamianie z dysku "index.html" - nie działa. Przeglądarka ma Same-Origin Policy (SOP) - blokuje możliwość korzystania przez index.html z plików zewnętrznych
        Wszystkie pliki trzeba wrzucić na github + z pliku "index.html" trzeba usunąć znacznik: <base href="/">

        Installing "now"
        We can install "now" using npm:
            1 npm install -g now
        To deploy a site with now is very easy:
            1 cd dist/angular-reddit    # change into the dist folder
            2 now
        The "now" command should ask u a couple of questions (such as your email address) and u'll need to check your email and click the link inside
        After you've confirmed your account (or if u had 1 already), "now" will upload your code and then give u a URL to view to see your application
        Visit that URL and view your app. If it works, try sending the URL to a friend ! Congratulations! You've built and deployed your 1st Angular app !

    ■ WRAPPING UP

        We did it! We've created our 1st Angular App. That wasn't so bad, was it ? There's lots more to learn: understanding data flow, making AJAX requests, built-in directives, routing, manipulating the DOM etc.
        But for now, bask in our success ! Much of writing Angular apps is just, as we did above:
(B)         1. Split your app into components        2. Create the views        3. Define your models        4. Display your models        5. Add interaction
        In the future chapters of this book, we'll cover everything u need to write sophisticated apps with Angular

II. TS

    ■ ANGULAR IS BUILT IN TS
                                                                                 ³⁰ https://www.typescriptlang.org/ 
        Angular is built in a JS-like language called TS³⁰. You might be skeptical of using a new language just for Angular, but it turns out, there are a lot of great reasons to use TS, instead of plain JS
        TS isn't a completely new language, it's a superset of ES6. If we write ES6 code, it's perfectly valid and compilable TS code. Here's a diagram, that shows the relationship between the languages:
(A)         What is ES5 ? What is ES6 ? ES5 is short for "ECMAScript 5", otherwise known as "regular JS". ES5 is the normal JS we all know and love. It runs in more-or-less every browser
            ES6 is the next version of JS, which we talk more about below
        At the publishing of this book, very few browsers will run ES6 out of the box, much less TS
(B)     To solve this issue, we have transpilers (or sometimes called transcompiler). The TS transpiler takes our TS code as input and outputs ES5 code, that nearly all browsers understand
        For converting TS to ES5, there is a single transpiler written by the core TS team. However if we wanted to convert ES6 code (not TS) to ES5, there are 2 major ES6-to-ES5 transpilers: 
        traceur³¹ by Google and babel³² created by the JS community. We're not going to be using either directly for this book, but they're both great projects, that are worth knowing about
        We installed TS in the last chapter, but in case you're just starting out in this chapter, u can install it:
            npm install -g TS                                   ³¹ https://github.com/google/traceur-compiler        ³² https://babeljs.io/
        TS is an official collaboration between Microsoft and Google. That's great news, because with 2 tech heavyweights behind it, we know, that it will be supported for a long time
        Both groups are committed to moving the web forward and as developers, we win because of it
(A)     1 of the great things about transpilers is, that they allow relatively small teams to make improvements to a language, without requiring everyone on the internet upgrade their browser
        1 thing to point out: we don't have to use TS with Angular2. If u want to use ES5 (i.e. "regular" JS) - u definitely can
        There is an ES5 API, that provides access to all functionality of Angular2. Then why should we use TS at all ? Because there are some great features in TS, that make development a lot better

    ■ WHAT DO WE GET WITH TS ?

        There are 5 big improvements, that TS bring over ES5:
            • types     • classes     • decorators    • imports   • language utilities (e.g. destructuring)

    ■ TYPES

        The major improvement of TS over ES6, that gives the language its name, is the typing system. For some people, the lack of type checking is considered 1 of the benefits of using a language like JS
(B)     You might be a little skeptical of type checking, but I'd encourage u to give it a chance. 1 of the great things about type checking is, that:
            1. it helps when writing code, because it can prevent bugs at compile time and
            2. it helps when reading code, because it clarifies your intentions
(B)     It's also worth noting, that types are optional in TS. If we want to write some quick code / prototype a feature - we can omit types and gradually add them, as the code becomes more mature
        TS's basic types are the same ones, we've been using implicitly, when we write "normal" JS code: strings, numbers, booleans, etc.
        Up until ES5, we would define variables with the "var" keyword, like "var fullName;"
        The new TS syntax is a natural evolution from ES5, we still use "var", but now we can optionally provide the variable type along with its name:
(B)         var fullName: string;
        When declaring functions, we can use types for arguments and return values:
(B)         function greetText(name: string): string {return "Hello " + name;}
        In the example above, we are defining a new function called "greetText", which takes 1 argument: "name". The syntax "name: string" says, that this function expects "name" to be a string
        Our code won't compile, if we call this function with anything other, than a string and that's a good thing, because otherwise we'd introduce a bug
        Notice, that the "greetText" function also has a new syntax after the parentheses: ": string {" 
        The colon indicates, that we will specify the return type for this function, which in this case is a string - this is helpful, because:
            1. if we accidentally return anything other, than a string in our code, the compiler will tell us, that we made a mistake 
            2. any other developers, who want to use this function, know precisely what type of object they'll be getting
        Let's see what happens, if we try to write code, that doesn't conform to our declared typing:
            function hello(name: string): string {return 12;}
        If we try to compile it, we'll see the following error:
            tsc compile-error.ts
            compile-error.ts(2,12): error TS2322: Type 'number' is not assignable to type 'string'
        What happened here ? We tried to return 12, which is a number, but we stated, that hello would return a string (by putting the ): string { after the argument declaration)
        In order to correct this, we need to update the function declaration to return a number:
            function hello(name: string): number {return 12;}
        This is 1 small example, but already we can see, that by using types, it can save us from a lot of bugs down the road
        So, now that we know how to use types, how can we know, what types are available to use ? Let's look at the list of built-in types and then we'll figure out, how to create our own
        
        Trying it out with a REPL                                   zamiast tego, można też użyć jakiegoś edytora TS online, np: https://www.typescriptlang.org/play
        To play with the examples in this chapter, let's install a nice little utility called TSUN³³ (TS Upgraded Node):            ³³https://github.com/HerringtonDarkholme/TS-repl
            1 $ npm install -g tsun
        Now start tsun:
            1 $ tsun
            2 TSUN : TS Upgraded Node
            3 type in TS expression to evaluate
            4 type :help for commands in repl
            5
            6 >
        That little > is the prompt indicating, that TSUN is ready to take in commands. In most of the examples below, u can copy and paste into this terminal and follow along

        BUILT-IN TYPES
        
        String - holds text and is declared using the "string" type:        
            var fullName: string = 'Nate Murray';
        
        Number - is any type of numeric value. In TS, all numbers are represented as floating point. The type for numbers is number:
            var age: number = 36;
        
        Boolean - holds either true / false as the value
            var married: boolean = true;
        
        Array - are declared with the Array type. However, because an Array is a collection, we also need to specify the type of the objects in the Array
        We specify the type of the items in the array with either the Array<type> or type[] notations:
            var jobs: Array<string> = ['IBM', 'Microsoft', 'Google'];
            var jobs: string[] = ['Apple', 'Dell', 'HP'];
        Or similarly with a number:
            var chickens: Array<number> = [1, 2, 3];
            var chickens: number[] = [4, 5, 6];
        
        Enums - work by naming numeric values. Np. if we wanted to have a fixed list of roles a person may have:
            enum Role {Employee, Manager, Admin};
            var role: Role = Role.Employee;
        The default initial value for an enum is 0, though u can set the starting enum number, like this:
            enum Role {Employee = 3, Manager, Admin};
            var role: Role = Role.Employee;
        In the code above, instead of Employee being 0, Employee is 3. The value of the enum increments from there, which means - Manager is 4 and Admin is 5 and we can even set individual values:
            enum Role {Employee = 3, Manager = 5, Admin = 7};
            var role: Role = Role.Employee;
        You can also look up the name of a given enum by using its value:
            enum Role {Employee, Manager, Admin};
            console.log('Roles: ', Role[0], ',', Role[1], 'and', Role[2]);
        
        Any - is the default type, if we omit typing for a given variable. Having a variable of type "any" allows it to receive any kind of value:
            var sth: any = 'as string';
            sth = 1;     sth = [1, 2, 3];

        Void - means there's no type expected. This is usually in functions with no return value:
            function setName(name: string): void {this.fullName = name;}

    ■ CLASSES

        In JS ES5, object oriented programming was accomplished by using "prototype-based objects". This model doesn't use classes, but instead relies on "prototypes"
        A number of good practices have been adopted by the JS community to compensate the lack of classes
        A good summary of those good practices can be found in Mozilla Developer Network's JS Guide³⁴ and u can find a good overview on the Introduction to Object-Oriented JS³⁵ page
                    ³⁴ https://developer.mozilla.org/en-US/docs/Web/JS/Guide      ³⁵ https://developer.mozilla.org/en-US/docs/Web/JS/Introduction_to_Object-Oriented_JS
(B)     However, in ES6 we finally have built-in classes in JS. To define a class, we use the new "class" keyword and give our class a name and a body:
            class Vehicle { }                 
        Classes may have properties, methods, constructors
        
        a) Properties
        Properties define data attached to an instance of a class. Np. a class named Person might have properties, like "first_name", "last_name" and "age"
        Each property in a class can optionally have a type. Np. we could say, that the "first_name" and "last_name" properties are strings and the "age" property is a number. The declaration for a "Person" class:
            class Person {first_name: string; last_name: string; age: number;}
        
        b) Methods
        Methods are functions, that run in context of an object. To call a method on an object, we 1st have to have an instance of that object
        To instantiate a class, we use the "new" keyword. Use "new Person()" to create a new instance of the Person class. If we wanted to add a way to greet a Person using the class above:
            class Person {first_name: string; last_name: string; age: number; greet() {console.log("Hello", this.first_name);}}
        Notice, that we're able to access the "first_name" for this Person, by using the "this" keyword and calling "this.first_name"
        When methods don't declare an explicit returning type and return a value, it's assumed, they can return anything (any type). However, in this case, we are returning "void", since there's no explicit return statement
        Note, that a "void" value is also a valid "any" value. In order to invoke the "greet" method, u would need to 1st have an instance of the "Person" class:
            var p: Person;          // declare a variable of type Person
            p = new Person();       // instantiate a new Person instance
            p.first_name = 'Felipe';    // give it a first_name
            p.greet();                  // call the greet method
        You can declare a variable and instantiate a class on the same line, if u want:
            var p: Person = new Person();
        Say, we want to have a method on the Person class, that returns a value. Np. to know the age of a Person in a number of years from now:
            class Person {first_name: string; last_name: string; age: number; greet() {console.log("Hello", this.first_name);}
            ageInYears(years: number): number {return this.age + years;}}
            var p: Person = new Person();           // instantiate a new Person instance
            p.age = 6;              // set initial age
            p.ageInYears(12);       // how old will he be in 12 years ?       // -> 18

        c) Constructors                     Dziedziczenie klasowe vs Dziedziczenie prototypowe
        A constructor is a special method, that is executed, when a new instance of the class is being created. Usually, the constructor is where u perform any initial setup for new objects
        Constructor methods must be named "constructor". They can optionally take parameters, but they can't return any values, since they are called, when the class is being instantiated 
        (i.e. an instance of the class is being created, no other value can be returned). In order to instantiate a class, we call the class constructor method by using the class name: "new ClassName()"
	    When a class has no constructor defined explicitly, 1 will be created automatically:
            class Vehicle {}
            var v = new Vehicle();
        Is the same as:                             Constructor jest po to, żeby przypisać temu obiektowi properties / methods
            class Vehicle {constructor() {}}
            var v = new Vehicle();
(B)     In TS, u can have only 1 constructor per class. That is a departure from ES6, which allows 1 class to have more, than 1 constructor, as long as they have a different number of parameters
        Constructors can take parameters, when we want to parameterize our new instance creation. Np. we can change "Person" to have a constructor, that initializes our data:
            class Person {first_name: string; last_name: string; age: number;                   // te properties chyba nie są potrzebne - i tak je nadpisuje constructor
                          constructor(first_name: string, last_name: string, age: number) {this.first_name = first_name; this.last_name = last_name; this.age = age;}
                          greet() {console.log("Hello", this.first_name);}
                          ageInYears(years: number): number {return this.age + years;}}
        It makes our previous example a little easier to write:
            var p: Person = new Person('Felipe', 'Coury', 36);
            p.greet();
        This way, the person's names and age are set for us, when the object is created
        
        d) Inheritance
        Another important aspect of object oriented programming. It is a way to indicate, that a class receives behavior from a parent class - then we can override / modify / augment those behaviors on the new class
        If u want to have a deeper understanding of how inheritance used to work in ES5, take a look at the Mozilla Developer Network article about it: Inheritance and the prototype chain³⁶            ³⁶https://developer.mozilla.org/en-US/docs/Web/JS/Inheritance_and_the_prototype_chain
        TS fully supports inheritance and, unlike ES5, it's built into the core language. Inheritance is achieved through the "extends" keyword. To illustrate, let's say we've created a "Report" class:
            class Report {data: Array<string>; constructor(data: Array<string>) {this.data = data;}
		                  run() {this.data.forEach(function(line) {console.log(line);});}}
        This "report" has a property "data", which is an Array of strings. When we call "run", we loop over each element of data and print them out, using "console.log"
(B)	    "forEach" is a method on Array, that accepts a function, as an argument, and calls that function for each element in the Array
        This Report works, by adding lines and then calling "run" to print out the lines:
            var r: Report = new Report(['1st line', '2nd line']);
            r.run();
        Running this should show:
            1st line
            2nd line
        Now, let's say, we want to have a 2nd report ("TabbedReport"), that takes some headers and some data, but we still want to reuse, how the Report class presents the data to the user
        To reuse that behavior from the "Report" class, we can use inheritance with the "extends" keyword:
            class TabbedReport extends Report {headers: Array<string>; 			// nowy property
					                           constructor(headers: string[], values: string[]) {super(values); this.headers = headers;}		// przypisujemy ten nowy property     
                                               run() {console.log(this.headers); super.run();}}		// zmieniamy oddziedziczoną metodę "run"
	    var headers: string[] = ['Name'];							// ten nowy property
	    var data: string[] = ['Alice Green', 'Paul Pfifer', 'Louis Blakenship'];		// ten odziedziczony property
	    var r: TabbedReport = new TabbedReport(headers, data)
	    r.run();                // uwaga - ta nowa funkcja run() - wywoła w sobie także tę poprzednią funkcję "run()" - ale z nowymi danymi

        LEPSZY PRZYKŁAD (https://www.w3schools.com/)
                "super()" - metoda, która wysyła argument do constructora w obiekcie wyżej. By calling the super() method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods
                parametr w tej funkcji - to dowolna nazwa (np. "abc"). To nie musi być nazwa parametru w funkcji constructor w obiekcie wyżej
                oczywiście ten parametr(y) w funkcji super(), powinien wcześniej pojawić się jako parametr(y) w funkcji "constructor" w tej samej klasie
                Także ilość przekazywanych parametrów (tj. "abc") z funkcji super() do funkcji wyżej, powinna być zsynchronizowana (jak będzie mniej, to wypełni pierwszy parametr, pozostałe będą undefined)

                class Car {constructor(brand) {this.carname = brand;} 
                        present() {return this.carname;}}

                // console.log(Car.carname);    // "undefined"
                // console.log(Car.present());    // "Uncaught TypeError: Car.present is not a function"

                Car1 = new Car("Ford");
                console.log("Car1-a: " + Car1.carname);    // "Ford"
                console.log("Car1-b: " + Car1.present());    // "Ford"

                class Model extends Car {constructor(abc, mod) {super(abc); this.model = mod;}      
                                        show() {return this.model;}}

                Car2 = new Model("Ferrari", "Mustang");
                console.log("Car2-a: " + Car2.abc);   // "undefined"
                console.log("Car2-b: " + Car2.model);   // "Mustang"
                console.log("Car2-c: " + Car2.show());   // "Mustang"
                console.log("Car2-d: " + Car2.carname);   // "Ferrari"
                console.log("Car2-e: " + Car2.present());   // "Ferrari"

    ■ UTILITIES
        ES6, and by extension TS, provides a number of syntax features, that make programming really enjoyable. 2 important ones are:    • fat arrow function syntax     • template strings
        
        1) Fat Arrow Functions (funkcje grubo-strzałkowe)        
        Fat arrow "=>" functions are a shorthand notation for writing functions. In ES5, whenever we want to use a function as an argument, we have to use the "function" keyword along with {} braces:
            var data = ['Alice Green', 'Paul Pfifer', 'Louis Blakenship'];	// ES5-like example
            data.forEach(function(line) {console.log(line);});			
        However, with the "=>" syntax, we can instead rewrite it:
            var data: string[] = ['Alice Green', 'Paul Pfifer', 'Louis Blakenship'];	   // TS example
            data.forEach((line) => console.log(line));
        Parentheses are optional, when there's only 1 parameter. The "=>" syntax can be used both as an "expression":
            var evens = [2,4,6,8];
            var odds = evens.map(v => v + 1);
        or as a "statement":
            data.forEach(line => {console.log(line.toUpperCase())});
(A)     1 important feature of the "=>" syntax is, that it shares the same "this", as the surrounding code. This is important and different, than what happens, when u normally create a function in JS
(B)     Generally, when u write a function in JS, that function is given its own "this". Sometimes in JS, we see code like this:
            var nate = {name: "Nate", guitars: ["Gibson", "Martin", "Taylor"],
                        printGuitars: function() {var self = this; this.guitars.forEach(function(g) {console.log(self.name + " plays a " + g);});}};       // "this.name" is undefined, so we have to use "self.name"
        Because the fat arrow shares "this" with its surrounding code, we can instead write:
            var nate = {name: "Nate", guitars: ["Gibson", "Martin", "Taylor"],
                        printGuitars: function() {this.guitars.forEach((g) => {console.log(this.name + " plays a " + g);});}};
        Arrows are a great way to cleanup your inline functions. It makes it even easier to use higher-order functions in JS
        
        2) Template Strings
        In ES6, new template strings were introduced. The 2 great features of template strings are:
            1. Variables within strings (without being forced to concatenate with "+") and
            2. Multi-line strings
        
        a) Variables in strings						() - brackets ("okrągłe") [] - square brackets ("kwadratowe") {} - curly brackets ("klamrowe", a nie "sześcienne")
(B)     This feature is also called "string interpolation". The idea is, that u can put variables right in your strings:
            var firstName = "Nate";
            var lastName = "Murray";
            var greeting = `Hello ${firstName} ${lastName}`;	    // interpolate a string
            console.log(greeting);
        Note, that to use string interpolation, u must enclose your string in backticks "`" - not single / double quotes
        
        b) Multiline strings
        Another great feature of backtick strings "`" is multi-line strings:
            var template = `
            <div>
            <h1>Hello</h1>
            <p>This is a great website</p>
            </div>
            `			           
        Multiline strings are a huge help, when we want to put strings in our code, that are a little long, like templates
        
    ■ WRAPPING UP

        There are a variety of other features in TS / ES6, such as:
        	• Interfaces        • Generics        • Importing and Exporting Modules        • Decorators        • Destructuring
        We'll be touching on these concepts, as we use them throughout the book, but for now, these basics should get u started. Let's get back to Angular !

    ■ HOW ANGULAR WORKS

        In this chapter, we're going to talk about the high-level concepts of Angular. We're going to take a step back so that we can see how all the pieces fit together
        If you've used AngularJS 1.x, you'll notice that Angular has a new mentalmodel for building applications. Don't panic ! 
        As AngularJS 1.x users ourselves we've found Angular to be both straightforward and familiar. A little later in this book we're going to talk specifically about how to convert your AngularJS 1.x apps to Angular
        In the chapters that follow, we won't be taking a deep dive into each concept, but instead we're going to give an overview and explain the foundational ideas
        The 1st big idea is that an Angular application is made up of Components. 1 way to think of Components is a way to teach the browser new tags
        If u have an Angular 1 background, Components are analogous to directives in AngularJS 1.x (it turns out, Angular has directives too, but we'll talk more about this distinction later on)
        However, Angular Components have some significant advantages over AngularJS 1.x directives and we'll talk about that below. 1st, let's start at the top: the Application

        Application
        An Angular Application is nothing more than a tree of Components. At the root of that tree, the top level Component is the application itself. And that's what the browser will render when "booting" (a.k.a bootstrapping) the app
        1 of the great things about Components is that they're composable. This means that we can build up larger Components from smaller ones. The Application is simply a Component that renders other Components
        Because Components are structured in a parent/child tree, when each Component renders, it recursively renders its children Components
        Np. let's create a simple inventory management application that is represented by the following page mockup:

        Inventory Management App
        Given this mockup, to write this application the 1st thing we want to do is split it into components.
        In this example, we could group the page into three high level components
            1. The Navigation Component
            2. The Breadcrumbs Component
            3. The Product List Component

        The Navigation Component
        This component would render the navigation section. This would allow the user to visit other areas of the application

        The Breadcrumbs Component
        This would render a hierarchical representation of where in the application the user currently is

        The Product List Component
        The Products List component would be a representation of a collection of products
        Breaking this component down into the next level of smaller components, we could say that the Product List is composed of multiple Product Rows

        Product Row Component
        And of course, we could continue one step further, breaking each Product Row into smaller pieces:
            • the Product Image component would be responsible for rendering a product image, given its image name
            • the Product Department component would render the department tree, like Men > Shoes > Running Shoes
            • the Price Display component would render the price. Imagine that our implementation customizes the pricing if the user is logged in to include system-wide tier discounts or include shipping for instance
            We could implement all this behavior into this component.
        Finally, putting it all together into a tree representation, we end up with the following diagram:

        App Tree Diagram
        At the top we see Inventory Management App: that's our application. Under the application we have the Navigation, the Breadcrumb and the Products List components
        The Products List component has Product Rows, one for each product. And the Product Row uses three components itself: one for the image, the department and the price
        Let's work together to build this application. You can find the full code listing for this chapter in the downloads under 	how-angular-works/inventory-app

        Here's a screenshot of what our app will look like when we're done:
        Completed Inventory App

        How to Use This Chapter
        In this chapter we're going to explain the fundamental concepts required when building Angular apps by walking through an app that we've built. We'll explain:
            • How to break your app into components
            • How to make reusable components using inputs
            • How to handle user interactions, such as clicking on a component
        In this chapter, we've used angular-cli, just as we did before. This means, u can use all of the normal "ng" commands, such as:
            ng serve # runs the app
        Also, in this chapter, we're not going to give step-by-step instructions on how to create each file in the app. If you'd like to follow along at home, when we introduce a new component you can run:
            ng generate component NameOfNewComponentHere
        This will generate the files you need and you're free to type in your code there / copy and paste code from the book or from our example code
        We've provided the entire, completed application in the code download folder under how-angular-works/inventory-app. If you ever feel lost or need more context, take some time to look at the completed example code
        Let's get started building!

        Product Model
        1 of the key things to realize about Angular is that it doesn't prescribe a particular model library. Angular is flexible enough to support many different kinds of models (and data architectures)
        However, this means the choice is left to you as the user to determine how to implement these things. We'll have a lot to say about data architectures in future chapters
        For now, though, we're going to have our models be plain JS objects.			code/how-angular-works/inventory-app/src/app/product.model.ts
            /**
            * Provides a `Product` object
            */
            export class Product {constructor(public sku: string, public name: string, public imageUrl: string, public department: string[], public price: number) {}}
        If you're new to ES6/TS, this syntax might be a bit unfamiliar. We're creating a new Product class and the constructor takes 5 arguments. When we write public sku: string, we're saying 2 things:
            • there is a public variable on instances of this class called sku
            • sku is of type string
        If you're already familiar with JS, u can quickly catch up on some of the differences, including the public constructor shorthand, here at learnxinyminutes³⁷		³⁷https://learnxinyminutes.com/docs/TS/
        This Product class doesn't have any dependencies on Angular, it's just a model that we'll use in our app.

        Components
        As we mentioned before, Components are the fundamental building block of Angular applications. The "application" itself is just the top-level Component. Then we break our application into smaller child Components
        When building new Angular applications, we often follow this process: we mockup the design in wireframes (or on paper) and then we break down the parts into Components
        We'll be using Components a lot, so it's worth looking at them more closely. Each component is composed of three parts:
            • Component Decorator	• A View	• A Controller
        To illustrate the key concepts we need to understand about components, we'll start with the top level Inventory App and then focus on the Products List and child components:
        Products List Component
        Here's what a basic, top-level AppComponent looks like:
        @Component({selector: "inventory-app-root",
        template: `
        <div class="inventory-app">
        (Products will go here soon)
        </div>
        `
        })
        export class AppComponent { // Inventory logic here }

        If u've been using Angular 1 the syntax might look pretty foreign ! But the ideas are pretty similar, so let's take them step by step.
        The @Component is called a decorator. It adds metadata to the class that follows it (AppComponent). The @Component decorator specifies:
            • a selector, which tells Angular what element to match		• a template, which defines the view
        The Component controller is defined by a class, the AppComponent class, in this case. Let's take a look into each part now in more detail

        Component Decorator
        The @Component decorator is where you configure your component. 1 of the primary roles of the @Component decorator is to configure how the outside world will interact with your component
        There are lots of options available to configure a component (many of which we cover in the Advanced Components Chapter). In this chapter we're just going to touch on the basics

        Component selector
        With the selector key, you indicate how your component will be recognized when used in a template. The idea is similar to CSS or XPath selectors. The selector is a way to define what elements in the HTML will match this component
        In this case, by saying selector: 'inventory-app-root', we're saying that in our HTML we want to match the inventory-app-root tag, that is, we're defining a new tag that has new functionality whenever we use it
        E.g. when we put this in our HTML:
            <inventory-app-root></inventory-app-root>
        Angular will use the AppComponent component to implement the functionality

        Component template
        The view is the visual part of the component. By using the template option on @Component, we declare the HTML template that the component will use:
        @Component({selector: 'inventory-app-root',
        template: `
        <div class="inventory-app">
        (Products will go here soon)
        </div>
        `
        })
        For the template above, notice that we're using TS's backtick multi-line string syntax. Our template so far is pretty sparse: just a div with some placeholder text
        We can also move our template out to a separate file and use templateUrl instead:
        @Component({
        selector: "inventory-app-root",
        templateUrl: "./app.component.html"
        })
        export class AppComponent { // Inventory logic here }

        Adding A Product
        Our app isn't very interesting without Products to view. Let's add some now. We can create a new Product like this:
            // this is just an example of how to use Product,
            // we'll do sth similar in our Angular code in a moment
            // 1st, we have to import `Product` so that we can use it
        import { Product } from "./product.model";
            // now we can create a new `Product`
        let newProduct = new Product(
            "NICEHAT", // sku
            "A Nice Black Hat", // name
            "/assets/images/products/black-hat.jpg", // imageUrl
            ["Men", "Accessories", "Hats"], // department
            29.99); // price
        Our constructor for Product takes 5 arguments. We can create a new Product by using the "new" keyword
        Normally, I probably wouldn't pass more than a few arguments to a function. Another option here is to configure the Product class to take an Object in the constructor, then we wouldn't have to remember the order of the arguments
        That is, Product could be changed to do sth like this:
            new Product({sku: "MYHAT", name: "A green hat"})
        But for now, this 5 argument constructor is easy to use. We want to be able to show this Product in the view. In order to make properties accessible to our template we add them as instance variables to the Component
        Np. if we want to access newProduct in our view we could write:
            import { Product } from "./product.model";
            export class AppComponent {
            product: Product;
            constructor() {
            let newProduct = new Product(
            "NICEHAT",
            "A Nice Black Hat",
            "/resources/images/products/black-hat.jpg",
            ["Men", "Accessories", "Hats"],
            29.99);
            this.product = newProduct;}}
        or more concisely:
            export class AppComponent {
            product: Product;
            constructor() {
            this.product = new Product(
            "NICEHAT",
            "A Nice Black Hat",
            "/resources/images/products/black-hat.jpg",
            ["Men", "Accessories", "Hats"],
            29.99);}}
        Notice, that we did 3 things here:
            1. We added a constructor - When Angular creates a new instance of this Component, it calls the constructor function. This is where we can put setup for this Component
            2. We described an instance variable - On AppComponent, when we write: product: Product, we're specifying that the AppComponent instances have a property product which is a Product object
            3. We assigned a Product to product - In the constructor we create an instance of Product and assigned it to the instance variable

        Viewing the Product with Template Binding
        Now that we have product assigned to the AppComponent instance, we could use that variable in our view template:
            <div class="inventory-app">
            <h1>{{ product.name }}</h1>
            <span>{{ product.sku }}</span>
            </div>
        Using the {{…}} syntax is called template binding. It tells the view we want to use the value of the expression inside the brackets at this location in our template
        So in this case, we have 2 bindings:
            • {{ product.name }}
            • {{ product.sku }}
        The product variable comes from the instance variable product on our Component instance of AppComponent.
        What's neat about template binding is that the code inside the brackets is an expression. That means you can do things like this:
            • {{ count + 1 }}
            • {{ myFunction(myArguments) }}
        In the 1st case, we're using an operator to change the displayed value of count. In the 2nd case, we're able to replace the tags with the value of the function myFunction(myArguments)
        Using template binding tags is the main way that you'll show data in your Angular applications

        Adding More Products
        In the code above, we're only able to show a single product in our app, but we want to be able to show a list of products. Let's change our AppComponent to store an array of Products rather than a single Product:
            export class AppComponent {products: Product[]; constructor() {this.products = [];}}
        Notice, that we've renamed the variable product to products and we've changed the type to Product[]. The [] characters at the end mean we want products to be an Array of Products
        We also could have written this as: Array<Product>. Now that our AppComponent holds an array of Products. Let's create some Products in the constructor:	code/how-angular-works/inventory-app/src/app/app.component.ts
        export class AppComponent {
        products: Product[];

        constructor() {this.products = [new Product('MYSHOES', 'Black Running Shoes', '/assets/images/products/black-shoes.jpg', ['Men', 'Shoes', 'Running Shoes'], 109.99),
                        new Product('NEATOJACKET', 'Blue Jacket', '/assets/images/products/blue-jacket.jpg', ['Women', 'Apparel', 'Jackets & Vests'], 238.99),
                        new Product('NICEHAT', 'A Nice Black Hat', '/assets/images/products/black-hat.jpg', ['Men', 'Accessories', 'Hats'], 29.99)];}
        This code will give us some Products to work with in our app

        Selecting a Product
        We (eventually) want to support user interaction in our app. Np. the user might select a particular product to view more information about the product, add it to the cart, etc.
        Let's add some functionality here in our AppComponent to handle what happens when a new Product is selected. To do that, let's define a new function, productWasSelected:	code/how-angular-works/inventory-app/src/app/app.component.ts
            productWasSelected(product: Product): void {console.log('Product clicked: ', product);}
        This function accepts a single argument product and then it will log out that the product was passed in. We'll use this function in a bit

        Listing products using <products-list>
        Now, that we have our top-level AppComponent component, we need to add a new component for rendering a list of products. In the next section we'll create the implementation of a ProductsList component that matches the selector productslist
        Before we dive into the implementation details, here's how we will use this new component in our template:	code/how-angular-works/inventory-app/src/app/app.component.html
            <div class="inventory-app">
            <products-list
            [productList]="products"
            (onProductSelected)="productWasSelected($event)">
            </products-list>
            </div>
        There is some new syntax here, so let's talk about each part:

        Inputs and Outputs
        When we use products-list we're using a key feature of Angular components: 
        inputs and outputs:
            <products-list [productList]="products" <!-- input -->
                (onProductSelected)="productWasSelected($event)"> <!-- output -->
            </products-list>
        The [squareBrackets] pass inputs and the (parentheses) handle outputs. Data flows in to your component via input bindings and events flow out of your component through output bindings
        Think of the set of input + output bindings as defining the public API of your component.
        [squareBrackets] pass inputs
        In Angular, you pass data into child components via inputs. In our code where we show:
        <products-list [productList]="products"
        We're using an input of the ProductList component.
        It can be tricky to understand, where products/productList are coming from. There are 2 sides to this attribute:
            • [productList] (the left-hand side) and
            • "products" (the right-hand side)
        The left-hand side [productList] says we want to use the productList input of the products-list component (we'll show how to define that in a moment)
        The right-hand side "products" says that we want to send the value of the expression products. That is, the array this.products in the AppComponent class
        You might ask, "how would I know that productList is a valid input to the products-list component? The answer is: you'd read the docs for that component. The inputs (and outputs) are part of the "public API" of a component
        You'd know the inputs for a component that you're using in the same way that you'd know what the arguments are for a function that you're using
        That said, we'll define the products-list component in a moment and we'll see exactly how the productList input is defined. (parens) handle outputs
        In Angular, you send data out of components via outputs.
        In our code where we show:
            <products-list
            ...
            (onProductSelected)="productWasSelected($event)">
        We're saying that we want to listen to the onProductSelected output from the ProductsList component
        That is:
            • (onProductSelected), the left-hand side is the name of the output we want to "listen" on
            • "productWasSelected", the right-hand side is the function we want to call when sth new is sent to this output
            • $event is a special variable here that represents the thing emitted on (i.e. sent to) the output	
        Now, we haven't talked about how to define inputs or outputs on our own components yet, but we will shortly when we define the ProductsList component
        For now, know that we can pass data to child components through inputs (like "arguments" to a function) and we can receive data out of a child component through outputs (sort of like "return values" from a function)

        Full AppComponent Listing
        We broke the AppComponent up into several chunks above. So that we can see the whole thing together, here's the full code listing of our AppComponent:		code/how-angular-works/inventory-app/src/app/app.component.ts
        import {
        Component,
        EventEmitter
        } from '@angular/core';

        import { Product } from './product.model';
        /**
        * @InventoryApp: the top-level component for our application
        */
        @Component({selector: 'inventory-app-root', templateUrl: './app.component.html'})
        export class AppComponent {products: Product[]; constructor() {this.products = [new Product('MYSHOES', 'Black Running Shoes', '/assets/images/products/black-shoes.jpg', ['Men', 'Shoes', 'Running Shoes'], 109.99),
        new Product('NEATOJACKET', 'Blue Jacket', '/assets/images/products/blue-jacket.jpg', ['Women', 'Apparel', 'Jackets & Vests'], 238.99),
        new Product('NICEHAT', 'A Nice Black Hat', '/assets/images/products/black-hat.jpg', ['Men', 'Accessories', 'Hats'], 29.99)];}
        productWasSelected(product: Product): void {console.log('Product clicked: ', product);}}
        and the template:			code/how-angular-works/inventory-app/src/app/app.component.html
        <div class="inventory-app">
            <products-list
                [productList]="products"
                (onProductSelected)="productWasSelected($event)">
            </products-list>
        </div>

        The ProductsListComponent
        Now, that we have our top-level application component, let's write the ProductsList-Component, which will render a list of product rows
        We want to allow the user to select one Product and we want to keep track of which Product is the currently selected one. The ProductsListComponent is a great place to do this because it "knows" all of the Products at the same time
        Let's write the ProductsListComponent in three steps:
            • Configuring the ProductsListComponent @Component options
            • Writing the ProductsListComponent controller class
            • Writing the ProductsListComponent view template
        Configuring the ProductsListComponent @Component Options
        Let's take a look at the @Component configuration for ProductsListComponent:	code/how-angular-works/inventory-app/src/app/products-list/products-list.component.ts
        import {Component, EventEmitter, Input, Output} from '@angular/core';
        import { Product } from '../product.model';
        /**
        * @ProductsList: A component for rendering all ProductRows and
        * storing the currently selected Product
        */
        @Component({selector: 'products-list', templateUrl: './products-list.component.html'})
        export class ProductsListComponent {
        /**
        * @input productList - the Product[] passed to us
        */
        @Input() productList: Product[];
        /**
        * @output onProductSelected - outputs the current
        * Product whenever a new Product is selected
        */
        @Output() onProductSelected: EventEmitter<Product>;
        We start our ProductsListComponent with a familiar option: selector. This selector means we can place our ProductsListComponent with the tag <products-list>
        We've also defined two properties productList and onProductSelected. Notice that productList has a @Input() annotation, denoting that it is an input and onProductSelected has an @Output() annotation, denoting that it is an output

        Component inputs
        Inputs specify the parameters we expect our component to receive. To designate an input, we use the @Input() decoration on a component class property
        When, we specify that a Component takes an input, it is expected that the definition class will have an instance variable that will receive the value. Np. say we have the following code:
        import { Component, Input } from "@angular/core";
        @Component({selector: "my-component"})
        class MyComponent {@Input() name: string; @Input() age: number;}
        The name and age inputs map to the name and age properties on instances of the MyComponent class
        If we need to use 2 different names for the attribute and the property, we could for example write @Input('firstname') name: String;. But the Angular Style Guide³⁸ suggests to avoid this	³⁸https://angular.io/docs/ts/latest/guide/style-guide.html
        If we want to use MyComponent from another template, we write sth like: <mycomponent[name]="myName" [age]="myAge"></my-component>.
        Notice that the attribute name matches the input name, which in turn matches the MyComponent property name. However, these don't always have to match
        Np. say we wanted our attribute key and instance property to differ. That is, we want to use our component like this:
            <my-component [shortName]="myName" [oldAge]="myAge"></my-component>
        To do this, we would change the format of the string in the inputs option:
        @Component({selector: "my-component"})
        class MyComponent {@Input("shortName") name: string; @Input("oldAge") age: number;}
        • The property name (name, age) represent how that incoming property will be visible ("bound") in the controller
        • The @Input argument (shortName, oldAge) configures how the property is visible to the "outside world"
        Passing products through via the inputs
        If u recall, in our AppComponent, we passed products to our products-list via the [productList] input:		code/how-angular-works/inventory-app/src/app/app.component.html
            <div class="inventory-app">
                <products-list [productList]="products" (onProductSelected)="productWasSelected($event)">
                </products-list>
            </div>
        Hopefully, this syntax makes more sense now: we're passing the value of this.products (on the AppComponent) in via an input on ProductsListComponent

        Component outputs
        When u want to send data from your component to the outside world, u use output bindings. Let's say a component we're writing has a button and we need to do sth when that button is clicked
        The way to do this, is by binding the click output of the button to a method declared on our component's controller. You do that using the (output)="action" notation
        Here's an example where we keep a counter and increment (or decrement) based on which button is pressed:
            @Component({ selector: 'counter', template: {{ value }} <button (click)="increase()">Increase</<button (click)="decrease()">Decrease</button> }) class Counter { value: number;
            constructor() {this.value = 1;}
            increase() {this.value = this.value + 1; return false;}
            decrease() {this.value = this.value - 1; return false;}}
        In this example, we're saying, that every time the 1st button is clicked, we want the increase() method on our controller to be invoked. And, similarly, when the second button is clicked, we want to call the decrease() method
        The parentheses attribute syntax looks like this: (output)="action". In this case, the output we're listening for is the click event on this button. There are many other built-in events we can listen to such as: mousedown, mousemove, dbl-click, etc.
        In this example, the event is internal to the component. That is, calling increase() increments this.value, but there's no effect that leaves this component
        When creating our own components we can also expose "public events" (component outputs) that allow the component to talk to the outside world
        The key thing to understand here is that in a view, we can listen to an event by using the (output)="action" syntax

        Emitting Custom Events
        Let's say we want to create a component that emits a custom event, like click / mousedown above. To create a custom output event we do 3 things:
            1. Specify outputs in the @Component configuration
            2. Attach an EventEmitter to the output property
            3. Emit an event from the EventEmitter, at the right time
        Perhaps EventEmitter is unfamiliar to you. Don't panic! It's not too hard. An EventEmitter is an object that helps you implement the Observer Pattern³⁹. That is, it's an object that will:
            1. maintain a list of subscribers and										³⁹https://en.wikipedia.org/wiki/Observer_pattern
            2. publish events to them
        That's it.
        Here's a short and sweet example of how you can use EventEmitter
            let ee = new EventEmitter(); ee.subscribe((name: string) ) console
            log(Hello ${name})); ee.emit("Nate");		// -> "Hello Nate"
        When we assign an EventEmitter to an output Angular automatically subscribes for us. You don't need to do the subscription yourself (though in a special situation you could add your own subscriptions, if you want to)
        Here's an example of how we write a component that has outputs:

        @Component({selector: "single-component", template: `<button (click)="liked()">Like it?</button>`})
        class SingleComponent {@Output() putRingOnIt: EventEmitter<string>; constructor() {this.putRingOnIt = new EventEmitter();} liked(): void {this.putRingOnIt.emit("oh oh oh");}}
        Notice, that we did all 3 steps: 1. specified outputs, 2. created an EventEmitter that we attached to the output property putRingOnIt and 3. Emitted an event when liked is called
        If we wanted to use this output in a parent component we could do sth like this:
        @Component({selector: "club", template: `<div><single-component(putRingOnIt)="ringWasPlaced($event)"></single-component></div>`})
        class ClubComponent {ringWasPlaced(message: string) {console.log(`Put your hands up: ${message}`);}}		// logged -> "Put your hands up: oh oh oh"
        Again, notice that:
            • putRingOnIt comes from the outputs of SingleComponent		
            • ringWasPlaced is a function on the ClubComponent
            • $event contains the thing that was emitted, in this case a string
        Writing the ProductsListComponent Controller Class Back to our store example, our ProductsListComponent controller class needs 3 instance variables:
            • 1 to hold the list of Products (that come from the productList input)
            • 1 to output events (that emit from the onProductSelected output)
            • 1 to hold a reference to the currently selected product
        Here's how we define those in code:		code/how-angular-works/inventory-app/src/app/products-list/products-list.component.ts
        export class ProductsListComponent {
        /**
        * @input productList - the Product[] passed to us
        */
        @Input() productList: Product[];
        /**
        * @output onProductSelected - outputs the current
        * Product whenever a new Product is selected
        */
        @Output() onProductSelected: EventEmitter<Product>;

        /**
        * @property currentProduct - local state containing
        * the currently selected `Product`
        */
        private currentProduct: Product;
        constructor() {this.onProductSelected = new EventEmitter();}

        Notice, that our productList is an Array of Products - this comes in from the inputs.onProductSelected is our output
        currentProduct is a property internal to ProductsListComponent. You might also hear this being referred to as "local component state". It's only used here within the component

        Writing the ProductsListComponent View Template
        Here's the template for our products-list component:		code/how-angular-works/inventory-app/src/app/products-list/products-list.component.html
        <div class="ui items">
        <product-row
        *ngFor="let myProduct of productList"
        [product]="myProduct"
        (click)='clicked(myProduct)'
        [class.selected]="isSelected(myProduct)">
        </product-row>
        </div>
        Here, we're using the product-row tag, which comes from the ProductRow component, which we'll define in a minute
        We're using ngFor to iterate over each Product in productList. We've talked about ngFor before in this book, but just as a reminder the let thing of things syntax says, 
        "iterate over things and create a copy of this element for each item and assign each item to the variable thing"
        So in this case, we're iterating over the Products in productList and generating a local variable myProduct for each 1
        Style-wise, I probably wouldn't call this variable myProduct in a real app. Instead, I'd probably call it product, or even p
        But here I want to be explicit about what we're passing and myProduct is slightly clearer because it let's us distinguish the 'local template variable' from the input product
        The interesting thing to note about this myProduct variable is that we can now use it even on the same tag. As you can see, we do this on the following three lines
        The line that reads [product]="myProduct" says that we want to pass myProduct (the local variable) to the input product of the product-row. (We'll define this input when we define the ProductRow component below)
        The (click)='clicked(myProduct)' line describes what we want to do when this element is clicked. click is a built-in event that is triggered when the host element is clicked on
        In this case, we want to call the component function clicked on ProductsListComponent whenever this element is clicked on
        The line [class.selected]="isSelected(myProduct)" is a fun one: Angular allows us to set classes conditionally on an element using this syntax
        This syntax says "add the CSS class selected if isSelected(myProduct) returns true." This is a really handy way for us to mark the currently selected product
        You may have noticed that we didn't define clicked nor isSelected yet, so let's do that now (in ProductsListComponent): clicked			code/how-angular-works/inventory-app/src/app/products-list/products-list.component.ts
            clicked(product: Product): void {this.currentProduct = product; this.onProductSelected.emit(product);}
        This function does 2 things:
            1. Set this.currentProduct to the Product that was passed in
            2. Emit the Product that was clicked on our output isSelected		code/how-angular-works/inventory-app/src/app/products-list/products-list.component.ts
        isSelected(product: Product): boolean {
        if (!product || !this.currentProduct) {return false;} return product.sku === this.currentProduct.sku;}
        This function accepts a Product and returns true if product's sku matches the currentProduct's sku. It returns false otherwise

        The Full ProductsListComponent Component
        Here's the full code listing so we can see everything in context:		code/how-angular-works/inventory-app/src/app/products-list/products-list.component.ts
        import {Component, EventEmitter, Input, Output} from '@angular/core';
        import { Product } from '../product.model';

        /**
        * @ProductsList: A component for rendering all ProductRows and
        * storing the currently selected Product
        */
        @Component({
        selector: 'products-list',
        templateUrl: './products-list.component.html'
        })
        export class ProductsListComponent {
        /**
        * @input productList - the Product[] passed to us
        */
        @Input() productList: Product[];

        /**
        * @output onProductSelected - outputs the current
        * Product whenever a new Product is selected
        */
        @Output() onProductSelected: EventEmitter<Product>;
        /**
        * @property currentProduct - local state containing
        * the currently selected `Product`
        */
        private currentProduct: Product;
        constructor() {this.onProductSelected = new EventEmitter();}
        clicked(product: Product): void {this.currentProduct = product; this.onProductSelected.emit(product);}
        isSelected(product: Product): boolean {if (!product || !this.currentProduct) {return false;}
        return product.sku === this.currentProduct.sku;}}
        and the template:		code/how-angular-works/inventory-app/src/app/products-list/products-list.component.html
        <div class="ui items">
        <product-row
        *ngFor="let myProduct of productList"
        [product]="myProduct"
        (click)='clicked(myProduct)'
        [class.selected]="isSelected(myProduct)">
        </product-row>
        </div>

The ProductRowComponent Component
A Selected Product Row Component
Our ProductRowComponent displays our Product. ProductRowComponent will have its
own template, but will also be split up into three smaller Components:
• ProductImageComponent - for the image
• ProductDepartmentComponent - for the department "breadcrumbs"
• PriceDisplayComponent - for showing the product's price
Here's a visual of the three Components that will be used within the ProductRow-
Component:
ProductRowComponent's Sub-components
Let's take a look at the ProductRowComponent's Component configuration, definition
class and template:
How Angular Works 126
ProductRowComponent Configuration
The ProductRowComponent uses a lot of the ideas we've covered so far:
code/how-angular-works/inventory-app/src/app/product-row/product-row.component.ts
1 import {
2 Component,
3 Input,
4 HostBinding
5 } from '@angular/core';
6 import { Product } from '../product.model';
7
8 /**
9 * @ProductRow: A component for the view of single Product
10 */
11 @Component({
12 selector: 'product-row',
13 templateUrl: './product-row.component.html',
14 })
15 export class ProductRowComponent {
16 @Input() product: Product;
17 @HostBinding('attr.class') cssClass = 'item';
18 }
We start by defining the selector of product-row. We've seen this several times now
- this defines that this component will match the tag product-row.
Next we define that this row takes an @Input of product. This instance variable will
be set to the Product that was passed in from our parent Component.
The HostBinding decoration is new - it lets us set attributes on the host element.
The host is the element this component is attached to.
In this case, we're using the Semantic UI item class⁴⁰. Here when we say @HostBinding('
attr.class') cssClass = 'item'; we're saying that we want to attach the
CSS class item to the host element.
⁴⁰http://semantic-ui.com/views/item.html
How Angular Works 127
Using host is nice because it means we can configure our host element
from within the component. This is great because otherwise we'd require
the host element to specify the CSS tag and that is bad because we would
then make assigning a CSS class part of the requirement to using the
Component.
Instead of putting a long template string in our TS file, instead we're going
to move the template to a separate HTML file and use a templateUrl to load it. We'll
talk about the template in a minute.
ProductRowComponent template
Now let's take a look at the template:
code/how-angular-works/inventory-app/src/app/product-row/product-row.component.html
1 <product-image [product]="product"></product-image>
2 <div class="content">
3 <div class="header">{{ product.name }}</div>
4 <div class="meta">
5 <div class="product-sku">SKU #{{ product.sku }}</div>
6 </div>
7 <div class="description">
8 <product-department [product]="product"></product-department>
9 </div>
10 </div>
11 <price-display [price]="product.price"></price-display>
Our template doesn't have anything conceptually new.
In the 1st line we use our product-image directive and we pass our product to
the product input of the ProductImageComponent. We use the product-department
directive in the same way.
We use the price-display directive slightly differently in that we pass the product.
price, instead of the product directly.
The rest of the template is standard HTML elements with custom CSS classes and
some template bindings.
Now let's talk about the three components we used in this template. They're
relatively short.
How Angular Works 128
The ProductImageComponent Component
In the ProductImageComponent the template is only one line, so we can put it inline:
code/how-angular-works/inventory-app/src/app/product-image/product-image.component.ts
8 /**
9 * @ProductImage: A component to show a single Product's image
10 */
11 @Component({
12 selector: 'product-image',
13 template: `
14 <img class="product-image" [src]="product.imageUrl">
15 `
16 })
17 export class ProductImageComponent {
18 @Input() product: Product;
19 @HostBinding('attr.class') cssClass = 'ui small image';
20 }
The one thing to note here is in the img tag, notice how we use the [src] input to
img.
By using the [src] attribute, we're telling Angular that we want to use the [src]
input on this img tag. Angular will then replace the value of the src attribute once
the expression is resolved.
We could also have written this tag this way:
<img src="{{ product.imageUrl }}">
Both styles do essentially the same thing, so feel free to pick the style that works best
for your team.
The PriceDisplayComponent Component
Next, let's look at PriceDisplayComponent:
How Angular Works 129
code/how-angular-works/inventory-app/src/app/price-display/price-display.component.ts
1 import {
2 Component,
3 Input
4 } from '@angular/core';
5
6 /**
7 * @PriceDisplay: A component to show the price of a
8 * Product
9 */
10 @Component({
11 selector: 'price-display',
12 template: `
13 <div class="price-display">\${{ price }}</div>
14 `
15 })
16 export class PriceDisplayComponent {
17 @Input() price: number;
18 }
One thing to note is that we're escaping the dollar sign $ because this is a backtick
string and the dollar sign is used for template variables (in ES6).
The ProductDepartmentComponent
Here is our ProductDepartmentComponent:
code/how-angular-works/inventory-app/src/app/product-department/product-department.
component.ts
1 import {
2 Component,
3 Input
4 } from '@angular/core';
5 import { Product } from '../product.model';
6
7 /**
8 * @ProductDepartment: A component to show the breadcrumbs to a
9 * Product's department
10 */
11 @Component({
How Angular Works 130
12 selector: 'product-department',
13 templateUrl: './product-department.component.html'
14 })
15 export class ProductDepartmentComponent {
16 @Input() product: Product;
17 }
and template:
code/how-angular-works/inventory-app/src/app/product-department/product-department.
component.html
1 <div class="product-department">
2 <span *ngFor="let name of product.department; let i=index">
3 <a href="#">{{ name }}</a>
4 <span>{{i < (product.department.length-1) ? '>' : ''}}</span>
5 </span>
6 </div>
The thing to note about the ProductDepartmentComponent Component is the ngFor
and the span tag.
Our ngFor loops over product.department and assigns each department string to
name. The new part is the second expression that says: let i=index. This is how you
get the iteration number out of ngFor.
In the span tag, we use the i variable to determine if we should show the greater-than
> symbol.
The idea is that given a department, we want to show the department string like:
1 Women > Apparel > Jackets & Vests
The expression {{i < (product.department.length-1) ? '>' : ''}} says that we
only want to use the '>' character if we're not the last department. On the last
department just show an empty string ''.
This format: test ? valueIfTrue : valueIfFalse is called the ternary
operator.
How Angular Works 131
NgModule and Booting the App
The final thing we have to do is ensure we have a NgModule for this app and boot it
up:
code/how-angular-works/inventory-app/src/app/app.module.ts
1 import { BrowserModule } from "@angular/platform-browser";
2 import { NgModule } from "@angular/core";
3 import { FormsModule } from "@angular/forms";
4
5 import { AppComponent } from "./app.component";
6 import { ProductImageComponent } from "./product-image/product-image.component";
7 import { ProductDepartmentComponent } from "./product-department/product-department.compo\
8 nent";
9 import { PriceDisplayComponent } from "./price-display/price-display.component";
10 import { ProductRowComponent } from "./product-row/product-row.component";
11 import { ProductsListComponent } from "./products-list/products-list.component";
12
13 @NgModule({
14 declarations: [
15 AppComponent,
16 ProductImageComponent,
17 ProductDepartmentComponent,
18 PriceDisplayComponent,
19 ProductRowComponent,
20 ProductsListComponent
21 ],
22 imports: [BrowserModule, FormsModule],
23 providers: [],
24 bootstrap: [AppComponent]
25 })
26 export class AppModule {}
Angular provides a module system that helps organize our code. Unlike AngularJS
1.x, where all directives are essentially globals, in Angular you must specify exactly
which components you're going to be using in your app.
While it is a bit more configuration to do it this way, it's a lifesaver for larger apps.
When you create new components in Angular, in order to use them they must be
accessible from the current module. That is, if we want to use the ProductsListComHow
Angular Works 132
ponent component with the products-list selector in the AppComponent template,
then we need to make sure that the AppComponent's module either:
1. is in the same module as the ProductsListComponent component or
2. The AppComponent's module imports the module that contains ProductsList-
Component
Remember every component you write must be declared in one NgModule
before it can be used in a template.
In this case, we're putting AppComponent, ProductsListComponent and all the other
components for this app in one module. This is easy and it means they can all "see"
each other.
Notice that we tell NgModule that we want to bootstrap with AppComponent. This
says that AppComponent will be the top-level component.
Because we are writing a browser app, we also put BrowserModule in the imports of
the NgModule.
Booting the app
To bootstrap this app we write this in our main.ts:
code/how-angular-works/inventory-app/src/main.ts
1 import { enableProdMode } from '@angular/core';
2 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
3
4 import { AppModule } from './app/app.module';
5 import { environment } from './environments/environment';
6
7 if (environment.production) {
8 enableProdMode();
9 }
10
11 platformBrowserDynamic().bootstrapModule(AppModule);
How Angular Works 133
The last line in this file is what boots our AppModule and subsequently boots our
Angular app.
Because this app was written with angular-cli, we can use the ng tool to run the
app by running ng serve.
That said, it can be tricky to understand what's going on there. When we run our
app with ng serve this is what happens:
• ng serve looks at .angular-cli.json which specifies main.ts as our entry
point (and index.html as our index file)
• main.ts bootstraps AppModule
• AppModule specifies that AppComponent is the top level component
• … and then AppComponent renders the rest of our app!
The Completed Project
To try it out, change into the project directory and type:
npm install
ng serve
Now we have all the pieces we need for the working project!
Here's what it will look like when we're done:
How Angular Works 134
Completed Inventory App
Now you can click to select a particular product and have it render a nice purple
outline when selected. If you add new Products in your code, you'll see them
rendered.
Deploying the App
We can deploy this app in the same way we deployed the app in the 1st chapter:
ng build --prod
And then push the files in dist to our server!
How Angular Works 135
A Word on Data Architecture
You might be wondering at this point how we would manage the data flow if we
started adding more functionality to this app.
Np. say we wanted to add a shopping cart view and then we would add
items to our cart. How could we implement this?
The only tools we've talked about are emitting output events. When we click add-tocart
do we simply bubble up an addedToCart event and handle at the root component?
That feels a bit awkward.
Data architecture is a large topic with many opinions. Thankfully, Angular is flexible
enough to handle a wide variety of data architectures, but that means that you have
to decide for yourself which to use.
In Angular 1, the default option was two-way data binding. Two-way data binding
is super easy to get started: your controllers have data, your forms manipulate that
data directly and your views show the data.
The problem with two-way data binding is that it often causes cascading effects
throughout your application and makes it really difficult to trace data flow as your
project grows.
Another problem with two-way data binding is that because you're passing data
down through components it often forces your "data layout tree" to match your "dom
view tree". In practice, these two things should really be separate.
One way you might handle this scenario would be to create a ShoppingCartService,
which would be a singleton that would hold the list of the current items in the cart.
This service could notify any interested objects when an item in the cart changes.
The idea is easy enough, but in practice there are a lot of details to be worked out.
The recommended way in Angular and in many modern web frameworks (such as
React), is to adopt a pattern of one-way data binding. That is, your data flows only
down through components. If you need to make changes, you emit events that cause
changes to happen "at the top" which then trickle down.
One-way data binding can seem like it adds some overhead in the beginning but it
saves a lot of complication around change detection and it makes your systems easier
How Angular Works 136
to reason about.
Thankfully there are two major contenders for managing your data architecture:
1. Use an Observables-based architecture like RxJS
2. Use a Flux-based architecture
Later in this book we'll talk about how to implement a scalable data architecture for
your app. For now, bask in the joy of your new Component-based application!
Built-in Directives
Introduction
Angular provides a number of built-in directives, which are attributes we add to our
HTML elements that give us dynamic behavior. In this chapter, we're going to cover
each built-in directive and show you examples of how to use them.
By the end of this chapter you'll be able to use the basic built-in directives that
Angular offers.
How To Use This Chapter
Instead of building an app step-by-step, this chapter is a tour of the builtin
directives in Angular. Since we're early in the book, we won't explain
every detail, but we will provide plenty of example code.
Remember: at any time you can reference the sample code for this chapter
to get the complete context.
If you'd like to run the examples in this chapter then see the folder
code/built-in-directives and run:
1 npm install
2 npm start
And then open http://localhost:4200⁴¹ in your browser.
NgIf
The ngIf directive is used when you want to display or hide an element based on a
condition. The condition is determined by the result of the expression that you pass
into the directive.
⁴¹http://localhost:4200
Built-in Directives 138
If the result of the expression returns a false value, the element will be removed from
the DOM.
Some examples are:
<div *ngIf="false"></div> <!-- never displayed -->
<div *ngIf="a > b"></div> <!-- displayed if a is more than b -->
<div *ngIf="str == 'yes'"></div> <!-- displayed if str is the string "yes" -->
<div *ngIf="myFunc()"></div> <!-- displayed if myFunc returns truthy -->
Note for AngularJS 1.x Users
If you've used AngularJS 1.x, you may have used the ngIf directive before.
You can think of the Angular version as a direct substitute.
On the other hand, Angular offers no built-in alternative for ng-show. So,
if your goal is to just change the CSS visibility of an element, you should
look into either the ngStyle or the class directives, described later in this
chapter.
NgSwitch
Sometimes you need to render different elements depending on a given condition.
When you run into this situation, you could use ngIf several times like this:
<div class="container">
<div *ngIf="myVar == 'A'">Var is A</div>
<div *ngIf="myVar == 'B'">Var is B</div>
<div *ngIf="myVar != 'A' && myVar != 'B'">Var is sth else</div>
</div>
But as you can see, the scenario where myVar is neither A nor B is verbose when all
we're trying to express is an else.
To illustrate this growth in complexity, say we wanted to handle a new value C.
In order to do that, we'd have to not only add the new element with ngIf, but also
change the last case:
Built-in Directives 139
<div class="container">
<div *ngIf="myVar == 'A'">Var is A</div>
<div *ngIf="myVar == 'B'">Var is B</div>
<div *ngIf="myVar == 'C'">Var is C</div>
<div *ngIf="myVar != 'A' && myVar != 'B' && myVar != 'C'">Var is sth else</div>
</div>
For cases like this, Angular introduces the ngSwitch directive.
If you're familiar with the switch statement then you'll feel very at home.
The idea behind this directive is the same: allow a single evaluation of an expression,
and then display nested elements based on the value that resulted from that
evaluation.
Once we have the result then we can:
• Describe the known results, using the ngSwitchCase directive
• Handle all the other unknown cases with ngSwitchDefault
Let's rewrite our example using this new set of directives:
<div class="container" [ngSwitch]="myVar">
<div *ngSwitchCase="'A'">Var is A</div>
<div *ngSwitchCase="'B'">Var is B</div>
<div *ngSwitchDefault>Var is sth else</div>
</div>
Then if we want to handle the new value C we insert a single line:
<div class="container" [ngSwitch]="myVar">
<div *ngSwitchCase="'A'">Var is A</div>
<div *ngSwitchCase="'B'">Var is B</div>
<div *ngSwitchCase="'C'">Var is C</div>
<div *ngSwitchDefault>Var is sth else</div>
</div>
And we don't have to touch the default (i.e. fallback) condition.
Having the ngSwitchDefault element is optional. If we leave it out, nothing will be
rendered when myVar fails to match any of the expected values.
You can also declare the same *ngSwitchCase value for different elements, so you're
not limited to matching only a single time. Here's an example:
Built-in Directives 140
code/built-in-directives/src/app/ng-switch-example/ng-switch-example.component.html
1 <h4 class="ui horizontal divider header">
2 Current choice is {{ choice }}
3 </h4>
4
5 <div class="ui raised segment">
6 <ul [ngSwitch]="choice">
7 <li *ngSwitchCase="1">First choice</li>
8 <li *ngSwitchCase="2">Second choice</li>
9 <li *ngSwitchCase="3">Third choice</li>
10 <li *ngSwitchCase="4">Fourth choice</li>
11 <li *ngSwitchCase="2">Second choice, again</li>
12 <li *ngSwitchDefault>Default choice</li>
13 </ul>
14 </div>
15
16 <div style="margin-top: 20px;">
17 <button class="ui primary button" (click)="nextChoice()">
18 Next choice
19 </button>
20 </div>
In the example above when the choice is 2, both the second and fifth lis will be
rendered.
NgStyle
With the NgStyle directive, you can set a given DOM element CSS properties from
Angular expressions.
The simplest way to use this directive is by doing [style.<cssproperty>]="value".
For example:
Built-in Directives 141
code/built-in-directives/src/app/ng-style-example/ng-style-example.component.html
5 <div [style.background-color]="'yellow'">
6 Uses fixed yellow background
7 </div>
This snippet is using the NgStyle directive to set the background-color CSS property
to the literal string 'yellow'.
Another way to set fixed values is by using the NgStyle attribute and using key value
pairs for each property you want to set, like this:
code/built-in-directives/src/app/ng-style-example/ng-style-example.component.html
13 <div [ngStyle]="{color: 'white', 'background-color': 'blue'}">
14 Uses fixed white text on blue background
15 </div>
Notice that in the ng-style specification we have single quotes around
background-color but not around color. Why is that? Well, the argument
to ng-style is a JS object and color is a valid key, without quotes.
With background-color, however, the dash character isn't allowed in an
object key, unless it's a string so we have to quote it.
Generally I'd leave out quoting as much as possible in object keys and only
quote keys when we have to.
Here we are setting both the color and the background-color properties.
But the real power of the NgStyle directive comes with using dynamic values.
In our example, we are defining two input boxes with an apply settings button:
Built-in Directives 142
code/built-in-directives/src/app/ng-style-example/ng-style-example.component.html
56 <div class="ui input">
57 <input type="text" name="color" value="{{color}}" #colorinput>
58 </div>
59
60 <div class="ui input">
61 <input type="text" name="fontSize" value="{{fontSize}}" #fontinput>
62 </div>
63
64 <button class="ui primary button" (click)="apply(colorinput.value, fontinput.value)">
65 Apply settings
66 </button>
And then using their values to set the CSS properties for three elements.
On the 1st one, we're setting the font size based on the input value:
code/built-in-directives/src/app/ng-style-example/ng-style-example.component.html
21 <div>
22 <span [ngStyle]="{color: 'red'}" [style.font-size.px]="fontSize">
23 red text
24 </span>
25 </div>
It's important to note that we have to specify units where appropriate. Np.
it isn't valid CSS to set a font-size of 12 - we have to specify a unit such as 12px
or 1.2em. Angular provides a handy syntax for specifying units: here we used the
notation [style.font-size.px].
The .px suffix indicates that we're setting the font-size property value in pixels.
You could easily replace that by [style.font-size.em] to express the font size in
ems or even in percentage using [style.font-size.%].
The other two elements use the #colorinput to set the text and background colors:
Built-in Directives 143
code/built-in-directives/src/app/ng-style-example/ng-style-example.component.html
33 <h4 class="ui horizontal divider header">
34 ngStyle with object property from variable
35 </h4>
36
37 <div>
38 <span [ngStyle]="{color: color}">
39 {{ color }} text
40 </span>
41 </div>
42
43 <h4 class="ui horizontal divider header">
44 style from variable
45 </h4>
46
47 <div [style.background-color]="color"
48 style="color: white;">
49 {{ color }} background
50 </div>
This way, when we click the Apply settings button, we call a method that sets the
new values:
code/built-in-directives/src/app/ng-style-example/ng-style-example.component.ts
32 apply(color: string, fontSize: number): void {
33 this.color = color;
34 this.fontSize = fontSize;
35 }
And with that, both the color and the font size will be applied to the elements using
the NgStyle directive.
NgClass
The NgClass directive, represented by a ngClass attribute in your HTML template,
allows you to dynamically set and change the CSS classes for a given DOM element.
Built-in Directives 144
The 1st way to use this directive is by passing in an object literal. The object is
expected to have the keys as the class names and the values should be a truthy/falsy
value to indicate whether the class should be applied or not.
Let's assume we have a CSS class called bordered that adds a dashed black border to
an element:
code/built-in-directives/src/styles.css
8 .bordered {
9 border: 1px dashed black;
10 background-color: #eee; }
Let's add two div elements: one always having the bordered class (and therefore
always having the border) and another one never having it:
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.html
2 <div [ngClass]="{bordered: false}">This is never bordered</div>
3 <div [ngClass]="{bordered: true}">This is always bordered</div>
As expected, this is how those two divs would be rendered:
Simple class directive usage
Of course, it's a lot more useful to use the NgClass directive to make class assignments
dynamic.
To make it dynamic we add a variable as the value for the object value, like this:
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.html
5 <div [ngClass]="{bordered: isBordered}">
6 Using object literal. Border {{ isBordered ? "ON" : "OFF" }}
7 </div>
Alternatively, we can define a classesObj object in our component:
Built-in Directives 145
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.ts
3 @Component({
4 selector: 'app-ng-class-example',
5 templateUrl: './ng-class-example.component.html'
6 })
7 export class NgClassExampleComponent implements OnInit {
8 isBordered: boolean;
9 classesObj: Object;
10 classList: string[];
11
12 constructor() {
13 }
14
15 ngOnInit() {
16 this.isBordered = true;
17 this.classList = ['blue', 'round'];
18 this.toggleBorder();
19 }
20
21 toggleBorder(): void {
22 this.isBordered = !this.isBordered;
23 this.classesObj = {
24 bordered: this.isBordered
25 };
26 }
And use the object directly:
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.html
9 <div [ngClass]="classesObj">
10 Using object var. Border {{ classesObj.bordered ? "ON" : "OFF" }}
11 </div>
Again, be careful when you have class names that contains dashes, like
bordered-box. JS requires that object-literal keys with dashes be
quoted like a string, as in:
<div [ngClass]="{'bordered-box': false}">...</div>
Built-in Directives 146
We can also use a list of class names to specify which class names should be added
to the element. For that, we can either pass in an array literal:
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.html
31 <div class="base" [ngClass]="['blue', 'round']">
32 This will always have a blue background and
33 round corners
34 </div>
Or assign an array of values to a property in our component:
this.classList = ['blue', 'round'];
And pass it in:
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.html
36 <div class="base" [ngClass]="classList">
37 This is {{ classList.indexOf('blue') > -1 ? "" : "NOT" }} blue
38 and {{ classList.indexOf('round') > -1 ? "" : "NOT" }} round
39 </div>
In this last example, the [ngClass] assignment works alongside existing values
assigned by the HTML class attribute.
The resulting classes added to the element will always be the set of the classes
provided by usual class HTML attribute and the result of the evaluation of the
[class] directive.
In this example:
code/built-in-directives/src/app/ng-class-example/ng-class-example.component.html
31 <div class="base" [ngClass]="['blue', 'round']">
32 This will always have a blue background and
33 round corners
34 </div>
Built-in Directives 147
The element will have all three classes: base from the class HTML attribute and also
blue and round from the [class] assignment:
Classes from both the attribute and directive
NgFor
The role of this directive is to repeat a given DOM element (or a collection of DOM
elements) and pass an element of the array on each iteration.
The syntax is *ngFor="let item of items".
• The let item syntax specifies a (template) variable that's receiving each
element of the items array;
• The items is the collection of items from your controller.
To illustrate, we can take a look at the code example. We declare an array of cities
on our component controller:
this.cities = ['Miami', 'Sao Paulo', 'New York'];
And then, in our template we can have the following HTML snippet:
Built-in Directives 148
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.html
1 <h4 class="ui horizontal divider header">
2 Simple list of strings
3 </h4>
4
5 <div class="ui list" *ngFor="let c of cities">
6 <div class="item">{{ c }}</div>
7 </div>
And it will render each city inside the div as you would expect:
Result of the ngFor directive usage
We can also iterate through an array of objects like these:
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.ts
17 this.people = [
18 { name: 'Anderson', age: 35, city: 'Sao Paulo' },
19 { name: 'John', age: 12, city: 'Miami' },
20 { name: 'Peter', age: 22, city: 'New York' }
21 ];
And then render a table based on each row of data:
Built-in Directives 149
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.html
9 <h4 class="ui horizontal divider header">
10 List of objects
11 </h4>
12
13 <table class="ui celled table">
14 <thead>
15 <tr>
16 <th>Name</th>
17 <th>Age</th>
18 <th>City</th>
19 </tr>
20 </thead>
21 <tr *ngFor="let p of people">
22 <td>{{ p.name }}</td>
23 <td>{{ p.age }}</td>
24 <td>{{ p.city }}</td>
25 </tr>
26 </table>
Getting the following result:
Rendering array of objects
We can also work with nested arrays. If we wanted to have the same table as above,
broken down by city, we could easily declare a new array of objects:
Built-in Directives 150
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.ts
22 this.peopleByCity = [
23 {
24 city: 'Miami',
25 people: [
26 { name: 'John', age: 12 },
27 { name: 'Angel', age: 22 }
28 ]
29 },
30 {
31 city: 'Sao Paulo',
32 people: [
33 { name: 'Anderson', age: 35 },
34 { name: 'Felipe', age: 36 }
35 ]
36 }
37 ];
38 }
And then we could use NgFor to render one h2 for each city:
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.html
32 <div *ngFor="let item of peopleByCity">
33 <h2 class="ui header">{{ item.city }}</h2>
And use a nested directive to iterate through the people for a given city:
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.html
13 <table class="ui celled table">
14 <thead>
15 <tr>
16 <th>Name</th>
17 <th>Age</th>
18 <th>City</th>
19 </tr>
20 </thead>
21 <tr *ngFor="let p of people">
22 <td>{{ p.name }}</td>
23 <td>{{ p.age }}</td>
24 <td>{{ p.city }}</td>
25 </tr>
26 </table>
Built-in Directives 151
Resulting in the following template code:
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.html
28 <h4 class="ui horizontal divider header">
29 Nested data
30 </h4>
31
32 <div *ngFor="let item of peopleByCity">
33 <h2 class="ui header">{{ item.city }}</h2>
34
35 <table class="ui celled table">
36 <thead>
37 <tr>
38 <th>Name</th>
39 <th>Age</th>
40 </tr>
41 </thead>
42 <tr *ngFor="let p of item.people">
43 <td>{{ p.name }}</td>
44 <td>{{ p.age }}</td>
45 </tr>
46 </table>
47 </div>
And it would render one table for each city:
Built-in Directives 152
Rendering nested arrays
Getting an index
There are times that we need the index of each item when we're iterating an array.
We can get the index by appending the syntax let idx = index to the value of our
ngFor directive, separated by a semi-colon. When we do this, ng2 will assign the
current index into the variable we provide (in this case, the variable idx).
Note that, like JS, the index is always zero based. So the index for
first element is 0, 1 for the second and so on…
Making some changes to our 1st example, adding the let num = index snippet like
below:
Built-in Directives 153
code/built-in-directives/src/app/ng-for-example/ng-for-example.component.html
53 <div class="ui list" *ngFor="let c of cities; let num = index">
54 <div class="item">{{ num+1 }} - {{ c }}</div>
55 </div>
It will add the position of the city before the name, like this:
Using an index
NgNonBindable
We use ngNonBindable when we want tell Angular not to compile or bind a particular
section of our page.
Let's say we want to render the literal text {{ content }} in our template. Normally
that text will be bound to the value of the content variable because we're using the
{{ }} template syntax.
So how can we render the exact text {{ content }}? We use the ngNonBindable
directive.
Let's say we want to have a div that renders the contents of that content variable
and right after we want to point that out by outputting <- this is what {{ content }}
rendered next to the actual value of the variable.
To do that, here's the template we'd have to use:
Built-in Directives 154
code/built-in-directives/src/app/ng-non-bindable-example/ng-non-bindable-example.
component.html
1 <div class='ngNonBindableDemo'>
2 <span class="bordered">{{ content }}</span>
3 <span class="pre" ngNonBindable>
4 &larr; This is what {{ content }} rendered
5 </span>
6 </div>
And with that ngNonBindable attribute, ng2 will not compile within that second
span's context, leaving it intact:
Result of using ngNonBindable
Conclusion
Angular has only a few core directives, but we can combine these simple pieces
to create dynamic, powerful apps. However, all of these directives help us output
dynamic data, they don't let us accept user interaction.
In the next chapter we'll learn how to let our user input data using forms.
Forms in Angular
Forms are Crucial, Forms are Complex
Forms are probably the most crucial aspect of your web application. While we often
get events from clicking on links or moving the mouse, it's through forms where we
get the majority of our rich data input from users.
On the surface, forms seem straightforward: you make an input tag, the user fills it
out and hits submit. How hard could it be?
It turns out, forms can be very complex. Here's a few reasons why:
• Form inputs are meant to modify data, both on the page and the server
• Changes often need to be reflected elsewhere on the page
• Users have a lot of leeway in what they enter, so you need to validate values
• The UI needs to clearly state expectations and errors, if any
• Dependent fields can have complex logic
• We want to be able to test our forms, without relying on DOM selectors
Thankfully, Angular has tools to help with all of these things.
• FormControls encapsulate the inputs in our forms and give us objects to work
with them
• Validators give us the ability to validate inputs, any way we'd like
• Observers let us watch our form for changes and respond accordingly
In this chapter we're going to walk through building forms, step by step. We'll start
with some simple forms and build up to more complicated logic.
Forms in Angular 156
FormControls and FormGroups
The two fundamental objects in Angular forms are FormControl and FormGroup.
FormControl
A FormControl represents a single input field - it is the smallest unit of an Angular
form.
FormControls encapsulate the field's value and states such as being valid, dirty
(changed), or has errors.
Np. here's how we might use a FormControl in TS:
// create a new FormControl with the value "Nate"
let nameControl = new FormControl("Nate");
let name = nameControl.value; // -> Nate
// now we can query this control for certain values:
nameControl.errors // -> StringMap<string, any> of errors
nameControl.dirty // -> false
nameControl.valid // -> true
// etc.
To build up forms we create FormControls (and groups of FormControls) and then
attach metadata and logic to them.
Like many things in Angular, we have a class (FormControl, in this case) that we
attach to the DOM with an attribute (formControl, in this case). Np. we
might have the following in our form:
<!-- part of some bigger form -->
<input type="text" [formControl]="name" />
This will create a new FormControl object within the context of our form. We'll talk
more about how that works below.
Forms in Angular 157
FormGroup
Most forms have more than one field, so we need a way to manage multiple
FormControls. If we wanted to check the validity of our form, it's cumbersome
to iterate over an array of FormControls and check each FormControl for validity.
FormGroups solve this issue by providing a wrapper interface around a collection of
FormControls.
Here's how you create a FormGroup:
let personInfo = new FormGroup({
firstName: new FormControl("Nate"),
lastName: new FormControl("Murray"),
zip: new FormControl("90210")
})
FormGroup and FormControl have a common ancestor (AbstractControl⁴²). That
means we can check the status or value of personInfo just as easily as a single
FormControl:
personInfo.value; // -> {
// firstName: "Nate",
// lastName: "Murray",
// zip: "90210"
// }
// now we can query this control group for certain values, which have sensible
// values depending on the children FormControl's values:
personInfo.errors // -> StringMap<string, any> of errors
personInfo.dirty // -> false
personInfo.valid // -> true
// etc.
Notice that when we tried to get the value from the FormGroup we received an object
with key-value pairs. This is a really handy way to get the full set of values from our
form without having to iterate over each FormControl individually.
⁴²https://angular.io/docs/ts/latest/api/forms/index/AbstractControl-class.html
Forms in Angular 158
Our 1st Form
There are lots of moving pieces to create a form and several important ones we
haven't touched on. Let's jump in to a full example and I'll explain each piece as we
go along.
You can find the full code listing for this section in the code download
under forms/
Here's a screenshot of the very 1st form we're going to build:
Demo Form with Sku: Simple Version
In our imaginary application we're creating an e-commerce-type site where we're
listing products for sale. In this app we need to store the product's SKU, so let's
create a simple form that takes the SKU as the only input field.
SKU is an abbreviation for "stockkeeping unit". It's a term for a unique id
for a product that is going to be tracked in inventory. When we talk about
a SKU, we're talking about a human-readable item ID.
Our form is super simple: we have a single input for sku (with a label) and a submit
button.
Let's turn this form into a Component. If you recall, there are three parts to defining
a component:
Forms in Angular 159
• Configure the @Component() decorator
• Create the template
• Implement custom functionality in the component definition class
Let's take these in turn:
Loading the FormsModule
In order to use the new forms library we need to 1st make sure we import the forms
library in our NgModule.
There are two ways of using forms in Angular and we'll talk about them both in
this chapter: using FormsModule or using ReactiveFormsModule. Since we'll use both,
we'll import them both into our module. To do this, we do the following in our app.ts
where we bootstrap the app:
1 // app.module.ts
2 import {
3 FormsModule,
4 ReactiveFormsModule
5 } from '@angular/forms';
6
7 // farther down...
8
9 @NgModule({
10 declarations: [
11 AppComponent,
12 DemoFormSkuComponent,
13 // ... our declarations here
14 ],
15 imports: [
16 BrowserModule,
17 FormsModule, // <-- add this
18 ReactiveFormsModule // <-- and this
19 ],
20 bootstrap: [ AppComponent ]
21 })
22 class AppModule {}
This ensures that we're able to use the form directives in our views. At the risk of
jumping ahead, the FormsModule gives us template driven directives such as:
Forms in Angular 160
• ngModel and
• NgForm
Whereas ReactiveFormsModule gives us reactive driven directives like
• formControl and
• ngFormGroup
… and several more. We haven't talked about how to use these directives or what
they do, but we will shortly. For now, just know that by importing FormsModule and
ReactiveFormsModule into our NgModule means we can use any of the directives in
that list in our view template or inject any of their respective providers into our
components.
Reactive- vs. template-driven Forms
Angular allows you to define forms in two different ways: "reactive" or "template"
driven. You can see a comparison of two ways here⁴³. Rather than describe how
they're different, we're going to show you examples of different ways you can build
forms - then you can decide which is right for your application.
Simple SKU Form: @Component Decorator
First, let's start by creating what's called a "template driven" form. Starting with our
component:
⁴³https://angular.io/guide/forms-overview
Forms in Angular 161
code/forms/src/app/demo-form-sku/demo-form-sku.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-demo-form-sku',
5 templateUrl: './demo-form-sku.component.html',
Here we define a selector of app-demo-form-sku. If you recall, selector tells
Angular what elements this component will bind to. In this case we can use this
component by having a app-demo-form-sku tag like so:
1 <app-demo-form-sku></app-demo-form-sku>
Simple SKU Form: template
Let's look at our template:
code/forms/src/app/demo-form-sku/demo-form-sku.component.html
1 <div class="ui raised segment">
2 <h2 class="ui header">Demo Form: Sku</h2>
3 <form #f="ngForm"
4 (ngSubmit)="onSubmit(f.value)"
5 class="ui form">
6
7 <div class="field">
8 <label for="skuInput">SKU</label>
9 <input type="text"
10 id="skuInput"
11 placeholder="SKU"
12 name="sku" ngModel>
13 </div>
14
15 <button type="submit" class="ui button">Submit</button>
16 </form>
17 </div>
Forms in Angular 162
form & NgForm
Now things get interesting: because we imported FormsModule, that makes NgForm
available to our view. Remember that whenever we make directives available to our
view, they will get attached to any element that matches their selector.
NgForm does sth handy but non-obvious: it includes the form tag in its selector
(instead of requiring you to explicitly add ngForm as an attribute). What this means is
that if you import FormsModule, NgForm will get automatically attached to any <form>
tags you have in your view. This is really useful but potentially confusing because it
happens behind the scenes.
There are two important pieces of functionality that NgForm gives us:
1. A FormGroup named ngForm
2. A (ngSubmit) output
You can see that we use both of these in the <form> tag in our view:
code/forms/src/app/demo-form-sku/demo-form-sku.component.html
3 <form #f="ngForm"
4 (ngSubmit)="onSubmit(f.value)"
First we have #f="ngForm". The #v="thing" syntax says that we want to create a
local variable for this view.
Here we're creating an alias to ngForm, for this view, bound to the variable #f. Where
did ngForm come from in the 1st place? It came from the NgForm directive.
And what type of object is ngForm? It is a FormGroup. That means we can use f as a
FormGroup in our view. And that's exactly what we do in the (ngSubmit) output.
Forms in Angular 163
Astute readers might notice that I just said above that NgForm is automatically
attached to <form> tags (because of the default NgForm selector), which
means we don't have to add an ngForm attribute to use NgForm. But here
we're putting ngForm in an attribute (value) tag. Is this a typo?
No, it's not a typo. If ngForm were the key of the attribute then we would
be telling Angular that we want to use NgForm on this attribute. In this
case, we're using ngForm as the attribute when we're assigning a reference.
That is, we're saying the value of the evaluated expression ngForm should
be assigned to a local template variable f.
ngForm is already on this element and you can think of it as if we are
"exporting" this FormGroup so that we can reference it elsewhere in our
view.
We bind to the ngSubmit action of our form by using the syntax: (ngSubmit)="onSubmit(f.value)".
• (ngSubmit) - comes from NgForm
• onSubmit() - will be implemented in our component definition class (below)
• f.value - f is the FormGroup that we specified above. And .value will return
the key/value pairs of this FormGroup
Put it all together and that line says "when I submit the form, call onSubmit on my
component instance and pass the value of the form as the argument".
input & NgModel
Our input tag has a few things we should touch on before we talk about NgModel:
Forms in Angular 164
code/forms/src/app/demo-form-sku/demo-form-sku.component.html
3 <form #f="ngForm"
4 (ngSubmit)="onSubmit(f.value)"
5 class="ui form">
6
7 <div class="field">
8 <label for="skuInput">SKU</label>
9 <input type="text"
10 id="skuInput"
11 placeholder="SKU"
12 name="sku" ngModel>
13 </div>
• class="ui form" and class="field" - these classes are totally optional. They
come from the CSS framework Semantic UI⁴⁴. I've added them in some of our
examples just to give them a nice coat of CSS but they're not part of Angular.
• The label "for" attribute and the input "id" attribute are to match, as per W3C
standard⁴⁵
• We set a placeholder of "SKU", which is just a hint to the user for what this
input should say when it is blank
The NgModel directive specifies a selector of ngModel. This means we can attach it
to our input tag by adding this sort of attribute: ngModel="whatever". In this case,
we specify ngModel with no attribute value.
There are a couple of different ways to specify ngModel in your templates and this is
the first. When we use ngModel with no attribute value we are specifying:
1. a one-way data binding
2. we want to create a FormControl on this form with the name sku (because of
the name attribute on the input tag)
NgModel creates a new FormControl that is automatically added to the parent
FormGroup (in this case, on the form) and then binds a DOM element to that new
⁴⁴http://semantic-ui.com/
⁴⁵http://www.w3.org/TR/WCAG20-TECHS/H44.html
Forms in Angular 165
FormControl. That is, it sets up an association between the input tag in our view and
the FormControl and the association is matched by a name, in this case "sku".
NgModel vs. ngModel: what's the difference? Generally, when we use
PascalCase, like NgModel, we're specifying the class and referring to the
object as it's defined in code. The lower case (CamelCase), as in ngModel,
comes from the selector of the directive and it's only used in the DOM /
template.
It's also worth pointing out that NgModel and FormControl are separate
objects. NgModel is the directive that you use in your view, whereas
FormControl is the object used for representing the data and validations
in your form.
Sometimes we want to do two-way binding with ngModel like we used to do
in Angular 1. We'll look at how to do that towards the end of this chapter.
Simple SKU Form: Component Definition Class
Now let's look at our class definition:
code/forms/src/app/demo-form-sku/demo-form-sku.component.ts
8 export class DemoFormSkuComponent implements OnInit {
9
10 constructor() { }
11
12 ngOnInit() {
13 }
14
15 onSubmit(form: any): void {
16 console.log('you submitted value:', form);
17 }
18
19 }
Here our class defines one function: onSubmit. This is the function that is called when
the form is submitted. For now, we'll just console.log out the value that is passed
in.
Forms in Angular 166
Try it out!
Putting it all together, here's what our code listing looks like:
code/forms/src/app/demo-form-sku/demo-form-sku.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-demo-form-sku',
5 templateUrl: './demo-form-sku.component.html',
6 styles: []
7 })
8 export class DemoFormSkuComponent implements OnInit {
9
10 constructor() { }
11
12 ngOnInit() {
13 }
14
15 onSubmit(form: any): void {
16 console.log('you submitted value:', form);
17 }
18
19 }
and the template:
code/forms/src/app/demo-form-sku/demo-form-sku.component.html
1 <div class="ui raised segment">
2 <h2 class="ui header">Demo Form: Sku</h2>
3 <form #f="ngForm"
4 (ngSubmit)="onSubmit(f.value)"
5 class="ui form">
6
7 <div class="field">
8 <label for="skuInput">SKU</label>
9 <input type="text"
10 id="skuInput"
11 placeholder="SKU"
12 name="sku" ngModel>
13 </div>
14
Forms in Angular 167
15 <button type="submit" class="ui button">Submit</button>
16 </form>
17 </div>
If we try this out in our browser, here's what it looks like:
Demo Form with Sku: Simple Version, Submitted
Using FormBuilder
Building our FormControls and FormGroups implicitly using ngForm is convenient, but
doesn't give us a lot of customization options. A more flexible and common way to
configure forms is to use a FormBuilder.
FormBuilder is an aptly-named helper class that helps us build forms. As you recall,
Forms in Angular 168
forms are made up of FormControls and FormGroups and the FormBuilder helps us
make them (you can think of it as a "factory" object).
Let's add a FormBuilder to our previous example. Let's look at:
• how to use the FormBuilder in our component definition class
• how to use our custom FormGroup on a form in the view
Reactive Forms with FormBuilder
For this component we're going to be using the formGroup and formControl directives
which means we need to import the appropriate classes. We start by importing them
like so:
code/forms/src/app/demo-form-sku-with-builder/demo-form-sku-with-builder.component.ts
1 import { Component, OnInit } from '@angular/core';
2 import {
3 FormBuilder,
4 FormGroup
5 } from '@angular/forms';
Using FormBuilder
We inject FormBuilder by creating an argument in the constructor of our component
class:
What does inject mean? We haven't talked much about dependency
injection (DI) or how DI relates to the hierarchy tree, so that last sentence
may not make a lot of sense. We talk a lot more about dependency injection
in the Dependency Injection chapter, so go there if you'd like to learn more
about it in depth.
At a high level, Dependency Injection is a way to tell Angular what
dependencies this component needs to function properly.
Forms in Angular 169
code/forms/src/app/demo-form-sku-with-builder/demo-form-sku-with-builder.component.ts
1 import { Component, OnInit } from '@angular/core';
2 import {
3 FormBuilder,
4 FormGroup
5 } from '@angular/forms';
6
7 @Component({
8 selector: 'app-demo-form-sku-with-builder',
9 templateUrl: './demo-form-sku-with-builder.component.html',
10 styles: []
11 })
12 export class DemoFormSkuWithBuilderComponent implements OnInit {
13 myForm: FormGroup;
14
15 constructor(fb: FormBuilder) {
16 this.myForm = fb.group({
17 'sku': ['ABC123']
18 });
19 }
20
21 ngOnInit() {
22 }
23
24 onSubmit(value: string): void {
25 console.log('you submitted value: ', value);
26 }
27
28 }
During injection an instance of FormBuilder will be created and we assign it to the
fb variable (in the constructor).
There are two main functions we'll use on FormBuilder:
• control - creates a new FormControl
• group - creates a new FormGroup
Notice that we've setup a new instance variable called myForm on this class. (We could
have just as easily called it form, but I want to differentiate between our FormGroup
and the form we had before.)
Forms in Angular 170
myForm is typed to be a FormGroup. We create a FormGroup by calling fb.group().
.group takes an object of key-value pairs that specify the FormControls in this group.
In this case, we're setting up one control sku and the value is ["ABC123"] - this says
that the default value of this control is "ABC123". (You'll notice that is an array. That's
because we'll be adding more configuration options there later.)
Now that we have myForm we need to use that in the view (i.e. we need to bind it to
our form element).
Using myForm in the view
We want to change our <form> to use myForm. If you recall, in the last section we
said that ngForm is applied for us automatically when we use FormsModule. We also
mentioned that ngForm creates its own FormGroup. Well, in this case, we don't want
to use an outside FormGroup. Instead we want to use our instance variable myForm,
which we created with our FormBuilder. How can we do that?
Angular provides another directive that we use when we have an existing Form-
Group: it's called formGroup and we use it like this:
code/forms/src/app/demo-form-sku-with-builder/demo-form-sku-with-builder.component.html
2 <h2 class="ui header">Demo Form: Sku with Builder</h2>
3 <form [formGroup]="myForm"
Here we're telling Angular that we want to use myForm as the FormGroup for this form.
Remember how earlier we said that when using FormsModule that NgForm
will be automatically applied to a <form> element? There is an exception:
NgForm won't be applied to a <form> that has formGroup.
If you're curious, the selector for NgForm is:
form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]
This means you could have a form that doesn't get NgForm applied by using
the ngNoForm attribute.
Forms in Angular 171
We also need to change onSubmit to use myForm instead of f, because now it is myForm
that has our configuration and values.
There's one last thing we need to do to make this work: bind our FormControl to the
input tag.
When we want to bind an existing FormControl to an input we use formControl:
code/forms/src/app/demo-form-sku-with-builder/demo-form-sku-with-builder.component.html
8 <label for="skuInput">SKU</label>
9 <input type="text"
10 id="skuInput"
11 placeholder="SKU"
12 [formControl]="myForm.controls['sku']">
Here we are instructing the formControl directive to look at myForm.controls and
use the existing sku FormControl for this input.
Try it out!
Here's what it looks like all together:
code/forms/src/app/demo-form-sku-with-builder/demo-form-sku-with-builder.component.ts
1 import { Component, OnInit } from '@angular/core';
2 import {
3 FormBuilder,
4 FormGroup
5 } from '@angular/forms';
6
7 @Component({
8 selector: 'app-demo-form-sku-with-builder',
9 templateUrl: './demo-form-sku-with-builder.component.html',
10 styles: []
11 })
12 export class DemoFormSkuWithBuilderComponent implements OnInit {
13 myForm: FormGroup;
14
15 constructor(fb: FormBuilder) {
16 this.myForm = fb.group({
17 'sku': ['ABC123']
18 });
Forms in Angular 172
19 }
20
21 ngOnInit() {
22 }
23
24 onSubmit(value: string): void {
25 console.log('you submitted value: ', value);
26 }
27
28 }
and the template:
code/forms/src/app/demo-form-sku-with-builder/demo-form-sku-with-builder.component.html
1 <div class="ui raised segment">
2 <h2 class="ui header">Demo Form: Sku with Builder</h2>
3 <form [formGroup]="myForm"
4 (ngSubmit)="onSubmit(myForm.value)"
5 class="ui form">
6
7 <div class="field">
8 <label for="skuInput">SKU</label>
9 <input type="text"
10 id="skuInput"
11 placeholder="SKU"
12 [formControl]="myForm.controls['sku']">
13 </div>
14
15 <button type="submit" class="ui button">Submit</button>
16 </form>
17 </div>
Remember:
To create a new FormGroup and FormControls implicitly use:
• ngForm and
• ngModel
But to bind to an existing FormGroup and FormControls use:
• formGroup and
• formControl
Forms in Angular 173
Adding Validations
Our users aren't always going to enter data in exactly the right format. If someone
enters data in the wrong format, we want to give them feedback and not allow the
form to be submitted. For this we use validators.
Validators are provided by the Validators module and the simplest validator is
Validators.required which simply says that the designated field is required or else
the FormControl will be considered invalid.
To use validators we need to do two things:
1. Assign a validator to the FormControl object
2. Check the status of the validator in the view and take action accordingly
To assign a validator to a FormControl object we simply pass it as the second
argument to our FormControl constructor:
1 let control = new FormControl('sku', Validators.required);
Or in our case, because we're using FormBuilder we will use the following syntax:
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.ts
18 constructor(fb: FormBuilder) {
19 this.myForm = fb.group({
20 'sku': ['', Validators.required]
21 });
22
23 this.sku = this.myForm.controls['sku'];
24 }
Now we need to use our validation in the view. There are two ways we can access
the validation value in the view:
1. We can explicitly assign the FormControl sku to an instance variable of the class
- which is more verbose, but gives us easy access to the FormControl in the view.
2. We can lookup the FormControl sku from myForm in the view. This requires less
work in the component definition class, but is slightly more verbose in the view.
To make this difference clearer, let's look at this example both ways:
Forms in Angular 174
Explicitly setting the sku FormControl as an instance
variable
Here's a screenshot of what our form is going to look like with validations:
Demo Form with Validations
The most flexible way to deal with individual FormControls in your view is to set
each FormControl up as an instance variable in your component definition class.
Here's how we could setup sku in our class:
Forms in Angular 175
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.ts
14 export class DemoFormWithValidationsExplicitComponent {
15 myForm: FormGroup;
16 sku: AbstractControl;
17
18 constructor(fb: FormBuilder) {
19 this.myForm = fb.group({
20 'sku': ['', Validators.required]
21 });
22
23 this.sku = this.myForm.controls['sku'];
24 }
25
26 onSubmit(value: string): void {
27 console.log('you submitted value: ', value);
28 }
29
30 }
Notice that:
1. We setup sku: AbstractControl at the top of the class and
2. We assign this.sku after we've created myForm with the FormBuilder
This is great because it means we can reference sku anywhere in our component view.
The downside is that by doing it this way, we'd have to setup an instance variable
for every field in our form. For large forms, this can get pretty verbose.
Now that we have our sku being validated, I want to look at four different ways we
can use it in our view:
1. Checking the validity of our whole form and displaying a message
2. Checking the validity of our individual field and displaying a message
3. Checking the validity of our individual field and coloring the field red if it's
invalid
4. Checking the validity of our individual field on a particular requirement and
displaying a message
Form message
We can check the validity of our whole form by looking at myForm.valid:
Forms in Angular 176
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.html
20 <div *ngIf="!myForm.valid"
Remember, myForm is a FormGroup and a FormGroup is valid if all of the children
FormControls are also valid.
Field message
We can also display a message for the specific field if that field's FormControl is
invalid:
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.html
14 [formControl]="sku">
15 <div *ngIf="!sku.valid"
16 class="ui error message">SKU is invalid</div>
17 <div *ngIf="sku.hasError('required')"
Field coloring
I'm using the Semantic UI CSS Framework's CSS class .error, which means if I add
the class error to the <div class= "field"> it will show the input tag with a red
border.
To do this, we can use the property syntax to set conditional classes:
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.html
7 <div class="field"
8 [class.error]="!sku.valid && sku.touched">
Notice here that we have two conditions for setting the .error class: We're checking
for !sku.valid and sku.touched. The idea here is that we only want to show the
error state if the user has tried editing the form ("touched" it) and it's now invalid.
To try this out, enter some data into the input tag and then delete the contents of the
field.
Forms in Angular 177
Specific validation
A form field can be invalid for many reasons. We often want to show a different
message depending on the reason for a failed validation.
To look up a specific validation failure we use the hasError method:
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.html
17 <div *ngIf="sku.hasError('required')"
18 class="ui error message">SKU is required</div>
Note that hasError is defined on both FormControl and FormGroup. This means you
can pass a second argument of path to lookup a specific field from FormGroup. For
example, we could have written the previous example as:
1 <div *ngIf="myForm.hasError('required', 'sku')"
2 class="error">SKU is required</div>
Putting it together
Here's the full code listing of our form with validations with the FormControl set as
an instance variable:
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.ts
1 import { Component } from '@angular/core';
2 import {
3 FormBuilder,
4 FormGroup,
5 Validators,
6 AbstractControl
7 } from '@angular/forms';
8
9 @Component({
10 selector: 'app-demo-form-with-validations-explicit',
11 templateUrl: './demo-form-with-validations-explicit.component.html',
12 styles: []
13 })
14 export class DemoFormWithValidationsExplicitComponent {
Forms in Angular 178
15 myForm: FormGroup;
16 sku: AbstractControl;
17
18 constructor(fb: FormBuilder) {
19 this.myForm = fb.group({
20 'sku': ['', Validators.required]
21 });
22
23 this.sku = this.myForm.controls['sku'];
24 }
25
26 onSubmit(value: string): void {
27 console.log('you submitted value: ', value);
28 }
29
30 }
And the template:
code/forms/src/app/demo-form-with-validations-explicit/demo-form-with-validationsexplicit.
component.html
1 <div class="ui raised segment">
2 <h2 class="ui header">Demo Form: with validations (explicit)</h2>
3 <form [formGroup]="myForm"
4 (ngSubmit)="onSubmit(myForm.value)"
5 class="ui form"
6 [class.error]="!myForm.valid && myForm.touched">
7
8 <div class="field"
9 [class.error]="!sku.valid && sku.touched">
10 <label for="skuInput">SKU</label>
11 <input type="text"
12 id="skuInput"
13 placeholder="SKU"
14 [formControl]="sku">
15 <div *ngIf="!sku.valid"
16 class="ui error message">SKU is invalid</div>
17 <div *ngIf="sku.hasError('required')"
18 class="ui error message">SKU is required</div>
19 </div>
20
21 <div *ngIf="!myForm.valid"
22 class="ui error message">Form is invalid</div>
23
Forms in Angular 179
24 <button type="submit" class="ui button">Submit</button>
25 </form>
26 </div>
Removing the sku instance variable
In the example above we set sku: AbstractControl as an instance variable. We often
won't want to create an instance variable for each AbstractControl, so how would
we reference this FormControl in our view without an instance variable?
Instead we can use the myForm.controls property as in:
code/forms/src/app/demo-form-with-validations-shorthand/demo-form-with-validationsshorthand.
component.html
10 <label for="skuInput">SKU</label>
11 <input type="text"
12 id="skuInput"
13 placeholder="SKU"
14 [formControl]="myForm.controls['sku']">
15 <div *ngIf="!myForm.controls['sku'].valid"
16 class="ui error message">SKU is invalid</div>
17 <div *ngIf="myForm.controls['sku'].hasError('required')"
In this way we can access the sku control without being forced to explicitly add it as
an instance variable on the component class.
We used bracket-notation, e.g. myForm.controls['sku']. We could also
use the dot-notation, e.g myForm.controls.sku. In general, be aware that
TS may give a warning if you use the dot-notation and the object
is not properly typed (but that is not a problem here).
Custom Validations
We often are going to want to write our own custom validations. Let's take a look at
how to do that.
To see how validators are implemented, let's look at Validators.required from the
Angular core source:
Forms in Angular 180
1 export class Validators {
2 static required(c: FormControl): StringMap<string, boolean> {
3 return isBlank(c.value) || c.value == "" ? {"required": true} : null;
4 }
A validator: - Takes a FormControl as its input and - Returns a StringMap<string,
boolean> where the key is "error code" and the value is true if it fails
Writing the Validator
Let's say we have specific requirements for our sku. Np. say our sku needs
to begin with 123. We could write a validator like so:
code/forms/src/app/demo-form-with-custom-validation/demo-form-with-customvalidation.
component.ts
18 function skuValidator(control: FormControl): { [s: string]: boolean } {
19 if (!control.value.match(/^123/)) {
20 return {invalidSku: true};
21 }
22 }
This validator will return an error code invalidSku if the input (the control.value)
does not begin with 123.
Assigning the Validator to the FormControl
Now we need to add the validator to our FormControl. However, there's one small
problem: we already have a validator on sku. How can we add multiple validators to
a single field?
For that, we use Validators.compose:
Forms in Angular 181
code/forms/src/app/demo-form-with-custom-validation/demo-form-with-customvalidation.
component.ts
33 constructor(fb: FormBuilder) {
34 this.myForm = fb.group({
35 'sku': ['', Validators.compose([
36 Validators.required, skuValidator])]
37 });
Validators.compose wraps our two validators and lets us assign them both to the
FormControl. The FormControl is not valid unless both validations are valid.
Now we can use our new validator in the view:
code/forms/src/app/demo-form-with-custom-validation/demo-form-with-customvalidation.
component.html
19 <div *ngIf="sku.hasError('invalidSku')"
20 class="ui error message">SKU must begin with <span>123</span></div>
Note that in this section, I'm using "explicit" notation of adding an instance
variable for each FormControl. That means that in the view in this section,
sku refers to a FormControl.
If you run the sample code, one neat thing you'll notice is that if you type sth
in to the field, the required validation will be fulfilled, but the invalidSku validation
may not. This is great - it means we can partially-validate our fields and show the
appropriate messages.
Watching For Changes
So far we've only extracted the value from our form by calling onSubmit when the
form is submitted. But often we want to watch for any value changes on a control.
Both FormGroup and FormControl have an EventEmitter that we can use to observe
changes.
Forms in Angular 182
EventEmitter is an Observable, which means it conforms to a defined specification
for watching for changes. If you're interested in the Observable
spec, you can find it here⁴⁶
To watch for changes on a control we:
1. get access to the EventEmitter by calling control.valueChanges. Then we
2. add an observer using the .subscribe method
Here's an example:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.ts
21 constructor(fb: FormBuilder) {
22 this.myForm = fb.group({
23 'sku': ['', Validators.required]
24 });
25
26 this.sku = this.myForm.controls['sku'];
27
28 this.sku.valueChanges.subscribe(
29 (value: string) => {
30 console.log('sku changed to:', value);
31 }
32 );
33
34 this.myForm.valueChanges.subscribe(
35 (form: any) => {
36 console.log('form changed to:', form);
37 }
38 );
39
40 }
Here we're observing two separate events: changes on the sku field and changes on
the form as a whole.
The observable that we pass in is an object with a single key: next (there are other
keys you can pass in, but we're not going to worry about those now). next is the
function we want to call with the new value whenever the value changes.
⁴⁶https://github.com/jhusain/observable-spec
Forms in Angular 183
If we type 'kj' into the text box we will see in our console:
1 sku changed to: k
2 form changed to: Object {sku: "k"}
3 sku changed to: kj
4 form changed to: Object {sku: "kj"}
As you can see each keystroke causes the control to change, so our observable is
triggered. When we observe the individual FormControl we receive a value (e.g. kj),
but when we observe the whole form, we get an object of key-value pairs (e.g. {sku:
"kj"}).
ngModel
NgModel is a special directive: it binds a model to a form. ngModel is special in that it
mimics two-way data binding.
Two-way data binding is almost always more complicated and difficult to reason
about vs. one-way data binding. Angular is built to generally have data flow oneway:
top-down. However, when it comes to forms, there are times where it is easier
to opt-in to a two-way bind.
Just because you've used ng-model in Angular 1 in the past, don't rush to
use ngModel right away. There are good reasons to avoid two-way data
binding⁴⁷. Of course, ngModel can be really handy, but know that we don't
necessarily rely on two-way data binding as much as we did in Angular 1.
Let's change our form a little bit and say we want to input productName. We're going
to use ngModel to keep the component instance variable in sync with the view.
First, here's our component definition class:
⁴⁷https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2
Forms in Angular 184
code/forms/src/app/demo-form-ng-model/demo-form-ng-model.component.ts
10 export class DemoFormNgModelComponent {
11 productName: string;
12
13 constructor() {
14 this.productName = "ng-book: The Complete Guide to Angular"
15 }
16
17 onSubmit(value: string): void {
18 console.log('you submitted value: ', value);
19 }
20 }
Notice that we're simply storing productName: string as an instance variable.
Next, let's use ngModel on our input tag:
code/forms/src/app/demo-form-ng-model/demo-form-ng-model.component.html
13 <label for="productNameInput">Product Name</label>
14 <input type="text"
15 id="productNameInput"
16 placeholder="Product Name"
17 name="productName"
18 [(ngModel)]="productName">
Now notice sth - the syntax for ngModel is funny: we are using both brackets
and parentheses around the ngModel attribute! The idea this is intended to invoke is
that we're using both the input [] brackets and the output () parentheses. It's an
indication of the two-way bind.
Last, let's display our productName value in the view:
code/forms/src/app/demo-form-ng-model/demo-form-ng-model.component.html
4 <div class="ui info message">
5 The product name is: {{productName}}
6 </div>
Here's what it looks like:
Forms in Angular 185
Demo Form with ngModel
Easy!
Wrapping Up
Forms have a lot of moving pieces, but Angular makes it fairly straightforward. Once
you get a handle on how to use FormGroups, FormControls and Validations, it's
pretty easy going from there!
Dependency Injection
As our programs grow in size, parts of the app need to communicate with other
modules. When module A requires module B to run, we say that B is a dependency of
A.
One of the most common ways to get access to dependencies is to simply import a
file. Np. in this hypothetical module we might do the following:
// in A.ts
import { B } from "B"; // a dependency!
B.foo(); // using B
In many cases, simply importing code is sufficient, but other times we need to provide
dependencies in a more sophisticated way. Np. we may want to:
• substitute out the implementation of B for MockB during testing
• share a single instance of the B class across our whole app (e.g. the Singleton
pattern)
• create a new instance of the B class every time it is used (e.g. the Factory pattern)
Dependency Injection can solve these problems.
Dependency Injection (DI) is a system to make parts of our program accessible to
other parts of the program - and we can configure how that happens.
One way to think about "the injector" is as a replacement for the new
operator. That is, instead of using the language-provided new operator,
Dependency Injection let's us configure how objects are created.
The term Dependency Injection is used to describe both a design pattern (used in
many different frameworks) and also the specific implementation of DI that is builtin
to Angular.
Dependency Injection 187
The major benefit of using Dependency Injection is that the client component needn't
be aware of how to create the dependencies. All the client component needs to
know is how to interact with those dependencies. This is all very abstract, so let's
dive in to some code.
How to use this chapter
This chapter is a tour of Angular DI system and concepts. You can find the
code for this chapter in code/dependency-injection.
While reading this chapter, run the demo project by changing into the
project directory and running:
npm install npm start
As a preview, to get Dependency Injection to work involves configuration
in your NgModules. It can feel a bit confusing at 1st to figure out "where"
things are coming from.
The example code has full, runnable examples with all of the context. So
if you feel lost, we'd encourage you to checkout the sample code alongside
reading this chapter.
Injections Example: PriceService
Let's imagine we're building a store that has Products and we need to calculate the
final price of that product after sales tax. In order to calculate the full price for this
product, we use a PriceService that takes as input:
• the base price of the Product and
• the state we're selling it to.
and then returns the final price of the Product, plus tax:
Dependency Injection 188
code/dependency-injection/src/app/price-service-demo/price.service.1.ts
1 export class PriceService {
2 constructor() { }
3
4 calculateTotalPrice(basePrice: number, state: string) {
5 // e.g. Imgine that in our "real" application we're
6 // accessing a real database of state sales tax amounts
7 const tax = Math.random();
8
9 return basePrice + tax;
10 }
11
12 }
In this service, the calculateTotalPrice function will take the basePrice of a
product and the state and return the total price of product.
Say we want to use this service on our Product model. Here's how it could look
without dependency injection:
code/dependency-injection/src/app/price-service-demo/product.model.1.ts
1 import { PriceService } from './price.service';
2
3 export class Product {
4 service: PriceService;
5 basePrice: number;
6
7 constructor(basePrice: number) {
8 this.service = new PriceService(); // <-- create directly ("hardcoded")
9 this.basePrice = basePrice;
10 }
11
12 totalPrice(state: string) {
13 return this.service.calculateTotalPrice(this.basePrice, state);
14 }
15 }
Now imagine we need to write a test for this Product class. We could write a test like
this:
Dependency Injection 189
1 import { Product } from './product';
2
3 describe('Product', () => {
4
5 let product;
6
7 beforeEach(() => {
8 product = new Product(11);
9 });
10
11 describe('price', () => {
12 it('is calculated based on the basePrice and the state', () => {
13 expect(product.totalPrice('FL')).toBe(11.66); // <-- hmmm
14 });
15 })
16
17 });
The problem with this test is that we don't actually know what the exact value for
tax in Florida ('FL') is going to be. Even if we implemented the PriceService the
'real' way by calling an API or calling a database, we have the problem that:
• The API needs to be available (or the database needs to be running) and
• We need to know the exact Florida tax at the time we write the test.
What should we do if we want to test the price method of the Product without
relying on this external resource? In this case we often mock the PriceService. For
example, if we know the interface of a PriceService, we could write a MockPrice-
Service which will always give us a predictable calculation (and not be reliant on a
database or API).
Here's the interface for IPriceService:
code/dependency-injection/src/app/price-service-demo/price-service.interface.ts
1 export interface IPriceService {
2 calculateTotalPrice(basePrice: number, state: string): number;
3 }
This interface defines just one function: calculateTotalPrice. Now we can write
a MockPriceService that conforms to this interface, which we will use only for our
tests:
Dependency Injection 190
code/dependency-injection/src/app/price-service-demo/price.service.mock.ts
1 import { IPriceService } from './price-service.interface';
2
3 export class MockPriceService implements IPriceService {
4 calculateTotalPrice(basePrice: number, state: string) {
5 if (state === 'FL') {
6 return basePrice + 0.66; // it's always 66 cents!
7 }
8
9 return basePrice;
10 }
11 }
Now, just because we've written a MockPriceService doesn't mean our Product will
use it. In order to use this service, we need to modify our Product class:
code/dependency-injection/src/app/price-service-demo/product.model.ts
1 import { IPriceService } from './price-service.interface';
2
3 export class Product {
4 service: IPriceService;
5 basePrice: number;
6
7 constructor(service: IPriceService, basePrice: number) {
8 this.service = service; // <-- passed in as an argument!
9 this.basePrice = basePrice;
10 }
11
12 totalPrice(state: string) {
13 return this.service.calculateTotalPrice(this.basePrice, state);
14 }
15 }
Now, when creating a Product the client using the Product class becomes responsible
for deciding which concrete implementation of the PriceService is going
to be given to the new instance.
And with this change, we can tweak our test slightly and get rid of the dependency
on the unpredictable PriceService:
Dependency Injection 191
code/dependency-injection/src/app/price-service-demo/product.spec.ts
1 import { Product } from './product.model';
2 import { MockPriceService } from './price.service.mock';
3
4 describe('Product', () => {
5 let product;
6
7 beforeEach(() => {
8 const service = new MockPriceService();
9 product = new Product(service, 11.00);
10 });
11
12 describe('price', () => {
13 it('is calculated based on the basePrice and the state', () => {
14 expect(product.totalPrice('FL')).toBe(11.66);
15 });
16 });
17 });
We also get the bonus of having confidence that we're testing the Product class
in isolation. That is, we're making sure that our class works with a predictable
dependency.
While the predictability is nice, it's a bit laborious to pass a concrete implementation
of a service every time we want a new Product. Thankfully, Angular's DI library
helps us deal with that problem, too. More on that below.
Within Angular's DI system, instead of directly importing and creating a new instance
of a class, instead we will:
• Register the "dependency" with Angular
• Describe how the dependency will be injected
• Inject the dependency
One benefit of this model is that the dependency implementation can be swapped at
run-time (as in our mocking example above). But another significant benefit is that
we can configure how the dependency is created.
That is, often in the case of program-wide services, we may want to have only one
instance - that is, a Singleton. With DI we're able to configure Singletons easily.
Dependency Injection 192
A third use-case for DI is for configuration or environment-specific variables. For
instance, we might define a "constant" API_URL, but then inject a different value in
production vs. development.
Let's learn how to create our own services and the different ways of injecting them.
Dependency Injection Parts
To register a dependency we have to bind it to sth that will identify that
dependency. This identification is called the dependency token. Np. if we
want to register the URL of an API, we can use the string API_URL as the token.
Similarly, if we're registering a class, we can use the class itself as its token as we'll
see below.
Dependency injection in Angular has three pieces:
• the Provider (also often referred to as a binding) maps a token (that can be
a string or a class) to a list of dependencies. It tells Angular how to create an
object, given a token.
• the Injector that holds a set of bindings and is responsible for resolving
dependencies and injecting them when creating objects
• the Dependency that is what's being injected
We can think of the role of each piece as illustrated below:
Dependency Injection
Dependency Injection 193
A way of thinking about this is that when we configure DI we specify what is being
injected and how it will be resolved.
Playing with an Injector
Above with our Product and PriceService we manually created the PriceService
using the new operator. This mimics what Angular itself does.
Angular uses an injector to resolve a dependency and create the instance. This
is done for us behind the scenes, but as an exercise, it's useful to explore what's
happening. It can be enlightening to use the injector manually, because we can see
what Angular does for us behind the scenes.
Let's manually use the injector in our component to resolve and create a service.
(After we've resolved a dependency manually, we'll show the typical, easy way of
injecting dependencies. )
One of the common use-cases for services is to have a 'global' Singleton object.
Np. we might have a UserService which contains the information for the
currently logged in user. Many different components will want to have logic based
on the current user, so this is a good case for a service.
Here's a basic UserService that stores the user object as a property:
code/dependency-injection/src/app/services/user.service.ts
1 import { Injectable } from '@angular/core';
2
3 @Injectable()
4 export class UserService {
5 user: any;
6
7 setUser(newUser) {
8 this.user = newUser;
9 }
10
11 getUser(): any {
12 return this.user;
13 }
14 }
Say we want to create a toy sign-in form:
Dependency Injection 194
code/dependency-injection/src/app/user-demo/user-demo.component.html
1 <div>
2 <p
3 *ngIf="userName"
4 class="welcome">
5 Welcome: {{ userName }}!
6 </p>
7 <button
8 (click)="signIn()"
9 class="ui button"
10 >Sign In
11 </button>
12 </div>
Above, we click the "Sign In" button to call the signIn() function (which we'll define
in a moment). If we have a userName, we'll display a greeting.
Simple Sign In Button
Now let's implement this functionality in our component by using the injector
directly.
Dependency Injection 195
code/dependency-injection/src/app/user-demo/user-demo.injector.component.ts
1 import {
2 Component,
3 ReflectiveInjector
4 } from '@angular/core';
5
6 import { UserService } from '../services/user.service';
7
8 @Component({
9 selector: 'app-injector-demo',
10 templateUrl: './user-demo.component.html',
11 styleUrls: ['./user-demo.component.css']
12 })
13 export class UserDemoInjectorComponent {
14 userName: string;
15 userService: UserService;
16
17 constructor() {
18 // Create an _injector_ and ask for it to resolve and create a UserService
19 const injector: any = ReflectiveInjector.resolveAndCreate([UserService]);
20
21 // use the injector to **get the instance** of the UserService
22 this.userService = injector.get(UserService);
23 }
24
25 signIn(): void {
26 // when we sign in, set the user
27 // this mimics filling out a login form
28 this.userService.setUser({
29 name: 'Nate Murray'
30 });
31
32 // now **read** the user name from the service
33 this.userName = this.userService.getUser().name;
34 console.log('User name is: ', this.userName);
35 }
36 }
This starts as a basic component: we have a selector, template and CSS. Note that
we have two properties: userName, which holds the currently logged-in user's name
and userService, which holds a reference to the UserService.
Dependency Injection 196
In our component's constructor we are using a static method from ReflectiveInjector
called resolveAndCreate. That method is responsible for creating a new
injector. The parameter we pass in is an array with all the injectable things we
want this new injector to know. In our case, we just wanted it to know about the
UserService injectable.
The ReflectiveInjector is a concrete implementation of Injector that
uses reflection to look up the proper parameter types. While there are other
injectors that are possible ReflectiveInjector is the "normal" injector
we'll be using in most apps.
Signed In
Providing Dependencies with NgModule
While it's interesting to see how an injector is created directly, that isn't the typical
way we'd use injections. Instead, what we'd normally do is
• use NgModule to register what we'll inject – these are called providers and
Dependency Injection 197
• use decorators (generally on a constructor) to specify what we're injecting
By doing these two steps Angular will manage creating the injector and resolving
the dependencies.
Let's convert our UserService to be injectable as a singleton across our app. First,
we're going to add it to the providers key of our NgModule:
code/dependency-injection/src/app/user-demo/user-demo.module.ts
1 import { NgModule } from '@angular/core';
2 import { CommonModule } from '@angular/common';
3
4 // imported here
5 import { UserService } from '../services/user.service';
6
7 @NgModule({
8 imports: [
9 CommonModule
10 ],
11 providers: [
12 UserService // <-- added right here
13 ],
14 declarations: []
15 })
16 export class UserDemoModule { }
Now we can inject UserService into our component like this:
code/dependency-injection/src/app/user-demo/user-demo.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 import { UserService } from '../services/user.service';
4
5 @Component({
6 selector: 'app-user-demo',
7 templateUrl: './user-demo.component.html',
8 styleUrls: ['./user-demo.component.css']
9 })
10 export class UserDemoComponent {
11 userName: string;
12 // removed `userService` because of constructor shorthand below
Dependency Injection 198
13
14 // Angular will inject the singleton instance of `UserService` here.
15 // We set it as a property with `private`.
16 constructor(private userService: UserService) {
17 // empty because we don't have to do anything else!
18 }
19
20 // below is the same...
21 signIn(): void {
22 // when we sign in, set the user
23 // this mimics filling out a login form
24 this.userService.setUser({
25 name: 'Nate Murray'
26 });
27
28 // now **read** the user name from the service
29 this.userName = this.userService.getUser().name;
30 console.log('User name is: ', this.userName);
31 }
32 }
Notice in the constructor above that we have made userService: UserService an
argument to the UserDemoComponent. When this component is created on our page
Angular will resolve and inject the UserService singleton. What's great about
this is that because Angular is managing the instance, we don't have to worry about
doing it ourselves. Every class that injects the UserService will receive the same
singleton.
Providers are the Key
It's important to know that when we put the UserService on the constructor of the
UserDemoComponent, Angular knows what to inject (and how) **because we listed
UserService in the providers key of our NgModule.
It does not inject arbitrary classes. You must configure an NgModule for DI to work.
We've been talking a lot about Singleton services, but we can inject things in lots of
other ways. Let's take a look.
Dependency Injection 199
Providers
There are several ways we can configure resolving injected dependencies in Angular.
For instance we can:
• Inject a (singleton) instance of a class (as we've seen)
• Inject a value
• Call any function and inject the return value of that function
Let's look into detail at how we create each one:
Using a Class
As we've discussed, injecting a singleton instance of a class is probably the most
common type of injection.
When we put the class itself into the list of providers like this:
providers: [UserService];
This tells Angular that we want to provide a singleton instance of UserService
whenever UserService is injected. Because this pattern is so common, the class by
itself is actually shorthand notation for the following, equivalent configuration:
providers: [{ provide: UserService, useClass: UserService }];
What's interesting to note is that the object configuration with provide takes two
keys. provide is the token that we use to identify the injection and the second
useClass is how and what to inject.
Here we're mapping the UserService class to the UserService token. In this case,
the name of the class and the token match. This is the common case, but know that
the token and the injected thing aren't required to have the same name.
As we've seen above, in this case the injector will create a singleton behind the
scenes and return the same instance every time we inject it . Of course, the first
time it is injected, the singleton hasn't been instantiated yet, so when creating
the UserService instance for the 1st time, the DI system will trigger the class
constructor method.
Dependency Injection 200
Using a Value
Another way we can use DI is to provide a value, much like we might use a global
constant. Np. we might configure an API Endpoint URL depending on the
environment.
To do this, in our NgModule providers, we use the key useValue:
providers: [{ provide: "API_URL", useValue: "http://my.api.com/v1" }];
Above, for the provide token we're using a string of API_URL. If we use a string
for the provide value, Angular can't infer which dependency we're resolving by the
type. For instance we can't write:
// doesn't work - anti-example
export class AnalyticsDemoComponent {
constructor(apiUrl: "API_URL") {
// <--- this isn't a type, just a string
// if we put `string` that is ambiguous
}
}
So what can we do? In this case, we'll use the @Inject() decorator like this:
import { Inject } from "@angular/core";
export class AnalyticsDemoComponent {
constructor(@Inject("API_URL") apiUrl: string) {
// works! do sth w/ apiUrl
}
}
Now that we know how to do simple values with useValue and Singleton classes with
useClass, we're ready to talk about the more advanced case: writing configurable
services using factories.
Dependency Injection 201
Configurable Services
In the case of the UserService, no arguments are required for the constructor. But
what happens if a service's constructor requires arguments? We can implement this
by using a factory which is a function that can return any object when injected.
Np. let's say we're writing a library for recording user analytics (that is,
keeping a record of events of actions a user took on the page). In this scenario, we
want to have an AnalyticsService with a catch: the AnalyticsService should define
the interface for recording events, but not the implementation for handling the
event.
Tracking Analytics on the events
Our user may, Np. want to record these metrics with Google Analytics or
they may want to use Optimizely, or some other in-house solution. Let's write an
injectable AnalyticsService which can take an implementation configuration.
Dependency Injection 202
First, a couple of definitions. Let's define a Metric:
code/dependency-injection/src/app/analytics-demo/analytics-demo.interface.ts
4 export interface Metric {
5 eventName: string;
6 scope: string;
7 }
A Metric will store an eventName and a scope. We could use this for say, when a the
user nate logs-in the eventName could be loggedIn and the scope would be nate.
// just an example
let metric: Metric = {
eventName: "loggedIn",
scope: "nate"
};
This way we could, in theory, count the number of user logins by counting the events
with eventName loggedIn and count the number of times the specific user nate logged
in by counting the loggedIn events with user nate.
We also need to define what an analytics implementation would look like:
code/dependency-injection/src/app/analytics-demo/analytics-demo.interface.ts
12 export interface AnalyticsImplementation {
13 recordEvent(metric: Metric): void;
14 }
Here we define an AnalyticsImplementation interface to have one function: recordEvent
which takes a Metric as an argument.
Now let's define the AnalyticsService:
Dependency Injection 203
code/dependency-injection/src/app/services/analytics.service.ts
1 import { Injectable } from '@angular/core';
2 import {
3 Metric,
4 AnalyticsImplementation
5 } from '../analytics-demo/analytics-demo.interface';
6
7 @Injectable()
8 export class AnalyticsService {
9 constructor(private implementation: AnalyticsImplementation) {
10 }
11
12 record(metric: Metric): void {
13 this.implementation.recordEvent(metric);
14 }
15 }
Above our AnalyticsService defines one method: record which accepts a Metric
and then passes it on to the implementation.
Of course, this AnalyticsService is a bit trivial and in this case, we probably
wouldn't need the indirection. But this same pattern could be used in
the case where you had a more advanced AnalyticsService. Np.
we could add middleware or broadcast to several implementations.
Notice how its constructor method takes a phrase as a parameter? If we try to use
the "regular" useClass injection mechanism we would see an error on the browser
like:
Cannot resolve all parameters for AnalyticsService.
This happens because we didn't provide the injector with the implementation
necessary for the constructor. In order to resolve this problem, we need to configure
the provider to use a factory.
Dependency Injection 204
Using a Factory
So to use our AnalyticsService, we need to:
• create an implementation that conforms to AnalyticsImplementation and
• add it to providers with useFactory
Here's how:
code/dependency-injection/src/app/analytics-demo/analytics-demo.module.1.ts
1 import { NgModule } from '@angular/core';
2 import { CommonModule } from '@angular/common';
3 import {
4 Metric,
5 AnalyticsImplementation
6 } from './analytics-demo.interface';
7 import { AnalyticsService } from '../services/analytics.service';
8
9 @NgModule({
10 imports: [
11 CommonModule
12 ],
13 providers: [
14 {
15 // `AnalyticsService` is the _token_ we use to inject
16 // note, the token is the class, but it's just used as an identifier!
17 provide: AnalyticsService,
18
19 // useFactory is a function - whatever is returned from this function
20 // will be injected
21 useFactory() {
22
23 // create an implementation that will log the event
24 const loggingImplementation: AnalyticsImplementation = {
25 recordEvent: (metric: Metric): void => {
26 console.log('The metric is:', metric);
27 }
28 };
29
30 // create our new `AnalyticsService` with the implementation
31 return new AnalyticsService(loggingImplementation);
32 }
Dependency Injection 205
33 }
34 ],
35 declarations: [ ]
36 })
37 export class AnalyticsDemoModule { }
Here in providers we're using the syntax:
providers: [
{ provide: AnalyticsService, useFactory: () => ... }
]
useFactory takes a function and whatever this function returns will be injected.
Also note that we provide AnalyticsService. Again, when we use provide this way,
we're using the class AnalyticsService as the identifying token of what we're going
to inject. (If you wanted to be confusing, you could use a completely separate class,
or less-confusingly a string.)
In useFactory we're creating an AnalyticsImplementation object that has one
function: recordEvent. recordEvent is where we could, in theory, configure what
happens when an event is recorded. Again, in a real app this would probably send
an event to Google Analytics or a custom event logging software.
Lastly, we instantiate our AnalyticsService and return it.
Factory Dependencies
Using a factory is the most powerful way to create injectables, because we can do
whatever we want within the factory function. Sometimes our factory function will
have dependencies of it's own.
Say that we wanted to configure our AnalyticsImplementation to make an HTTP
request to a particular URL. In order to do this we'd need:
• The Angular HttpClient client and
• Our API_URL value
Here's how we could set that up:
Dependency Injection 206
code/dependency-injection/src/app/analytics-demo/analytics-demo.module.ts
1 import { NgModule } from "@angular/core";
2 import { CommonModule } from "@angular/common";
3 import { Metric, AnalyticsImplementation } from "./analytics-demo.interface";
4 import { AnalyticsService } from "../services/analytics.service";
5
6 // added this ->
7 import { HttpClientModule, HttpClient } from "@angular/common/http";
8
9 @NgModule({
10 imports: [
11 CommonModule,
12 HttpClientModule // <-- added
13 ],
14 providers: [
15 // add our API_URL provider
16 { provide: "API_URL", useValue: "http://devserver.com" },
17 {
18 provide: AnalyticsService,
19
20 // add our `deps` to specify the factory depencies
21 deps: [HttpClient, "API_URL"],
22
23 // notice we've added arguments here
24 // the order matches the deps order
25 useFactory(http: HttpClient, apiUrl: string) {
26 // create an implementation that will log the event
27 const loggingImplementation: AnalyticsImplementation = {
28 recordEvent: (metric: Metric): void => {
29 console.log("The metric is:", metric);
30 console.log("Sending to: ", apiUrl);
31 // ... You'd send the metric using http here ...
32 }
33 };
34
35 // create our new `AnalyticsService` with the implementation
36 return new AnalyticsService(loggingImplementation);
37 }
38 }
39 ],
40 declarations: []
41 })
42 export class AnalyticsDemoModule {}
Dependency Injection 207
Here we're importing the HttpClientModule, both in the ES6 import (which makes
the class constants available) and in our NgModule imports (which makes it available
for dependency injection).
We've added an API_URL provider, as we did above. And then in our AnalyticsService
provider, we've added a new key: deps. deps is an array of injection tokens and
these tokens will be resolved and passed as arguments to the factory function.
Dependency Injection in Apps
To review, when writing our apps there are three steps we need to take in order to
perform an injection:
1. Create the dependency (e.g. the service class)
2. Configure the injection (i.e. register the injection with Angular in our NgModule)
3. Declare the dependencies on the receiving component
The 1st thing we do is create the service class, that is, the class that exposes some
behavior we want to use. This will be called the injectable because it is the thing that
our components will receive via the injection.
Reminder on terminology: a provider provides (creates, instantiates, etc.) the injectable
(the thing you want). In Angular when you want to access an injectable you
inject a dependency into a function (often a constructor) and Angular's dependency
injection framework will locate it and provide it to you.
As we can see, Dependency Injection provides a powerful way to manage dependencies
within our app.
More Resources
• Official Angular DI Docs⁴⁸
• Victor Savkin Compare DI in Angular 1 vs. Angular 2⁴⁹
⁴⁸https://angular.io/docs/ts/latest/guide/dependency-injection.html
⁴⁹http://victorsavkin.com/post/126514197956/dependency-injection-in-angular-1-and-angular-2
HTTP
Introduction
Angular comes with its own HTTP library which we can use to call out to external
APIs.
When we make calls to an external server, we want our user to continue to be able
to interact with the page. That is, we don't want our page to freeze until the HTTP
request returns from the external server. To achieve this effect, our HTTP requests
are asynchronous.
Dealing with asynchronous code is, historically, more tricky than dealing with
synchronous code. In JS, there are generally three approaches to dealing with
async code:
1. Callbacks
2. Promises
3. Observables
In Angular, the preferred method of dealing with async code is using Observables,
and so that's what we'll cover in this chapter.
There's a whole chapter on RxJS and Observables: In this chapter we're
going to be using Observables and not explaining them much. If you're just
starting to read this book at this chapter, you should know that there's a
whole chapter on Observables that goes into RxJS in more detail.
In this chapter we're going to:
1. show a basic example of HttpClient
HTTP 209
2. create a YouTube search-as-you-type component
3. discuss API details about the HttpClient library
Sample Code The complete code for the examples in this chapter can
be found in the http folder of the sample code. That folder contains a
README.md which gives instructions for building and running the project.
Try running the code while reading the chapter and feel free play around
to get a deeper insight about how it all works.
Using @angular/common/http
HTTP has been split into a separate module in Angular. This means that to use it
you need to import constants from @angular/common/http. Np. we might
import constants from @angular/common/http like this:
import {
// The NgModule for using @angular/common/http
HttpClientModule,
// the class constants
HttpClient
} from '@angular/common/http';
import from @angular/common/http
In our app.module.ts we're going to import HttpClientModule which is a convenience
collection of modules.
HTTP 210
code/http/src/app/app.module.ts
1 import { BrowserModule } from '@angular/platform-browser';
2 import { NgModule } from '@angular/core';
3 import { FormsModule } from '@angular/forms';
4 import { HttpClientModule } from '@angular/common/http';
In our NgModule we will add HttpClientModule to the list of imports. The effect
is that we will be able to inject HttpClient (and a few other modules) into our
components.
code/http/src/app/app.module.ts
14 @NgModule({
15 declarations: [
16 AppComponent,
17 SimpleHttpComponent,
18 MoreHttpRequestsComponent,
19 YouTubeSearchComponent,
20 SearchResultComponent,
21 SearchBoxComponent
22 ],
23 imports: [
24 BrowserModule,
25 FormsModule,
26 HttpClientModule // <-- right here
27 ],
28 providers: [youTubeSearchInjectables],
29 bootstrap: [AppComponent]
30 })
31 export class AppModule {}
Notice that we have custom components in declarations as well as a
custom provider. We'll talk about these later in the chapter.
Now we can inject the HttpClient service into our components (or anywhere we use
dependency injection).
HTTP 211
class MyFooComponent {
constructor(public http: HttpClient) {
}
makeRequest(): void {
// do sth with this.http ...
}
}
A Basic Request
The 1st thing we're going to do is make a simple GET request to the jsonplaceholder
API⁵⁰.
What we're going to do is:
1. Have a button that calls makeRequest
2. makeRequest will call the http library to perform a GET request on our API
3. When the request returns, we'll update this.data with the results of the data,
which will be rendered in the view.
Here's a screenshot of our example:
Basic Request
⁵⁰https://jsonplaceholder.typicode.com
HTTP 212
Building the SimpleHttpComponent Component Definition
The 1st thing we're going to do is import a few modules and then specify a selector
for our @Component:
code/http/src/app/simple-http/simple-http.component.ts
1 import { Component, OnInit } from '@angular/core';
2 import { HttpClient } from '@angular/common/http';
3
4 @Component({
5 selector: 'app-simple-http',
6 templateUrl: './simple-http.component.html'
7 })
8 export class SimpleHttpComponent implements OnInit {
9 data: Object;
10 loading: boolean;
11
12 constructor(private http: HttpClient) {}
Building the SimpleHttpComponent template
Next we build our view:
code/http/src/app/simple-http/simple-http.component.html
1 <h2>Basic Request</h2>
2 <button type="button" (click)="makeRequest()">Make Request</button>
3 <div *ngIf="loading">loading...</div>
4 <pre>{{data | json}}</pre>
Our template has three interesting parts:
1. The button
2. The loading indicator
3. The data
HTTP 213
On the button we bind to (click) to call the makeRequest function in our controller,
which we'll define in a minute.
We want to indicate to the user that our request is loading, so to do that we will show
loading... if the instance variable loading is true, using ngIf.
The data is an Object. A great way to debug objects is to use the json pipe as we do
here. We've put this in a pre tag to give us nice, easy to read formatting.
Building the SimpleHttpComponent Controller
We start by defining a new class for our SimpleHttpComponent:
code/http/src/app/simple-http/simple-http.component.ts
8 export class SimpleHttpComponent implements OnInit {
9 data: Object;
10 loading: boolean;
We have two instance variables: data and loading. This will be used for our API
return value and loading indicator respectively.
Next we define our constructor:
code/http/src/app/simple-http/simple-http.component.ts
12 constructor(private http: HttpClient) {}
The constructor body is empty, but we inject one key module: HttpClient.
Remember that when we use the public keyword in public http:
HttpClient TS will assign http to this.http. It's a shorthand for:
// other instance variables here
http: HttpClient;
constructor(http: HttpClient) {
this.http = http;
}
Now let's make our 1st HTTP request by implementing the makeRequest function:
HTTP 214
code/http/src/app/simple-http/simple-http.component.ts
16 makeRequest(): void {
17 this.loading = true;
18 this.http
19 .get('https://jsonplaceholder.typicode.com/posts/1')
20 .subscribe(data => {
21 this.data = data;
22 this.loading = false;
23 });
24 }
When we call makeRequest, the 1st thing we do is set this.loading = true. This
will turn on the loading indicator in our view.
To make an HTTP request is straightforward: we call this.http.get and pass the
URL to which we want to make a GET request.
http.get returns an Observable. We can subscribe to changes (akin to using then
from a Promise) using subscribe.
code/http/src/app/simple-http/simple-http.component.ts
18 this.http
19 .get('https://jsonplaceholder.typicode.com/posts/1')
20 .subscribe(data => {
When our http.request returns (from the server) the stream will emit a Response
object. We extract the body of the response as an Object by using json and then we
set this.data to that Object.
Since we have a response, we're not loading anymore so we set this.loading =
false
.subscribe can also handle failures and stream completion by passing a
function to the second and third arguments respectively. In a production
app it would be a good idea to handle those cases, too. That is, this.loading
should also be set to false if the request fails (i.e. the stream emits an error).
Full SimpleHttpComponent
Here's what our SimpleHttpComponent looks like altogether:
HTTP 215
code/http/src/app/simple-http/simple-http.component.ts
1 import { Component, OnInit } from '@angular/core';
2 import { HttpClient } from '@angular/common/http';
3
4 @Component({
5 selector: 'app-simple-http',
6 templateUrl: './simple-http.component.html'
7 })
8 export class SimpleHttpComponent implements OnInit {
9 data: Object;
10 loading: boolean;
11
12 constructor(private http: HttpClient) {}
13
14 ngOnInit() {}
15
16 makeRequest(): void {
17 this.loading = true;
18 this.http
19 .get('https://jsonplaceholder.typicode.com/posts/1')
20 .subscribe(data => {
21 this.data = data;
22 this.loading = false;
23 });
24 }
25 }
Writing a YouTubeSearchComponent
The last example was a minimal way to get the data from an API server into your
code. Now let's try to build a more involved example.
In this section, we're going to build a way to search YouTube as you type. When the
search returns we'll show a list of video thumbnail results, along with a description
and link to each video.
Here's a screenshot of what happens when I search for "cats playing ipads":
HTTP 216
Can I get my cat to write Angular?
For this example we're going to write several things:
1. A SearchResult object that will hold the data we want from each result
2. A YouTubeSearchService which will manage the API request to YouTube and
convert the results to a stream of SearchResult[]
3. A SearchBoxComponent which will call out to the YouTube service as the user
types
4. A SearchResultComponent which will render a specific SearchResult
5. A YouTubeSearchComponent which will encapsulate our whole YouTube searching
app and render the list of results
HTTP 217
Let's handle each part one at a time.
Patrick Stapleton has an excellent repository named angular2-webpackstarter⁵
¹. This repo has an RxJS example which autocompletes Github
repositories. Some of the ideas in this section are inspired from that
example. It's a fantastic project with lots of examples and you should check
it out.
Writing a SearchResult
First let's start with writing a basic SearchResult class. This class is just a convenient
way to store the specific fields we're interested in from our search results.
code/http/src/app/you-tube-search/search-result.model.ts
1 /**
2 * SearchResult is a data-structure that holds an individual
3 * record from a YouTube video search
4 */
5 export class SearchResult {
6 id: string;
7 title: string;
8 description: string;
9 thumbnailUrl: string;
10 videoUrl: string;
11
12 constructor(obj?: any) {
13 this.id = obj && obj.id || null;
14 this.title = obj && obj.title || null;
15 this.description = obj && obj.description || null;
16 this.thumbnailUrl = obj && obj.thumbnailUrl || null;
17 this.videoUrl = obj && obj.videoUrl ||
18 `https://www.youtube.com/watch?v=${this.id}`;
19 }
20 }
This pattern of taking an obj?: any lets us simulate keyword arguments. The idea
is that we can create a new SearchResult and just pass in an object containing the
keys we want to specify.
⁵¹https://github.com/angular-class/angular2-webpack-starter
HTTP 218
The only thing to point out here is that we're constructing the videoUrl using a hardcoded
URL format. You're welcome to change this to a function which takes more
arguments, or use the video id directly in your view to build this URL if you need
to.
Writing the YouTubeSearchService
The API
For this example we're going to be using the YouTube v3 search API⁵².
In order to use this API you need to have an API key. I've included an API
key in the sample code which you can use. However, by the time you read
this, you may find it's over the rate limits. If that happens, you'll need to
issue your own key.
To issue your own key see this documentation⁵³. For the sake of simplicity,
I've registered a server key, but you should probably use a browser key if
you're going to put your JS code online.
We're going to setup two constants for our YouTubeSearchService mapping to our
API key and the API URL:
let YOUTUBE_API_KEY: string = "XXX_YOUR_KEY_HERE_XXX";
let YOUTUBE_API_URL: string = "https://www.googleapis.com/youtube/v3/search";
Eventually we're going to want to test our app. One of the things we find when
testing is that we don't always want to test against production - we often want to
test against staging or a development API.
To help with this environment configuration, one of the things we can do is make
these constants injectable.
Why should we inject these constants instead of just using them in the normal way?
Because if we make them injectable we can
⁵²https://developers.google.com/youtube/v3/docs/search/list
⁵³https://developers.google.com/youtube/registering_an_application#Create_API_Keys
HTTP 219
1. have code that injects the right constants for a given environment at deploy
time and
2. replace the injected value easily at test-time
By injecting these values, we have a lot more flexibility about their values down the
line.
In order to make these values injectable, we use the { provide: ... , useValue:
... } syntax like this:
code/http/src/app/you-tube-search/you-tube-search.injectables.ts
1 import {
2 YouTubeSearchService,
3 YOUTUBE_API_KEY,
4 YOUTUBE_API_URL
5 } from './you-tube-search.service';
6
7 export const youTubeSearchInjectables: Array<any> = [
8 {provide: YouTubeSearchService, useClass: YouTubeSearchService},
9 {provide: YOUTUBE_API_KEY, useValue: YOUTUBE_API_KEY},
10 {provide: YOUTUBE_API_URL, useValue: YOUTUBE_API_URL}
11 ];
Here we're specifying that we want to bind YOUTUBE_API_KEY "injectably" to the
value of YOUTUBE_API_KEY. (Same for YOUTUBE_API_URL and we'll define YouTube-
SearchService in a minute.)
To get a refresher on the different ways to create 'injectables', checkout the
chapter on dependency injection
If you recall, to make sth available to be injected throughout our application,
we need to put it in providers for our NgModule. Since we're exporting youTubeServiceInjectables
here we can use it in our app.module.ts
HTTP 220
// http/app.ts
import { HttpClientModule } from '@angular/common/http';
import { youTubeServiceInjectables } from "components/YouTubeSearchComponent";
// ...
// further down
// ...
@NgModule({
declarations: [
HttpApp,
// others ....
],
imports: [ BrowserModule, HttpClientModule ],
bootstrap: [ HttpApp ],
providers: [
youTubeServiceInjectables // <--- right here
]
})
class HttpAppModule {}
Now we can inject YOUTUBE_API_KEY (from the youTubeServiceInjectables) instead
of using the variable directly.
YouTubeSearchService constructor
We create our YouTubeSearchService by making a service class:
code/http/src/app/you-tube-search/you-tube-search.service.ts
26 /**
27 * YouTubeService connects to the YouTube API
28 * See: * https://developers.google.com/youtube/v3/docs/search/list
29 */
30 @Injectable()
31 export class YouTubeSearchService {
32 constructor(
33 private http: HttpClient,
34 @Inject(YOUTUBE_API_KEY) private apiKey: string,
35 @Inject(YOUTUBE_API_URL) private apiUrl: string
36 ) {}
HTTP 221
The @Injectable annotation allows us to inject things into this classes
constructor.
In the constructor we inject three things:
1. HttpClient
2. YOUTUBE_API_KEY
3. YOUTUBE_API_URL
Notice that we make instance variables from all three arguments, meaning we can
access them as this.http, this.apiKey and this.apiUrl respectively.
Notice that we explicitly inject using the @Inject(YOUTUBE_API_KEY) notation.
YouTubeSearchService search
Next let's implement the search function. search takes a query string and returns an
Observable which will emit a stream of SearchResult[]. That is, each item emitted
is an array of SearchResults.
code/http/src/app/you-tube-search/you-tube-search.service.ts
38 search(query: string): Observable<SearchResult[]> {
39 const params: string = [
40 `q=${query}`,
41 `key=${this.apiKey}`,
42 `part=snippet`,
43 `type=video`,
44 `maxResults=10`
45 ].join('&');
46 const queryUrl = `${this.apiUrl}?${params}`;
We're building the queryUrl in a manual way here. We start by simply putting the
query params in the params variable. (You can find the meaning of each of those
values by reading the search API docs⁵⁴.)
Then we build the queryUrl by concatenating the apiUrl and the params.
⁵⁴https://developers.google.com/youtube/v3/docs/search/list
HTTP 222
Now that we have a queryUrl we can make our request. In this case we are going to
use http.get, although HttpClient can make any kind of request (POST, DELETE,
GET, etc.):
code/http/src/app/you-tube-search/you-tube-search.service.ts
38 search(query: string): Observable<SearchResult[]> {
39 const params: string = [
40 `q=${query}`,
41 `key=${this.apiKey}`,
42 `part=snippet`,
43 `type=video`,
44 `maxResults=10`
45 ].join('&');
46 const queryUrl = `${this.apiUrl}?${params}`;
47 return this.http.get(queryUrl).map(response => {
48 return <any>response['items'].map(item => {
49 // console.log("raw item", item); // uncomment if you want to debug
50 return new SearchResult({
51 id: item.id.videoId,
52 title: item.snippet.title,
53 description: item.snippet.description,
54 thumbnailUrl: item.snippet.thumbnails.high.url
55 });
56 });
57 });
58 }
Here we take the return value of http.get and use map to get the Response from the
request. From that response we extract the body as an object using .json() and then
we iterate over each item and convert it to a SearchResult.
If you'd like to see what the raw item looks like, just uncomment the
console.log and inspect it in your browsers developer console.
HTTP 223
Notice that we're calling (<any>response.json()).items. What's going on
here? We're telling TS that we're not interested in doing strict type
checking.
When working with a JSON API, we don't generally have typing definitions
for the API responses and so TS won't know that the Object
returned even has an items key, so the compiler will complain.
We could call response.json()["items"] and then cast that to an Array
etc., but in this case (and in creating the SearchResult, it's just cleaner to
use an any type, at the expense of strict type checking
YouTubeSearchService Full Listing
Here's the full listing of our YouTubeSearchService.
In this chapter we are adding some style using the CSS framework
Bootstrap⁵⁵
code/http/src/app/you-tube-search/you-tube-search.service.ts
26 /**
27 * YouTubeService connects to the YouTube API
28 * See: * https://developers.google.com/youtube/v3/docs/search/list
29 */
30 @Injectable()
31 export class YouTubeSearchService {
32 constructor(
33 private http: HttpClient,
34 @Inject(YOUTUBE_API_KEY) private apiKey: string,
35 @Inject(YOUTUBE_API_URL) private apiUrl: string
36 ) {}
37
38 search(query: string): Observable<SearchResult[]> {
39 const params: string = [
40 `q=${query}`,
41 `key=${this.apiKey}`,
42 `part=snippet`,
43 `type=video`,
⁵⁵http://getbootstrap.com
HTTP 224
44 `maxResults=10`
45 ].join('&');
46 const queryUrl = `${this.apiUrl}?${params}`;
47 return this.http.get(queryUrl).map(response => {
48 return <any>response['items'].map(item => {
49 // console.log("raw item", item); // uncomment if you want to debug
50 return new SearchResult({
51 id: item.id.videoId,
52 title: item.snippet.title,
53 description: item.snippet.description,
54 thumbnailUrl: item.snippet.thumbnails.high.url
55 });
56 });
57 });
58 }
59 }
Writing the SearchBoxComponent
The SearchBoxComponent plays a key role in our app: it is the mediator between our
UI and the YouTubeSearchService.
The SearchBoxComponent will :
1. Watch for keyup on an input and submit a search to the YouTubeSearchService
2. Emit a loading event when we're loading (or not)
3. Emit a results event when we have new results
SearchBoxComponent @Component Definition
Let's define our SearchBoxComponent @Component:
HTTP 225
code/http/src/app/you-tube-search/search-box.component.ts
22 @Component({
23 selector: 'app-search-box',
24 template: `
25 <input type="text" class="form-control" placeholder="Search" autofocus>
26 `
27 })
28 export class SearchBoxComponent implements OnInit {
29 @Output() loading: EventEmitter<boolean> = new EventEmitter<boolean>();
30 @Output() results: EventEmitter<SearchResult[]> = new EventEmitter<SearchResult[]>();
31
32 constructor(private youtube: YouTubeSearchService,
33 private el: ElementRef) {
34 }
The selector we've seen many times before: this allows us to create a <app-searchbox>
tag.
The two @Outputs specify that events will be emitted from this component. That is,
we can use the (output)="callback()" syntax in our view to listen to events on this
component. Np. here's how we will use the app-search-box tag in our view
later on:
<app-search-box
(loading)="loading = $event"
(results)="updateResults($event)"
></app-search-box>
In this example, when the SearchBoxComponent emits a loading event, we will set
the variable loading in the parent context. Likewise, when the SearchBoxComponent
emits a results event, we will call the updateResults() function, with the value, in
the parent's context.
In the @Component class we're specifying the properties of the events with the
names loading and results. In this example, each event will have a corresponding
EventEmitter as an instance variable of the controller class. We'll implement that in
a few minutes.
For now, remember that @Component is like the public API for our component, so here
we're just specifying the name of the events and we'll worry about implementing
the EventEmitters later.
HTTP 226
SearchBoxComponent template Definition
Our template is straightforward. We have one input tag:
code/http/src/app/you-tube-search/search-box.component.ts
24 template: `
25 <input type="text" class="form-control" placeholder="Search" autofocus>
26 `
SearchBoxComponent Controller Definition
Our SearchBoxComponent controller is a new class:
code/http/src/app/you-tube-search/search-box.component.ts
28 export class SearchBoxComponent implements OnInit {
29 @Output() loading: EventEmitter<boolean> = new EventEmitter<boolean>();
30 @Output() results: EventEmitter<SearchResult[]> = new EventEmitter<SearchResult[]>();
We say that this class implements OnInit because we want to use the ngOnInit
lifecycle callback. If a class implements OnInit then the ngOnInit function will be
called after the 1st change detection check.
ngOnInit is a good place to do initialization (vs. the constructor) because inputs set
on a component are not available in the constructor.
Here we create the EventEmitters for both loading and the results. loading will
emit a boolean when this search is loading and results will emit an array of
SearchResults when the search is finished.
SearchBoxComponent Controller Definition constructor
Let's talk about the SearchBoxComponent constructor:
HTTP 227
code/http/src/app/you-tube-search/search-box.component.ts
32 constructor(private youtube: YouTubeSearchService,
33 private el: ElementRef) {
34 }
In our constructor we inject :
1. Our YouTubeSearchService and
2. The element el that this component is attached to. el is an object of type
ElementRef, which is an Angular wrapper around a native element.
We set both injections as instance variables.
SearchBoxComponent Controller Definition ngOnInit
On this input box we want to watch for keyup events. The thing is, if we simply did
a search after every keyup that wouldn't work very well. There are three things we
can do to improve the user experience:
1. Filter out any empty or short queries
2. "debounce" the input, that is, don't search on every character but only after the
user has stopped typing after a short amount of time
3. discard any old searches, if the user has made a new search
We could manually bind to keyup and call a function on each keyup event and then
implement filtering and debouncing from there. However, there is a better way: turn
the keyup events into an observable stream.
RxJS provides a way to listen to events on an element using Rx.Observable.fromEvent.
We can use it like so:
HTTP 228
code/http/src/app/you-tube-search/search-box.component.ts
36 ngOnInit(): void {
37 // convert the `keyup` event into an observable stream
38 Observable.fromEvent(this.el.nativeElement, 'keyup')
Notice that in fromEvent:
• the 1st argument is this.el.nativeElement (the native DOM element this
component is attached to)
• the second argument is the string 'keyup', which is the name of the event we
want to turn into a stream
We can now perform some RxJS magic over this stream to turn it into SearchResults.
Let's walk through step by step.
Given the stream of keyup events we can chain on more methods. In the next few
paragraphs we're going to chain several functions on to our stream which will
transform the stream. Then at the end we'll show the whole example together.
First, let's extract the value of the input tag:
.map((e: any) => e.target.value) // extract the value of the input
Above says, map over each keyup event, then find the event target (e.target, that is,
our input element) and extract the value of that element. This means our stream is
now a stream of strings.
Next:
.filter((text: string) => text.length > 1)
This filter means the stream will not emit any search strings for which the length
is less than one. You could set this to a higher number if you want to ignore short
searches.
HTTP 229
.debounceTime(250)
debounceTime means we will throttle requests that come in faster than 250ms. That
is, we won't search on every keystroke, but rather after the user has paused a small
amount.
.do(() => this.loading.emit(true)) // enable loading
Using do on a stream is a way to perform a function mid-stream for each event, but
it does not change anything in the stream. The idea here is that we've got our search,
it has enough characters and we've debounced, so now we're about to search, so we
turn on loading.
this.loading is an EventEmitter. We "turn on" loading by emitting true as
the next event. We emit sth on an EventEmitter by calling next. Writing
this.loading.emit(true) means, emit a true event on the loading EventEmitter.
When we listen to the loading event on this component, the $event value will now
be true (we'll look more closely at using $event below).
.map((query: string) => this.youtube.search(query))
.switch()
We use .map to call perform a search for each query that is emitted. By using switch
we're, essentially, saying "ignore all search events but the most recent". That is, if a
new search comes in, we want to use the most recent and discard the rest.
Reactive experts will note that I'm handwaving here. switch has a more
specific technical definition which you can read about in the RxJS docs
here⁵⁶.
For each query that comes in, we're going to perform a search on our YouTube-
SearchService.
Putting the chain together we have this:
⁵⁶https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/switch.md
HTTP 230
code/http/src/app/you-tube-search/search-box.component.ts
36 ngOnInit(): void {
37 // convert the `keyup` event into an observable stream
38 Observable.fromEvent(this.el.nativeElement, 'keyup')
39 .map((e: any) => e.target.value) // extract the value of the input
40 .filter((text: string) => text.length > 1) // filter out if empty
41 .debounceTime(250) // only once every 250ms
42 .do(() => this.loading.emit(true)) // enable loading
43 // search, discarding old events if new input comes in
44 .map((query: string) => this.youtube.search(query))
45 .switch()
46 // act on the return of the search
47 .subscribe(
The API of RxJS can be a little intimidating because the API surface area is large. That
said, we've implemented a sophisticated event-handling stream in very few lines of
code!
Because we are calling out to our YouTubeSearchService our stream is now a
stream of SearchResult[]. We can subscribe to this stream and perform actions
accordingly.
subscribe takes three arguments: onSuccess, onError, onCompletion.
code/http/src/app/you-tube-search/search-box.component.ts
47 .subscribe(
48 (results: SearchResult[]) => { // on sucesss
49 this.loading.emit(false);
50 this.results.emit(results);
51 },
52 (err: any) => { // on error
53 console.log(err);
54 this.loading.emit(false);
55 },
56 () => { // on completion
57 this.loading.emit(false);
58 }
59 );
60 }
The 1st argument specifies what we want to do when the stream emits a regular
event. Here we emit an event on both of our EventEmitters:
HTTP 231
1. We call this.loading.emit(false), indicating we've stopped loading
2. We call this.results.emit(results), which will emit an event containing the
list of results
The second argument specifies what should happen when the stream has an error
event. Here we set this.loading.emit(false) and log out the error.
The third argument specifies what should happen when the stream completes. Here
we also emit that we're done loading.
SearchBoxComponent: Full Listing
All together, here's the full listing of our SearchBoxComponent Component:
code/http/src/app/you-tube-search/search-box.component.ts
22 @Component({
23 selector: 'app-search-box',
24 template: `
25 <input type="text" class="form-control" placeholder="Search" autofocus>
26 `
27 })
28 export class SearchBoxComponent implements OnInit {
29 @Output() loading: EventEmitter<boolean> = new EventEmitter<boolean>();
30 @Output() results: EventEmitter<SearchResult[]> = new EventEmitter<SearchResult[]>();
31
32 constructor(private youtube: YouTubeSearchService,
33 private el: ElementRef) {
34 }
35
36 ngOnInit(): void {
37 // convert the `keyup` event into an observable stream
38 Observable.fromEvent(this.el.nativeElement, 'keyup')
39 .map((e: any) => e.target.value) // extract the value of the input
40 .filter((text: string) => text.length > 1) // filter out if empty
41 .debounceTime(250) // only once every 250ms
42 .do(() => this.loading.emit(true)) // enable loading
43 // search, discarding old events if new input comes in
44 .map((query: string) => this.youtube.search(query))
45 .switch()
46 // act on the return of the search
47 .subscribe(
48 (results: SearchResult[]) => { // on sucesss
HTTP 232
49 this.loading.emit(false);
50 this.results.emit(results);
51 },
52 (err: any) => { // on error
53 console.log(err);
54 this.loading.emit(false);
55 },
56 () => { // on completion
57 this.loading.emit(false);
58 }
59 );
60 }
61 }
Writing SearchResultComponent
Single Search Result Component
The SearchBoxComponent was fairly complicated . Let's
handle a much easier component now: the SearchResultComponent.
The SearchResultComponent's job is to
render a single SearchResult.
Given what we've already covered there aren't any
new ideas here, so let's take it all at once:
code/http/src/app/you-tube-search/search-result.component.ts
1 import {
2 Component,
3 OnInit,
4 Input
5 } from '@angular/core';
6 import { SearchResult } from './search-result.model';
7
8
9 @Component({
10 selector: 'app-search-result',
11 templateUrl: './search-result.component.html'
12 })
13 export class SearchResultComponent implements OnInit {
14 @Input() result: SearchResult;
HTTP 233
15
16 constructor() { }
17
18 ngOnInit() {
19 }
20
21 }
A few things:
The @Component takes a single input result, on which
we will put the SearchResult assigned to this component.
The template shows the title, description and thumbnail
of the video and then links to the video via a
button.
code/http/src/app/you-tube-search/search-result.
component.html
1 <div class="col-sm-6 col-md-3">
2 <div class="thumbnail">
3 <img src="{{result.thumbnailUrl}}">
4 <div class="caption">
5 <h3>{{result.title}}</h3>
6 <p>{{result.description}}</p>
7 <p><a href="{{result.videoUrl}}"
8 class="btn btn-default" role="button">
9 Watch</a></p>
10 </div>
11 </div>
12 </div>
The SearchResultComponent simply stores the SearchResult
in the instance variable result.
Writing YouTubeSearchComponent
The last component we have to implement is the YouTubeSearchComponent. This is
the component that ties everything together.
HTTP 234
YouTubeSearchComponent @Component
code/http/src/app/you-tube-search/you-tube-search.component.ts
4 @Component({
5 selector: 'app-you-tube-search',
6 templateUrl: './you-tube-search.component.html'
7 })
8 export class YouTubeSearchComponent implements OnInit {
9 results: SearchResult[];
10 loading: boolean;
Our @Component decorator is straightforward: use the selector app-you-tubesearch.
YouTubeSearchComponent Controller
Before we look at the template, let's take a look at the YouTubeSearchComponent
controller:
code/http/src/app/you-tube-search/you-tube-search.component.ts
8 export class YouTubeSearchComponent implements OnInit {
9 results: SearchResult[];
10 loading: boolean;
11
12 constructor() { }
13 ngOnInit() { }
14
15 updateResults(results: SearchResult[]): void {
16 this.results = results;
17 // console.log("results:", this.results); // uncomment to take a look
18 }
19 }
This component holds one instance variable: results which is an array of SearchResults.
We also define one function: updateResults. updateResults simply takes whatever
new SearchResult[] it's given and sets this.results to the new value.
We'll use both results and updateResults in our template.
HTTP 235
YouTubeSearchComponent template
Our view needs to do three things:
1. Show the loading indicator, if we're loading
2. Listen to events on the search-box
3. Show the search results
Next lets look at our template. Let's build some basic structure and show the loading
gif next to the header:
code/http/src/app/you-tube-search/you-tube-search.component.html
1 <div class='container'>
2 <div class="page-header">
3 <h1>YouTube Search
4 <img
5 style="float: right;"
6 *ngIf="loading"
7 src='assets/images/loading.gif' />
8 </h1>
9 </div>
We only want to show this loading image if loading is true, so we use ngIf to
implement that functionality.
Next, let's look at the markup where we use our search-box:
code/http/src/app/you-tube-search/you-tube-search.component.html
10 <div class="row">
11 <div class="input-group input-group-lg col-md-12">
12 <app-search-box
13 (loading)="loading = $event"
14 (results)="updateResults($event)"
15 ></app-search-box>
16 </div>
The interesting part here is how we bind to the loading and results outputs. Notice,
that we use the (output)="action()" syntax here.
HTTP 236
For the loading output, we run the expression loading = $event. $event will be
substituted with the value of the event that is emitted from the EventEmitter. That
is, in our SearchBoxComponent, when we call this.loading.emit(true) then $event
will be true.
Similarly, for the results output, we call the updateResults() function whenever
a new set of results are emitted. This has the effect of updating our components
results instance variable.
Lastly, we want to take the list of results in this component and render a searchresult
for each one:
code/http/src/app/you-tube-search/you-tube-search.component.html
19 <div class="row">
20 <app-search-result
21 *ngFor="let result of results"
22 [result]="result">
23 </app-search-result>
24 </div>
25 </div>
YouTubeSearchComponent Full Listing
Here's the full listing for the YouTubeSearchComponent:
code/http/src/app/you-tube-search/you-tube-search.component.ts
4 @Component({
5 selector: 'app-you-tube-search',
6 templateUrl: './you-tube-search.component.html'
7 })
8 export class YouTubeSearchComponent implements OnInit {
9 results: SearchResult[];
10 loading: boolean;
11
12 constructor() { }
13 ngOnInit() { }
14
15 updateResults(results: SearchResult[]): void {
16 this.results = results;
17 // console.log("results:", this.results); // uncomment to take a look
HTTP 237
18 }
19 }
and the template:
code/http/src/app/you-tube-search/you-tube-search.component.html
1 <div class='container'>
2 <div class="page-header">
3 <h1>YouTube Search
4 <img
5 style="float: right;"
6 *ngIf="loading"
7 src='assets/images/loading.gif' />
8 </h1>
9 </div>
10
11 <div class="row">
12 <div class="input-group input-group-lg col-md-12">
13 <app-search-box
14 (loading)="loading = $event"
15 (results)="updateResults($event)"
16 ></app-search-box>
17 </div>
18 </div>
19
20 <div class="row">
21 <app-search-result
22 *ngFor="let result of results"
23 [result]="result">
24 </app-search-result>
25 </div>
26 </div>
There we have it! A functional search-as-you-type implemented for YouTube video
search! Try running it from the code examples if you haven't already.
@angular/common/http API
Of course, all of the HTTP requests we've made so far have simply been GET requests.
It's important that we know how we can make other requests too.
HTTP 238
Making a POST request
Making POST request with @angular/common/http is very much like making a GET
request except that we have one additional parameter: a body.
jsonplaceholder API⁵⁷ also provides a convent URL for testing our POST requests, so
let's use it for a POST:
code/http/src/app/more-http-requests/more-http-requests.component.ts
20 makePost(): void {
21 this.loading = true;
22 this.http
23 .post(
24 'https://jsonplaceholder.typicode.com/posts',
25 JSON.stringify({
26 body: 'bar',
27 title: 'foo',
28 userId: 1
29 })
30 )
31 .subscribe(data => {
32 this.data = data;
33 this.loading = false;
34 });
35 }
Notice in the second argument we're taking an Object and converting it to a JSON
string using JSON.stringify.
PUT / PATCH / DELETE / HEAD
There are a few other fairly common HTTP requests and we call them in much the
same way.
• http.put and http.patch map to PUT and PATCH respectively and both take a
URL and a body
• http.delete and http.head map to DELETE and HEAD respectively and both take
a URL (no body)
⁵⁷http://jsonplaceholder.typicode.com
HTTP 239
Here's how we might make a DELETE request:
code/http/src/app/more-http-requests/more-http-requests.component.ts
37 makeDelete(): void {
38 this.loading = true;
39 this.http
40 .delete('https://jsonplaceholder.typicode.com/posts/1')
41 .subscribe(data => {
42 this.data = data;
43 this.loading = false;
44 });
45 }
Custom HTTP Headers
Let's say we want to craft a GET request that uses a special X-API-TOKEN header. We
can create a request with this header like so:
code/http/src/app/more-http-requests/more-http-requests.component.ts
47 makeHeaders(): void {
48 const headers: HttpHeaders = new HttpHeaders({
49 'X-API-TOKEN': 'ng-book'
50 });
51
52 const req = new HttpRequest(
53 'GET',
54 'https://jsonplaceholder.typicode.com/posts/1',
55 {
56 headers: headers
57 }
58 );
59
60 this.http.request(req).subscribe(data => {
61 this.data = data['body'];
62 });
63 }
HTTP 240
Summary
@angular/common/http is flexible and suitable for a wide variety of APIs.
One of the great things about @angular/common/http is that it has support for
mocking the backend which is very useful in testing. To learn about testing HTTP,
flip on over to the testing chapter.
Routing
In web development, routing means splitting the application into different areas
usually based on rules that are derived from the current URL in the browser.
Np. if we visit the / path of a website, we may be visiting the home route
of that website. Or if we visit /about we want to render the "about page" and so on.
Why Do We Need Routing?
Defining routes in our application is useful because we can:
• separate different areas of the app;
• maintain the state in the app;
• protect areas of the app based on certain rules;
Np. imagine we are writing an inventory application similar to the one we
described in previous chapters.
When we 1st visit the application, we might see a search form where we can enter
a search term and get a list of products that match that term.
After that, we might click a given product to visit that product's details page.
Because our app is client-side, it's not technically required that we change the URL
when we change "pages". But it's worth thinking about for a minute: what would be
the consequences of using the same URL for all pages?
• You wouldn't be able to refresh the page and keep your location within the app
• You wouldn't be able to bookmark a page and come back to it later
• You wouldn't be able to share the URL of that page with others
Routing 242
Or put in a positive light, routing lets us define a URL string that specifies where
within our app a user should be.
In our inventory example we could determine a series of different routes for each
activity, Np.:
The initial root URL could be represented by http://our-app/. When we visit this
page, we could be redirected to our "home" route at http://our-app/home.
When accessing the 'About Us' area, the URL could become http://our-app/about.
This way if we sent the URL http://our-app/about to another user they would see
same page.
How client-side routing works
Perhaps you've written server-side routing code before (though, it isn't necessary to
complete this chapter). Generally with server-side routing, the HTTP request comes
in and the server will render a different controller depending on the incoming URL.
Np. with Express.js⁵⁸ you might write sth like this:
var express = require('express');
var router = express.Router();
// define the about route
router.get('/about', function(req, res) {
res.send('About us');
});
Or with Ruby on Rails⁵⁹ you might have:
⁵⁸http://expressjs.com/guide/routing.html
⁵⁹http://rubyonrails.org/
Routing 243
# routes.rb
get '/about', to: 'pages#about'
# PagesController.rb
class PagesController < ActionController::Base
def about
render
end
end
The pattern varies per framework, but in both of these cases you have a server that
accepts a request and routes to a controller and the controller runs a specific action,
depending on the path and parameters.
Client-side routing is very similar in concept but different in implementation. With
client-side routing we're not necessarily making a request to the server on every
URL change. With our Angular apps, we refer to them as "Single Page Apps" (SPA)
because our server only gives us a single page and it's our JS that renders the
different pages.
So how can we have different routes in our JS code?
The beginning: using anchor tags
Client-side routing started out with a clever hack: Instead of using a normal serverside
URL for a page in our SPA, we use the anchor tag as the client-side URL.
As you may already know, anchor tags were traditionally used to link directly to
a place within the webpage and make the browser scroll all the way to where that
anchor was defined. Np. if we define an anchor tag in an HTML page:
<!-- ... lots of page content here ... -->
<a name="about"><h1>About</h1></a>
And we visited the URL http://sth/#about, the browser would jump straight
to that H1 tag that identified by the about anchor.
The clever move for client-side frameworks used for SPAs was to take the anchor
tags and use them represent the routes within the app by formatting them as paths.
Routing 244
Np. the about route for an SPA would be sth like http://sth/#/about.
This is what is known as hash-based routing.
What's neat about this trick is that it looks like a "normal" URL because we're starting
our anchor with a slash (/about).
The evolution: HTML5 client-side routing
With the introduction of HTML5, browsers acquired the ability to programmatically
create new browser history entries that change the displayed URL without the need
for a new request.
This is achieved using the history.pushState method that exposes the browser's
navigational history to JS.
So now, instead of relying on the anchor hack to navigate routes, modern frameworks
can rely on pushState to perform history manipulation without reloads.
Angular 1 Note: This way of routing already works in Angular 1, but it
needs to be explicitly enabled using $locationProvider.html5Mode(true).
In Angular, however, the HTML5 is the default mode. Later in this chapter we show
how to change from HTML5 mode to the old anchor tag mode.
There's two things you need to be aware of when using HTML5 mode
routing, though
1. Not all browsers support HTML5 mode routing, so if you need to
support older browsers you might be stuck with hash-based routing
for a while.
2. The server has to support HTML5 based routing.
It may not be immediately clear why the server has to support HTML5
based-routing, we'll talk more about why later in this chapter.
Routing 245
Writing our 1st routes
The Angular docs recommends using HTML5 mode routing⁶⁰. But due to
the challenges mentioned in the previous section we will for simplicity be
using hash based routing in our examples.
In Angular we configure routes by mapping paths to the component that will handle
them.
Let's create a small app that has multiple routes. On this sample application we will
have 3 routes:
• A main page route, using the /#/home path;
• An about page, using the /#/about path;
• A contact us page, using the /#/contact path;
And when the user visits the root path (/#/), it will redirect to the home path.
Components of Angular routing
There are three main components that we use to configure routing in Angular:
• Routes describes the routes our application supports
• RouterOutlet is a "placeholder" component that shows Angular where to put
the content of each route
• RouterLink directive is used to link to routes
Let's look at each one more closely.
Imports
In order to use the router in Angular, we import constants from the @angular/router
package:
⁶⁰https://angular.io/docs/ts/latest/guide/router.html#!#browser-url-styles
Routing 246
code/routes/routing/src/app/app.module.ts
5 import {
6 RouterModule,
7 Routes
8 } from '@angular/router';
Now we can define our router configuration.
Routes
To define routes for our application, create a Routes configuration and then use
RouterModule.forRoot(routes) to provide our application with the dependencies
necessary to use the router. 1st, let's look at the routes definitions:
code/routes/routing/src/app/app.module.ts
26 const routes: Routes = [
27 // basic routes
28 { path: '', redirectTo: 'home', pathMatch: 'full' },
29 { path: 'home', component: HomeComponent },
30 { path: 'about', component: AboutComponent },
31 { path: 'contact', component: ContactComponent },
32 { path: 'contactus', redirectTo: 'contact' },
33
34 // authentication demo
35 { path: 'login', component: LoginComponent },
36 {
37 path: 'protected',
38 component: ProtectedComponent,
39 canActivate: [ LoggedInGuard ]
40 },
41
42 // nested
43 {
44 path: 'products',
45 component: ProductsComponent,
46 children: childRoutes
47 }
48 ];
Notice a few things about the routes:
Routing 247
• path specifies the URL this route will handle
• component is what ties a given route path to a component that will handle the
route
• the optional redirectTo is used to redirect a given path to an existing route
We'll dive into the details of each route in this chapter, but at a high-level, the goal
of routes is to specify which component will handle a given path.
Redirections
When we use redirectTo on a route definition, it will tell the router that when we
visit the path of the route, we want the browser to be redirected to another route.
In our sample code above, if we visit the root path at http://localhost:4200/#/⁶¹, we'll
be redirected to the route home.
Another example is the contactus route:
code/routes/routing/src/app/app.module.ts
32 { path: 'contactus', redirectTo: 'contact' },
In this case, if we visit the URL http://localhost:4200/#/contactus⁶², we'll see that the
browser redirects to /contact.
Sample Code The complete code for the examples in this section can be
found in the routes/routing folder of the sample code. That folder contains
a README.md, which gives instructions for building and running the project.
There are many different imports required for routing and we don't list
every single one in every code example below. However we do list the
filename and line number from which almost every example is taken from.
If you're having trouble figuring out how to import a particular class, open
up the code using your editor to see the entire code listing.
Try running the code while reading this section and feel free play around
to get a deeper insight about how it all works.
⁶¹http://localhost:4200/#/
⁶²http://localhost:4200/#/contactus
Routing 248
Installing our Routes
Now that we have our Routes routes, we need to install it. To use the routes in our
app we do two things to our NgModule:
1. Import the RouterModule
2. Install the routes using RouterModule.forRoot(routes) in the imports of our
NgModule
Here's our routes configured into our NgModule for this app:
code/routes/routing/src/app/app.module.ts
26 const routes: Routes = [
27 // basic routes
28 { path: '', redirectTo: 'home', pathMatch: 'full' },
29 { path: 'home', component: HomeComponent },
30 { path: 'about', component: AboutComponent },
31 { path: 'contact', component: ContactComponent },
32 { path: 'contactus', redirectTo: 'contact' },
code/routes/routing/src/app/app.module.ts
59 imports: [
60 BrowserModule,
61 FormsModule,
62 HttpClientModule,
63 RouterModule.forRoot(routes), // <-- routes
64
65 // added this for our child module
66 ProductsModule
67 ],
RouterOutlet using <router-outlet>
When we change routes, we want to keep our outer "layout" template and only
substitute the "inner section" of the page with the route's component.
Routing 249
In order to describe to Angular where in our page we want to render the contents
for each route, we use the RouterOutlet directive.
Our component @Component has a template which specifies some div structure, a
section for Navigation and a directive called router-outlet.
The router-outlet element indicates where the contents of each route component
will be rendered.
We are are able to use the router-outlet directive in our template because
we imported the RouterModule in our NgModule.
Here's the component and template for the navigation wrapper of our app:
code/routes/routing/src/app/app.component.ts
6 @Component({
7 selector: 'app-root',
8 templateUrl: './app.component.html',
9 styleUrls: ['./app.component.css']
10 })
11 export class AppComponent {
12 constructor(private router: Router) {
13 };
14 }
and the template:
code/routes/routing/src/app/app.component.html
1 <div class="page-header">
2 <div class="container">
3 <h1>Router Sample</h1>
4 <div class="navLinks">
5 <a [routerLink]="['/home']">Home</a>
6 <a [routerLink]="['/about']">About Us</a>
7 <a [routerLink]="['/contact']">Contact Us</a>
8 |
9 <a [routerLink]="['/products']">Products</a>
10 <a [routerLink]="['/login']">Login</a>
11 <a [routerLink]="['/protected']">Protected</a>
12 </div>
Routing 250
13 </div>
14 </div>
15
16 <div id="content">
17 <div class="container">
18 <router-outlet></router-outlet>
19 </div>
20 </div>
If we look at the template above, you will note the router-outlet element right
below the navigation menu. When we visit /home, that's where HomeComponent
template will be rendered. The same happens for the other components.
RouterLink using [routerLink]
Now that we know where route templates will be rendered, how do we tell Angular
to navigate to a given route?
We might try linking to the routes directly using pure HTML:
1 <a href="/#/home">Home</a>
But if we do this, we'll notice that clicking the link triggers a page reload and that's
definitely not what we want when programming single page apps.
To solve this problem, Angular provides a solution that can be used to link to routes
with no page reload: the RouterLink directive.
This directive allows you to write links using a special syntax:
Routing 251
code/routes/routing/src/app/app.component.html
3 <h1>Router Sample</h1>
4 <div class="navLinks">
5 <a [routerLink]="['/home']">Home</a>
6 <a [routerLink]="['/about']">About Us</a>
7 <a [routerLink]="['/contact']">Contact Us</a>
8 |
We can see on the left-hand side the [routerLink] that applies the directive to the
current element (in our case a tags).
Now, on the right-hand side we have an array with the route path as the 1st element,
like "['/home']" or "['/about']" that will indicate which route to navigate to when
we click the element.
It might seem a little odd that the value of routerLink is a string with an array
containing a string ("['/home']", for example). This is because there are more things
you can provide when linking to routes, but we'll look at this into more detail when
we talk about child routes and route parameters.
For now, we're only using routes names from the root app component.
Putting it all together
So now that we have all the basic pieces, let's make them work together to transition
from one route to the other.
The 1st thing we need to write for our application is the index.html file.
Here's the full code for that:
Routing 252
code/routes/routing/src/index.html
1 <!doctype html>
2 <html>
3 <head>
4 <meta charset="utf-8">
5 <title>Routing</title>
6 <base href="/">
7
8 <meta name="viewport" content="width=device-width, initial-scale=1">
9 <link rel="icon" type="image/x-icon" href="favicon.ico">
10 </head>
11 <body>
12 <app-root>Loading...</app-root>
13 </body>
14 </html>
The code should be familiar by now, with the exception of this line:
<base href="/">
This line declares the base HTML tag. This tag is traditionally used to tell the browser
where to look for images and other resources declared using relative paths.
It turns out Angular Router also relies on this tag to determine how to construct its
routing information.
Np. if we have a route with a path of /hello and our base element declares
href="/app", the application will use /app/# as the concrete path.
Sometimes though, coders of an Angular application don't have access to the head
section of the application HTML. This is true Np. when reusing headers and
footers of a larger, pre-existing application.
Fortunately there is a workaround for this case. You can declare the application base
path programmatically, when configuring our NgModule by using the APP_BASE_HREF
provider:
Routing 253
@NgModule({
declarations: [ RoutesDemoApp ],
imports: [
BrowserModule,
RouterModule.forRoot(routes) // <-- routes
],
bootstrap: [ RoutesDemoApp ],
providers: [
{ provide: LocationStrategy, useClass: HashLocationStrategy },
{ provide: APP_BASE_HREF, useValue: '/' } // <--- this right here
]
})
Putting { provide: APP_BASE_HREF, useValue: '/' } in the providers is the equivalent
of using <base href="/"> on our application HTML header.
When deploying to production we can also set the value of the base-href
by using the --base-href command-line option
Creating the Components
Before we get to the main app component, let's create 3 simple components, one for
each of the routes.
HomeComponent
The HomeComponent will just have an h1 tag that says "Welcome!". Here's the full code
for our HomeComponent:
Routing 254
code/routes/routing/src/app/home/home.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-home',
5 templateUrl: './home.component.html',
6 styleUrls: ['./home.component.css']
7 })
8 export class HomeComponent implements OnInit {
9
10 constructor() { }
11
12 ngOnInit() {
13 }
14
15 }
And template:
code/routes/routing/src/app/home/home.component.html
1 <h1>Welcome Home!</h1>
AboutComponent
Similarly, the AboutComponent will just have a basic h1:
code/routes/routing/src/app/about/about.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-about',
5 templateUrl: './about.component.html',
6 styleUrls: ['./about.component.css']
7 })
8 export class AboutComponent implements OnInit {
9
10 constructor() { }
11
12 ngOnInit() {
Routing 255
13 }
14
15 }
And template:
code/routes/routing/src/app/about/about.component.html
1 <h1>About Us</h1>
ContactComponent
And, likewise with AboutComponent:
code/routes/routing/src/app/contact/contact.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-contact',
5 templateUrl: './contact.component.html',
6 styleUrls: ['./contact.component.css']
7 })
8 export class ContactComponent implements OnInit {
9
10 constructor() { }
11
12 ngOnInit() {
13 }
14
15 }
And template:
code/routes/routing/src/app/contact/contact.component.html
1 <h1>Contact Us</h1>
Nothing really very interesting about those components, so let's move on to the main
app.module.ts file.
Routing 256
Application Component
Now we need to create the root-level "application" component that will tie everything
together.
We start with the imports we'll need, both from the core and router bundles:
code/routes/routing/src/app/app.module.ts
1 import { BrowserModule } from '@angular/platform-browser';
2 import { NgModule } from '@angular/core';
3 import { FormsModule } from '@angular/forms';
4 import { HttpClientModule } from "@angular/common/http";
5 import {
6 RouterModule,
7 Routes
Next step is to import the three components we created above:
code/routes/routing/src/app/app.module.ts
15 import { AppComponent } from './app.component';
16 import { HomeComponent } from './home/home.component';
17 import { ContactComponent } from './contact/contact.component';
18 import { AboutComponent } from './about/about.component';
For our root component, we're going to use two router directives: RouterOutlet and
the RouterLink. Those directives, along with all other common router directives are
imported when we put RouterModule in the imports section of our NgModule.
As a recap, the RouterOutlet directive is then used to indicate where in our
template the route contents should be rendered. That's represented by the <routeroutlet></
router-outlet> snippet in our AppComponent template.
The RouterLink directive is used to create navigation links to our routes:
Routing 257
code/routes/routing/src/app/app.component.html
1 <div class="page-header">
2 <div class="container">
3 <h1>Router Sample</h1>
4 <div class="navLinks">
5 <a [routerLink]="['/home']">Home</a>
6 <a [routerLink]="['/about']">About Us</a>
7 <a [routerLink]="['/contact']">Contact Us</a>
8 |
9 <a [routerLink]="['/products']">Products</a>
10 <a [routerLink]="['/login']">Login</a>
11 <a [routerLink]="['/protected']">Protected</a>
12 </div>
13 </div>
14 </div>
15
16 <div id="content">
17 <div class="container">
18 <router-outlet></router-outlet>
19 </div>
20 </div>
Using [routerLink] will instruct Angular to take ownership of the click event and
then initiate a route switch to the right place, based on the route definition.
Configuring the Routes
Next, we declare the routes creating an array of objects that conform to the Routes
type:
Routing 258
code/routes/routing/src/app/app.module.ts
26 const routes: Routes = [
27 // basic routes
28 { path: '', redirectTo: 'home', pathMatch: 'full' },
29 { path: 'home', component: HomeComponent },
30 { path: 'about', component: AboutComponent },
31 { path: 'contact', component: ContactComponent },
32 { path: 'contactus', redirectTo: 'contact' },
code/routes/routing/src/app/app.module.ts
50 @NgModule({
51 declarations: [
52 AppComponent,
53 HomeComponent,
54 ContactComponent,
55 AboutComponent,
56 LoginComponent,
57 ProtectedComponent,
58 ],
59 imports: [
60 BrowserModule,
61 FormsModule,
62 HttpClientModule,
63 RouterModule.forRoot(routes), // <-- routes
64
65 // added this for our child module
66 ProductsModule
67 ],
68 providers: [
69 // uncomment this for "hash-bang" routing
70 // { provide: LocationStrategy, useClass: HashLocationStrategy }
71 AUTH_PROVIDERS,
72 LoggedInGuard
73 ],
74 bootstrap: [AppComponent]
75 })
76 export class AppModule { }
Notice that we put all necessary components in our declarations. If we're
going to route to a component, then it needs to be declared in some
NgModule (either this module or imported).
Routing 259
In our imports we have RouterModule.forRoot(routes). RouterModule.forRoot(routes)
is a function that will take our routes, configure the router and return a list
of dependencies like RouteRegistry, Location and several other classes that are
necessary to make routing work.
In our providers we have this:
{ provide: LocationStrategy, useClass: HashLocationStrategy }
Let's take an in depth look of what we want to achieve with this line.
Routing Strategies
The way the Angular application parses and creates paths from and to route
definitions is called location strategy.
In Angular 1 this is called routing modes instead
The default strategy is PathLocationStrategy, which is what we call HTML5
routing. While using this strategy, routes are represented by regular paths, like /home
or /contact.
We can change the location strategy used for our application by binding the
LocationStrategy class to a new, concrete strategy class.
Instead of using the default PathLocationStrategy we can also use the HashLocationStrategy.
The reason we're using the hash strategy as a default is because if we were using
HTML5 routing, our URLs would end up being regular paths (that is, not using
hash/anchor tags).
This way, the routes would work when you click a link and navigate on the client
side, let's say from /about to /contact.
Routing 260
If we were to refresh the page, instead of asking the server for the root URL, which is
what is being served, instead we'd be asking for /about or /contact. Because there's
no known page at /about the server would return a 404.
This default strategy works with hash based paths, like /#/home or /#/contact that
the server understands as being the / path. (This is also the default mode in Angular
1.)
Let's say you want to use HTML5 mode in production, how do you set this
up?
In order to use HTML5 mode routing, you have to configure your server to
redirect every "missing" route to the root URL.
Angular CLI supports this natively, but know that it doesn't necessarily
work by default on your server. In the routes/routing project you can use
HTML5 routes by simply doing ng serve
If we wanted to make our example application work with this new strategy, first
we have to import LocationStrategy and HashLocationStrategy and then add that
location strategy to the providers of our NgModule.
You could write your own strategy if you wanted to. All you need to do
is extend the LocationStrategy class and implement the methods. A good
way to start is reading the Angular source for the HashLocationStrategy
or PathLocationStrategy classes.
Running the application
You can now go into the application root folder (code/routes/routing) and run npm
start to boot the application.
When you type http://localhost:4200/⁶³ into your browser you should see the home
route rendered:
⁶³http://localhost:4200/
Routing 261
Home Route
Notice that the URL in the browser was redirected to http://localhost:4200/home⁶⁴.
Now clicking each link will render the appropriate routes:
⁶⁴http://localhost:4200/home
Routing 262
About Route
Routing 263
Contact Us Route
Route Parameters
In our apps we often want to navigate to a specific resource. Np. say we had
a news website and we had many articles. Each article may have an ID and if we
had an article with ID 3 then we might navigate to that article by visiting the URL:
/articles/3
And if we had an article with an ID of 4 we would access it at
/articles/4
and so on.
Obviously we're not going to want to write a route for each article, but instead
we want to use a variable, or route parameter. We can specify that a route takes
a parameter by putting a colon : in front of the path segment like this:
Routing 264
/route/:param
So in our example news site, we might specify our route as:
/product/:id
To add a parameter to our router configuration, we specify the route path like this:
const routes: Routes = [
{ path: 'product/:id', component: ProductComponent },
];
When we visit the route /product/123, the 123 part will be passed as the id route
parameter to our route.
But how can we retrieve the parameter for a given route? That's where we use route
parameters.
ActivatedRoute
In order to use route parameters, we need to 1st import ActivatedRoute:
1 import { ActivatedRoute } from '@angular/router';
Next, we inject the ActivatedRoute into the constructor of our component. For
example, let's say we have a Routes that specifies the following:
1 const routes: Routes = [
2 { path: 'product/:id', component: ProductComponent }
3 ];
Then when we write the ProductComponent, we add the ActivatedRoute as one of
the constructor arguments:
Routing 265
1 export class ProductComponent {
2 id: string;
3
4 constructor(private route: ActivatedRoute) {
5 route.params.subscribe(params => { this.id = params['id']; });
6 }
7 }
Notice that route.params is an observable. We can extract the value of the param into
a hard value by using .subscribe. In this case, we assign the value of params['id']
to the id instance variable on the component.
Now when we visit /product/230, our component's id attribute will receive 230.
Music Search App
Let's now work on a more complex application. We will build a music search
application that has the following features:
1. Search for tracks that match a given term
2. Show matching tracks in a grid
3. Show artist details when the artist name is clicked
4. Show album details and show a list of tracks when the album name is clicked
5. Show song details allow the user to play a preview when the song name is
clicked
Routing 266
The Search View of our Music App
The routes we will need for this application will be:
• /search - search form and results
Routing 267
• /artists/:id - artist info, represented by a Spotify ID
• /albums/:id - album info, with a list of tracks using the Spotify ID
• /tracks/:id - track info and preview, also using the Spotify ID
Sample Code The complete code for the examples in this section can be
found in the routes/music folder of the sample code. That folder contains
a README.md, which gives instructions for building and running the project.
We will use the Spotify API⁶⁵ to get information about tracks, artists and albums.
First Steps
The 1st file we need work on is app.module.ts. Let's start by importing classes we'll
use from Angular:
code/routes/music/src/app/app.module.ts
1 import { BrowserModule } from '@angular/platform-browser';
2 import { NgModule } from '@angular/core';
3 import { FormsModule } from '@angular/forms';
4 import { HttpClientModule } from "@angular/common/http";
5 import {
6 RouterModule,
7 Routes
8 } from '@angular/router';
9 import {
10 LocationStrategy,
11 HashLocationStrategy,
12 APP_BASE_HREF
13 } from '@angular/common';
14
15 import { AppComponent } from './app.component';
16 import { AlbumComponent } from './album/album.component';
17 import { ArtistComponent } from './artist/artist.component';
Now that we have the imports there, let's think about the components we'll use for
each route.
⁶⁵https://developer.spotify.com/web-api
Routing 268
• For the Search route, we'll create a SearchComponent. This component will talk
to the Spotify API to perform the search and then display the results on a grid.
• For the Artists route, we'll create an ArtistComponent which will show the
artist's information
• For the Albums route, we'll create an AlbumComponent which will show the list
of tracks in the album
• For the Tracks route, we'll create a TrackComponent which will show the track
and let us play a preview of the song
Since this new component will need to interact with the Spotify API, it seems like
we need to build a service that uses the http module to call out to the API server.
Everything in our app depends on the data, so let's build the SpotifyService first.
The SpotifyService
You can find the full code for the final version of the SpotifyService in
the routes/music/src/app folder of the sample code.
The 1st method we'll implement is searchTrack which will search for a track, given
a search term.
One of the endpoints documented on Spotify API docs is the Search endpoint⁶⁶.
This endpoint does exactly what we want: it takes a query (using the q parameter)
and a type parameter.
Query in this case is the search term. And since we're searching for songs, we should
use type=track.
Here's what a 1st version of the service could look like:
⁶⁶https://developer.spotify.com/web-api/search-item/
Routing 269
1 class SpotifyService {
2 constructor(public http: HttpClient) {
3 }
4
5 searchTrack(query: string) {
6 let params: string = [
7 `q=${query}`,
8 `type=track`
9 ].join("&");
10 let queryURL: string = `https://api.spotify.com/v1/search?${params}`;
11 return this.http.request(queryURL)
12 }
13 }
This code performs an HTTP GET request to the URL https://api.spotify.com/v1/search⁶⁷,
passing our query as the search term and type hardcoded to track.
This http call returns an Observable. We are going one step further and using the
RxJS function map to transform the result we would get (which is an http module's
Response object) and parsing it as JSON, resulting on an object.
Any function that calls searchTrack will then have to use the Observable API to
subscribe to the response like this:
service
.searchTrack('query')
.subscribe((res: any) => console.log('Got object', res))
The SearchComponent
Now that we have a service that will perform track searches, we can start coding the
SearchComponent.
Again, we start with an import section:
⁶⁷https://api.spotify.com/v1/search
Routing 270
code/routes/music/src/app/search/search.component.ts
1 /*
2 * Angular
3 */
4
5 import {Component, OnInit} from '@angular/core';
6 import {
7 Router,
8 ActivatedRoute,
9 } from '@angular/router';
10
11 /*
12 * Services
13 */
14 import {SpotifyService} from '../spotify.service';
Here we're importing, among other things, the SpotifyService class we just created.
The goal here is to render each resulting track side by side on a card like below:
Routing 271
Music App Card
We then start coding the component. We're using search as the selector, making a
few imports and using the following template. The template is a bit long because
we're putting some reasonable styles on it using the CSS framework Bootstrap⁶⁸, but
it isn't particularly complicated, relative to what we've done so far:
⁶⁸http://getbootstrap.com
Routing 272
code/routes/music/src/app/search/search.component.html
1 <h1>Search</h1>
2
3 <p>
4 <input type="text" #newquery
5 [value]="query"
6 (keydown.enter)="submit(newquery.value)">
7 <button (click)="submit(newquery.value)">Search</button>
8 </p>
9
10 <div *ngIf="results">
11 <div *ngIf="!results.length">
12 No tracks were found with the term '{{ query }}'
13 </div>
14
15 <div *ngIf="results.length">
16 <h1>Results</h1>
17
18 <div class="row">
19 <div class="col-sm-6 col-md-4" *ngFor="let t of results">
20 <div class="thumbnail">
21 <div class="content">
22 <img src="{{ t.album.images[0].url }}" class="img-responsive">
23 <div class="caption">
24 <h3>
25 <a [routerLink]="['/artists', t.artists[0].id]">
26 {{ t.artists[0].name }}
27 </a>
28 </h3>
29 <br>
30 <p>
31 <a [routerLink]="['/tracks', t.id]">
32 {{ t.name }}
33 </a>
34 </p>
35 </div>
36 <div class="attribution">
37 <h4>
38 <a [routerLink]="['/albums', t.album.id]">
39 {{ t.album.name }}
40 </a>
41 </h4>
42 </div>
43 </div>
Routing 273
44 </div>
45 </div>
46 </div>
47 </div>
48 </div>
The Search Field
Let's break down the HTML template a bit.
This 1st section will have the search field:
code/routes/music/src/app/search/search.component.html
3 <p>
4 <input type="text" #newquery
5 [value]="query"
6 (keydown.enter)="submit(newquery.value)">
7 <button (click)="submit(newquery.value)">Search</button>
8 </p>
Here we have the input field and we're binding its DOM element value property to
the query property of our component.
We also give this element a template variable named #newquery. We can now access
the value of this input within our template code by using newquery.value.
The button will trigger the submit method of the component, passing the value of
the input field as a parameter.
We also want to trigger submit when the user hits "Enter" so we bind to the
keydown.enter event on the input.
Search Results and Links
The next section displays the results. We're relying on the NgFor directive to iterate
through each track from our results object:
Routing 274
code/routes/music/src/app/search/search.component.html
18 <div class="row">
19 <div class="col-sm-6 col-md-4" *ngFor="let t of results">
20 <div class="thumbnail">
For each track, we display the artist name:
code/routes/music/src/app/search/search.component.html
24 <h3>
25 <a [routerLink]="['/artists', t.artists[0].id]">
26 {{ t.artists[0].name }}
27 </a>
28 </h3>
Notice how we're using the RouterLink directive to redirect to ['/artists',
t.artists[0].id].
This is how we set route parameters for a given route. Say we have an artist with an
id abc123. When this link is clicked, the app would then navigate to /artist/abc123
(where abc123 is the :id parameter).
Further down we'll show how we can retrieve this value inside the component that
handles this route.
Now we display the track:
code/routes/music/src/app/search/search.component.html
30 <p>
31 <a [routerLink]="['/tracks', t.id]">
32 {{ t.name }}
33 </a>
34 </p>
And the album:
Routing 275
code/routes/music/src/app/search/search.component.html
38 <a [routerLink]="['/albums', t.album.id]">
39 {{ t.album.name }}
40 </a>
41 </h4>
SearchComponent Class
Let's take a look at the constructor first:
code/routes/music/src/app/search/search.component.ts
22 export class SearchComponent implements OnInit {
23 query: string;
24 results: Object;
25
26 constructor(private spotify: SpotifyService,
27 private router: Router,
28 private route: ActivatedRoute) {
29 this.route
30 .queryParams
31 .subscribe(params => { this.query = params['query'] || ''; });
32 }
Here we're declaring two properties:
• query for current search term and
• results for the search results
On the constructor we're injecting the SpotifyService (that we created above),
Router and the ActivatedRoute and making them properties of our class.
In our constructor we subscribe to the queryParams property - this lets us access
query parameters, such as the search term (params['query']).
In a URL like: http://localhost/#/search?query=cats&order=ascending, query-
Params gives us the parameters in an object. This means we could access the order
with params['order'] (in this case, ascending).
Also note that queryParams are different than route.params. Whereas route.params
match parameters in the route queryParams match parameters in the query string.
In this case, if there is no query param, we set this.query to the empty string.
Routing 276
search
In our SearchComponent we will call out to the SpotifyService and render the results.
There are two cases when we want to run a search:
We want to run a search when the user:
• enters a search query and submits the form
• navigates to this page with a given URL in the query parameters (e.g. someone
shared a link or bookmarked the page)
To perform the actual search for both cases, we create the search method:
code/routes/music/src/app/search/search.component.ts
43 search(): void {
44 console.log('this.query', this.query);
45 if (!this.query) {
46 return;
47 }
48
49 this.spotify
50 .searchTrack(this.query)
51 .subscribe((res: any) => this.renderResults(res));
52 }
The search function uses the current value of this.query to know what to search
for. Because we subscribed to the queryParams in the constructor, we can be sure that
this.query will always have the most up-to-date value.
We then subscribe to the searchTrack Observable and whenever new results are
emitted we call renderResults.
Routing 277
code/routes/music/src/app/search/search.component.ts
54 renderResults(res: any): void {
55 this.results = null;
56 if (res && res.tracks && res.tracks.items) {
57 this.results = res.tracks.items;
58 }
59 }
We declared results as a component property. Whenever its value is changed, the
view will be automatically updated by Angular.
Searching on Page Load
As we pointed out above, we want to be able to jump straight into the results if the
URL includes a search query.
To do that, we are going to implement a hook Angular router provides for us to run
whenever our component is initialized.
But isn't that what constructors are for? Well, yes and no. Yes, constructors
are used to initialize values, but if you want to write good, testable code,
you want to minimize the side effects of constructing an object. So keep in
mind that you should put your component's initialization logic always on
a hook like below.
Here's the implementation of the ngOnInit method:
code/routes/music/src/app/search/search.component.ts
34 ngOnInit(): void {
35 this.search();
36 }
To use ngOnInit we imported the OnInit class and declared that our
component implements OnInit.
As you can see, we're just performing the search here. Since the term we're searching
for comes from the URL, we're good.
Routing 278
submit
Now let's see what we do when the user submits the form.
code/routes/music/src/app/search/search.component.ts
38 submit(query: string): void {
39 this.router.navigate(['search'], { queryParams: { query: query } })
40 .then(_ => this.search() );
41 }
We're manually telling the router to navigate to the search route and providing a
query parameter, then performing the actual search.
Doing things this way gives us a great benefit: if we reload the browser, we're going
to see the same search result rendered. We can say that we're persisting the search
term on the URL.
Putting it all together
Here's the full listing for the SearchComponent class:
code/routes/music/src/app/search/search.component.ts
1 /*
2 * Angular
3 */
4
5 import {Component, OnInit} from '@angular/core';
6 import {
7 Router,
8 ActivatedRoute,
9 } from '@angular/router';
10
11 /*
12 * Services
13 */
14 import {SpotifyService} from '../spotify.service';
15 ;
16
17 @Component({
18 selector: 'app-search',
19 templateUrl: './search.component.html',
Routing 279
20 styleUrls: ['./search.component.css']
21 })
22 export class SearchComponent implements OnInit {
23 query: string;
24 results: Object;
25
26 constructor(private spotify: SpotifyService,
27 private router: Router,
28 private route: ActivatedRoute) {
29 this.route
30 .queryParams
31 .subscribe(params => { this.query = params['query'] || ''; });
32 }
33
34 ngOnInit(): void {
35 this.search();
36 }
37
38 submit(query: string): void {
39 this.router.navigate(['search'], { queryParams: { query: query } })
40 .then(_ => this.search() );
41 }
42
43 search(): void {
44 console.log('this.query', this.query);
45 if (!this.query) {
46 return;
47 }
48
49 this.spotify
50 .searchTrack(this.query)
51 .subscribe((res: any) => this.renderResults(res));
52 }
53
54 renderResults(res: any): void {
55 this.results = null;
56 if (res && res.tracks && res.tracks.items) {
57 this.results = res.tracks.items;
58 }
59 }
60 }
Routing 280
Trying the search
Now that we have completed the code for the search, let's try it out:
Routing 281
Trying out Search
Routing 282
We can click the artist, track or album links to navigate to the proper route.
TrackComponent
For the track route, we use the TrackComponent. It basically displays the track name,
the album cover image and allow the user to play a preview using an HTML5 audio
tag:
code/routes/music/src/app/track/track.component.html
1 <div *ngIf="track">
2 <h1>{{ track.name }}</h1>
3
4 <p>
5 <img src="{{ track.album.images[1].url }}">
6 </p>
7
8 <p>
9 <audio controls src="{{ track.preview_url }}"></audio>
10 </p>
11
12 <p><a href (click)="back()">Back</a></p>
13 </div>
Like we did for the search before, we're going to use the Spotify API. Let's refactor
the method searchTrack and extract two other useful methods we can reuse:
code/routes/music/src/app/spotify.service.ts
13 export class SpotifyService {
14 static BASE_URL = "https://api.spotify.com/v1";
15
16 constructor(private http: HttpClient) {}
17
18 query(URL: string, params?: Array<string>): Observable<any> {
19 let queryURL = `${SpotifyService.BASE_URL}${URL}`;
20 if (params) {
21 queryURL = `${queryURL}?${params.join("&")}`;
22 }
23 const apiKey = environment.spotifyApiKey;
24 const headers = new HttpHeaders({
25 Authorization: `Bearer ${apiKey}`
Routing 283
26 });
27 const options = {
28 headers: headers
29 };
30
31 return this.http.request("GET", queryURL, options);
32 }
33
34 search(query: string, type: string): Observable<any> {
35 return this.query(`/search`, [`q=${query}`, `type=${type}`]);
36 }
Now that we've extracted those methods into the SpotifyService, notice how much
simpler searchTrack becomes:
code/routes/music/src/app/spotify.service.ts
38 searchTrack(query: string): Observable<any> {
39 return this.search(query, "track");
40 }
Now let's create a method to allow the component we're building retrieve track
information, based in the track ID:
code/routes/music/src/app/spotify.service.ts
42 getTrack(id: string): Observable<any> {
43 return this.query(`/tracks/${id}`);
44 }
And now we can use getTrack from a new ngOnInit method on the TrackComponent:
Routing 284
code/routes/music/src/app/track/track.component.ts
28 ngOnInit(): void {
29 this.spotify
30 .getTrack(this.id)
31 .subscribe((res: any) => this.renderTrack(res));
32 }
The other components work in a similar way and use get* methods from the
SpotifyService to retrieve information about either an Artist or a Track based on
their ID.
Wrapping up music search
Now we have a pretty functional music search and preview app. Try searching for a
few of your favorite tunes and try it out!
Routing 285
It Had to Route You
Router Hooks
There are times that we may want to do some action when changing routes. A classic
example of that is authentication. Let's say we have a login route and a protected
route.
We want to only allow the app to go to the protected route if the correct username
and password were provided on the login page.
In order to do that, we need to hook into the lifecycle of the router and ask
to be notified when the protected route is being activated. We then can call an
authentication service and ask whether or not the user provided the right credentials.
In order to check if a component can be activated we add a guard class to the key
canActivate in our router configuration.
Routing 286
Let's revisit our initial application, adding login and password input fields and a
new protected route that only works if we provide a certain username and password
combination.
Sample Code The complete code for the examples in this section build
on the 1st section and can be found in the routes/routing folder of the
sample code. That folder contains a README.md, which gives instructions for
building and running the project.
AuthService
Let's create a very simple and minimal implementation of a service, responsible for
authentication and authorization of resources:
code/routes/routing/src/app/auth.service.ts
1 import { Injectable } from '@angular/core';
2
3 @Injectable()
4 export class AuthService {
5 login(user: string, password: string): boolean {
6 if (user === 'user' && password === 'password') {
7 localStorage.setItem('username', user);
8 return true;
9 }
10
11 return false;
12 }
The login method will return true if the provided user/password pair equals
'user' and 'password', respectively. Also, when it is matched, it's going to use
localStorage to save the username. This will also serve as a flag to indicate whether
or not there is an active logged user.
If you're not familiar, localStorage is an HTML5 provided key/value pair
that allows you to persist information on the browser. The API is very
simple and basically allows the setting, retrieval and deletion of items. For
more information, see the Storage interface documents on MDN⁶⁹
⁶⁹https://developer.mozilla.org/en-US/docs/Web/API/Storage
Routing 287
The logout method just clears the username value:
code/routes/routing/src/app/auth.service.ts
14 logout(): any {
15 localStorage.removeItem('username');
16 }
And the final two methods:
• getUser returns the username or null
• isLoggedIn uses getUser() to return true if we have a user
Here's the code for those methods:
code/routes/routing/src/app/auth.service.ts
18 getUser(): any {
19 return localStorage.getItem('username');
20 }
21
22 isLoggedIn(): boolean {
23 return this.getUser() !== null;
24 }
The last thing we do is export an AUTH_PROVIDERS, so it can be injected into our app:
code/routes/routing/src/app/auth.service.ts
27 export const AUTH_PROVIDERS: Array<any> = [
28 { provide: AuthService, useClass: AuthService }
29 ];
Now that we have the AuthService we can inject it in our components to log the
user in, check for the currently logged in user, log the user out, etc.
In a little bit, we'll also use it in our router to protect the ProtectedComponent. But
first, let's create the component that we use to log in.
Routing 288
LoginComponent
This component will either show a login form, for the case when there is no logged
user, or display a little banner with user information along with a logout link.
The relevant code here is the login and logout methods:
code/routes/routing/src/app/login/login.component.ts
9 export class LoginComponent {
10 message: string;
11
12 constructor(public authService: AuthService) {
13 this.message = '';
14 }
15
16 login(username: string, password: string): boolean {
17 this.message = '';
18 if (!this.authService.login(username, password)) {
19 this.message = 'Incorrect credentials.';
20 setTimeout(function() {
21 this.message = '';
22 }.bind(this), 2500);
23 }
24 return false;
25 }
26
27 logout(): boolean {
28 this.authService.logout();
29 return false;
30 }
Once our service validates the credentials, we log the user in.
The component template has two snippets that are displayed based on whether the
user is logged in or not.
The 1st is a login form, protected by *ngIf="!authService.getUser()":
Routing 289
code/routes/routing/src/app/login/login.component.html
5 </div>
6
7 <form class="form-inline" *ngIf="!authService.getUser()">
8 <div class="form-group">
9 <label for="username">User: (type <em>user</em>)</label>
10 <input class="form-control" name="username" #username>
11 </div>
12
13 <div class="form-group">
14 <label for="password">Password: (type <em>password</em>)</label>
15 <input class="form-control" type="password" name="password" #password>
16 </div>
17
18 <a class="btn btn-default" (click)="login(username.value, password.value)">
19 Submit
And the information banner, containing the logout link, protected by the inverse -
*ngIf="authService.getUser()":
code/routes/routing/src/app/login/login.component.html
23 <div class="well" *ngIf="authService.getUser()">
24 Logged in as <b>{{ authService.getUser() }}</b>
25 <a href (click)="logout()">Log out</a>
26 </div>
There's another snippet of code that is displayed when we have an authentication
error:
code/routes/routing/src/app/login/login.component.html
3 <div class="alert alert-danger" role="alert" *ngIf="message">
4 {{ message }}
5 </div>
Now that we can handle the user login, let's create a resource that we are going to
protect behind a user login.
Routing 290
ProtectedComponent and Route Guards
The ProtectedComponent
Before we can protect the component, it needs to exist. Our ProtectedComponent is
straightforward:
code/routes/routing/src/app/protected/protected.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-protected',
5 templateUrl: './protected.component.html',
6 styleUrls: ['./protected.component.css']
7 })
8 export class ProtectedComponent implements OnInit {
9
10 constructor() { }
11
12 ngOnInit() {
13 }
14
15 }
And the template will show some protected content:
code/routes/routing/src/app/protected/protected.component.html
1 <h1>Protected</h1>
2 <p>
3 Protected content
4 </p>
We want this component to only be accessible to logged in users. But how can we
do that?
The answer is to use the router hook canActivate with a guard class that implements
CanActivate.
The LoggedInGuard
We create a new file logged-in.guard.ts:
Routing 291
code/routes/routing/src/app/logged-in.guard.ts
1 /* tslint:disble max-line-length */
2 import { Injectable } from '@angular/core';
3 import {
4 CanActivate,
5 ActivatedRouteSnapshot,
6 RouterStateSnapshot
7 } from '@angular/router';
8 import { Observable } from 'rxjs/Observable';
9 import { AuthService } from './auth.service';
10
11 @Injectable()
12 export class LoggedInGuard implements CanActivate {
13 constructor(private authService: AuthService) {}
14
15 canActivate(
16 next: ActivatedRouteSnapshot,
17 state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
18 const isLoggedIn = this.authService.isLoggedIn();
19 console.log('canActivate', isLoggedIn);
20 return isLoggedIn;
21 }
22 }
Angular CLI contains a generator for creating guards. So this file could be
created with the command: ng generate guard logged-in
Our guard states that it implements the CanActivate interface. This is satisfied by
implementing a method canActive.
We inject the AuthService into this class in the constructor and save it as a private
variable authService.
In our canActivate function we check this.authService to see if the user is-
LoggedIn.
Configuring the Router
To configure the router to use this guard we need to do the following:
Routing 292
1. import the LoggedInGuard
2. Use the LoggedInGuard in a route configuration
3. Include LoggedInGuard in the list of providers (so that it can be injected)
We do all of these steps in our app.module.ts.
We import the LoggedInGuard:
code/routes/routing/src/app/app.module.ts
23 import { AUTH_PROVIDERS } from './auth.service';
24 import { LoggedInGuard } from './logged-in.guard';
We add canActivate with our guard to the protected route:
code/routes/routing/src/app/app.module.ts
26 const routes: Routes = [
27 // basic routes
28 { path: '', redirectTo: 'home', pathMatch: 'full' },
29 { path: 'home', component: HomeComponent },
30 { path: 'about', component: AboutComponent },
31 { path: 'contact', component: ContactComponent },
32 { path: 'contactus', redirectTo: 'contact' },
33
34 // authentication demo
35 { path: 'login', component: LoginComponent },
36 {
37 path: 'protected',
38 component: ProtectedComponent,
39 canActivate: [ LoggedInGuard ]
40 },
41
42 // nested
43 {
44 path: 'products',
45 component: ProductsComponent,
46 children: childRoutes
47 }
48 ];
We add LoggedInGuard to our list of providers:
Routing 293
code/routes/routing/src/app/app.module.ts
68 providers: [
69 // uncomment this for "hash-bang" routing
70 // { provide: LocationStrategy, useClass: HashLocationStrategy }
71 AUTH_PROVIDERS,
72 LoggedInGuard
73 ],
Logging in
We import the LoginComponent:
code/routes/routing/src/app/app.module.ts
19 import { LoginComponent } from './login/login.component';
And then to access it we have:
1. a route that links to the LoginComponent
2. a new link to the protected route
Now when we open the application on the browser, we can see the new login form
and the new protected link:
Routing 294
Auth App - Initial Page
If you click the Protected link, you'll see nothing happens. The same happens if you
try to manually visit http://localhost:4200/protected⁷⁰.
Now enter the string user for the user and password for the password on the form
and click Submit. You'll see that we now get the current user displayed on a banner:
⁷⁰http://localhost:4200/protected
Routing 295
Auth App - Logged In
And, sure enough, if we click the Protected link, it gets redirected and the component
is rendered:
Routing 296
Auth App - Protected Area
A Note on Security: It's important to know how client-side route protection
is working before you rely too heavily on it for security. That is, you
should consider client-side route protection a form of user-experience and
not one of security.
Ultimately all of the JS in your app that gets served to the client can
be inspected, whether the user is logged in or not.
So if you have sensitive data that needs to be protected, you must protect
it with server-side authentication. That is, require an API key (or auth
token) from the user which is validated by the server on every request for
data.
Writing a full-stack authentication system is beyond the scope of this book.
The important thing to know is that protecting routes on the client-side
doesn't necessarily keep anyone from viewing the JS pages behind
those routes.
Routing 297
Nested Routes
Nested routes is the concept of containing routes within other routes. With nested
routes we're able to encapsulate the functionality of parent routes and have that
functionality apply to the child routes.
Let's say we have a website with one area to allow users to know our team, called
Who we are? and another one for our Products.
We could think that the perfect route for Who we are? would be /about and for
products /products.
And we're happily displaying all our team and all our products when visiting these
areas.
What happens when the website grows and we now need to display individual
information about each person in our team and also for each product we sell?
In order to support scenarios like these, the router allows the user to define nested
routes.
To do that, you can have multiple, nested router-outlet. So each area of our
application can have their own child components, that also have their own routeroutlets.
Let's work on an example to clear things up.
In this example, we'll have a products section where the user will be able to view two
highlighted products by visiting a nice URL. For all the other products, the routes will
use the product ID.
Configuring Routes
We will start by describing the products route on the app.module.ts file:
Routing 298
code/routes/routing/src/app/app.module.ts
26 const routes: Routes = [
27 // basic routes
28 { path: '', redirectTo: 'home', pathMatch: 'full' },
29 { path: 'home', component: HomeComponent },
30 { path: 'about', component: AboutComponent },
31 { path: 'contact', component: ContactComponent },
32 { path: 'contactus', redirectTo: 'contact' },
33
34 // authentication demo
35 { path: 'login', component: LoginComponent },
36 {
37 path: 'protected',
38 component: ProtectedComponent,
39 canActivate: [ LoggedInGuard ]
40 },
41
42 // nested
43 {
44 path: 'products',
45 component: ProductsComponent,
46 children: childRoutes
47 }
48 ];
Notice that products has a children parameter. Where does this come from? We've
defined the childRoutes in a new module: the ProductsModule. Let's take a look:
ProductsModule
The ProductsModule will have its own route configuration:
Routing 299
code/routes/routing/src/app/products/products.module.ts
15 export const routes: Routes = [
16 { path: '', redirectTo: 'main', pathMatch: 'full' },
17 { path: 'main', component: MainComponent },
18 { path: 'more-info', component: MoreInfoComponent },
19 { path: ':id', component: ProductComponent },
20 ];
Notice here that we have an empty path on the 1st object. We do this so that when
we visit /products, we'll be redirected to the main route.
The other route we need to look at is :id. In this case, when the user visits sth
that doesn't match any other route, it will fallback to this route. Everything that is
passed after / will be extracted to a parameter of the route, called id.
Now on the component template, we'll have a link to each of those static child routes:
code/routes/routing/src/app/products/products.component.html
3 <div class="navLinks">
4 <a [routerLink]="['./main']">Main</a> |
5 <a [routerLink]="['./more-info']">More Info</a> |
You can see that the route links are all in the format ['./main'], with a preceding
./. This indicates that you want to navigate the Main route relative to the current
route context.
You could also declare the routes with the ['products', 'main'] notation. The
downside is that by doing it this way, the child route is aware of the parent route and
if you were to move this component around or reuse it, you would have to rewrite
your route links.
After the links, we'll add an input where the user will be able to enter a product id,
along with a button to navigate to it and lastly add our router-outlet:
Routing 300
code/routes/routing/src/app/products/products.component.html
1 <h2>Products</h2>
2
3 <div class="navLinks">
4 <a [routerLink]="['./main']">Main</a> |
5 <a [routerLink]="['./more-info']">More Info</a> |
6 Enter id: <input #id size="6">
7 <button (click)="goToProduct(id.value)">Go</button>
8 </div>
9
10 <div class="products-area">
11 <router-outlet></router-outlet>
12 </div>
Let's look at the ProductsComponent definition:
code/routes/routing/src/app/products/products.component.ts
1 import { Component } from '@angular/core';
2 import {
3 ActivatedRoute,
4 Router
5 } from '@angular/router';
6
7 @Component({
8 selector: 'app-products',
9 templateUrl: './products.component.html',
10 styleUrls: ['./products.component.css']
11 })
12 export class ProductsComponent {
13 constructor(private router: Router, private route: ActivatedRoute) {
14 }
15
16 goToProduct(id: string): void {
17 this.router.navigate(['./', id], {relativeTo: this.route});
18 }
19 }
First on the constructor we're declaring an instance variable for the Router, since
we're going to use that instance to navigate to the product by id.
Routing 301
When we want to go to a particular product we use the goToProduct method. In
goToProduct we call the router's navigate method and providing the route name
and an object with route parameters. In our case we're just passing the id.
Notice that we use the relative ./ path in the navigate function. In order to use this
we also pass the relativeTo object to the options, which tells the router what that
route is relative to.
Now, if we run the application we will see the main page:
Nested Routes App
If you click on the Products link, you'll be redirected to /products/main that will
render as follows:
Routing 302
Nested Routes App - Products Section
Everything below that thin grey line is being rendered using the main application's
router-outlet.
And the contents of the dotted red line is being rendered inside the ProductComponent's
router-outlet. That's how you indicate how the parent and child routes will
be rendered.
When we visit one of the product links, or if we enter an ID on the textbox and click
Go, the new content is rendered inside the ProductComponent's outlet:
Routing 303
Nested Routes App - Product By Id
It's also worth noting that the Angular router is smart enough to prioritize concrete
routes 1st (like /products/spotify) over the parameterized ones (like /products/
123). This way /products/spotify will never be handled by the more generic,
catch-all route /products/:id.
Redirecting and linking nested routes
Just to recap, if we want to go to a route named MyRoute on your top-level routing
context, you use ['myRoute']. This will only work if you're in that same top-level
context.
If you are on a child component and you try to link or redirect to ['myRoute'], it will
try to find a sibling route and error out. In this case, you need to use ['/myRoute']
with a leading slash.
In a similar way, if we are on the top-level context and we want to link or redirect to
a child route, we have to need to use multiple elements on the route definition array.
Let's say we want to visit the Show route, which is a child of the Product route. In
this case, we use ['product', 'show'] as the route definition.
Routing 304
Summary
As we can see, the new Angular router is very powerful and flexible. Now go out
and route your apps!
Data Architecture in Angular
An Overview of Data Architecture
Managing data can be one of the trickiest aspects of writing a maintainable app.
There are tons of ways to get data into your application:
• AJAX HTTP Requests
• Websockets
• Indexdb
• LocalStorage
• Service Workers
• etc.
The problem of data architecture addresses questions like:
• How can we aggregate all of these different sources into a coherent system?
• How can we avoid bugs caused by unintended side-effects?
• How can we structure the code sensibly so that it's easier to maintain and onboard
new team members?
• How can we make the app run as fast as possible when data changes?
For many years MVC was a standard pattern for architecting data in applications: the
Models contained the domain logic, the View displayed the data and the Controller
tied it all together. The problem is, we've learned that MVC doesn't translate directly
into client-side web applications very well.
There has been a renaissance in the area of data architectures and many new ideas
are being explored. Np.:
Data Architecture in Angular 306
• MVW / Two-way data binding: Model-View-Whatever is a term used⁷¹ to
describe Angular 1's default architecture. The $scope provides a two-way databinding
- the whole application shares the same data structures and a change
in one area propagates to the rest of the app.
• Flux⁷²: uses a unidirectional data flow. In Flux, Stores hold data, Views render
what's in the Store and Actions change the data in the Store. There is a bit
more ceremony to setup Flux, but the idea is that because data only flows in
one direction, it's easier to reason about.
• Observables: Observables give us streams of data. We subscribe to the streams
and then perform operations to react to changes. RxJs⁷³ is the most popular
reactive streams library for JS and it gives us powerful operators for
composing operations on streams of data.
There are a lot of variations on these ideas. Np.:
• Flux is a pattern and not an implementation. There are many
different implementations of Flux (just like there are many implementations
of MVC)
• Immutability is a common variant on all of the above data architectures.
• Falcor⁷⁴ is a powerful framework that helps bind your client-side
models to the server-side data. Falcor is often used with an Observables-
type data architecture.
Data Architecture in Angular
Angular is extremely flexible in what it allows for data architecture. A data strategy
that works for one project doesn't necessarily work for another. So Angular doesn't
prescribe a particular stack, but instead tries to make it easy to use whatever
architecture we choose (while still retaining fast performance).
⁷¹See: Model View Whatever
⁷²https://facebook.github.io/flux/
⁷³https://github.com/Reactive-Extensions/RxJS
⁷⁴http://netflix.github.io/falcor/
Data Architecture in Angular 307
The benefit of this is that you have flexibility to fit Angular into almost any situation.
The downside is that you have to make your own decisions about what's right for
your project.
Don't worry, we're not going to leave you to make this decision on your own! In the
chapters that follow, we're going to cover how to build applications using some of
these patterns.
Data Architecture with
Observables - Part 1: Services
Observables and RxJS
In Angular, we can structure our application to use Observables as the backbone
of our data architecture. Using Observables to structure our data is called Reactive
Programming.
But what are Observables and Reactive Programming anyway? Reactive Programming
is a way to work with asynchronous streams of data. Observables are the main
data structure we use to implement Reactive Programming. But I'll admit, those
terms may not be that clarifying. So we'll look at concrete examples through the
rest of this chapter that should be more enlightening.
Note: Some RxJS Knowledge Required
I want to point out this book is not primarily about Reactive Programming.
There are several other good resources that can teach you the basics of Reactive
Programming and you should read them. We've listed a few below.
Consider this chapter a tutorial on how to work with RxJS and Angular rather
than an exhaustive introduction to RxJS and Reactive Programming.
In this chapter, I'll explain in detail the RxJS concepts and APIs that we encounter.
But know that you may need to supplement the content here with other resources if
RxJS is still new to you.
Data Architecture with Observables - Part 1: Services 309
Use of Underscore.js in this chapter
Underscore.js⁷⁵ is a popular library that provides functional operators on
JS data structures such as Array and Object. We use it a bunch
in this chapter alongside RxJS. If you see the _ in code, such as _.map or
_.sortBy know that we're using the Underscore.js library. You can find the
docs for Underscore.js here⁷⁶.
Learning Reactive Programming and RxJS
If you're just learning RxJS I recommend that you read this article first:
• The introduction to Reactive Programming you've been missing⁷⁷ by Andre
Staltz
After you've become a bit more familiar with the concepts behind RxJS, here are a
few more links that can help you along the way:
• Which static operators to use to create streams?⁷⁸
• Which instance operators to use on streams?⁷⁹
• RxMarbles⁸⁰ - Interactive diagrams of the various operations on streams
Throughout this chapter I'll provide links to the API documentation of RxJS. The RxJS
docs have tons of great example code that shed light on how the different streams
and operators work.
Do I have to use RxJS to use Angular? - No, you definitely don't.
Observables are just one pattern out of many that you can use with
Angular. We talk more about other data patterns you can use here.
⁷⁵http://underscorejs.org/
⁷⁶http://underscorejs.org/
⁷⁷https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
⁷⁸https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/which-static.md
⁷⁹https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/which-instance.md
⁸⁰http://rxmarbles.com
Data Architecture with Observables - Part 1: Services 310
I want to give you fair warning: learning RxJS can be a bit mind-bending at first.
But trust me, you'll get the hang of it and it's worth it. Here's a few big ideas about
streams that you might find helpful:
1. Promises emit a single value whereas streams emit many values. - Streams
fulfill the same role in your application as promises. If you've made the jump
from callbacks to promises, you know that promises are a big improvement
in readability and data maintenance vs. callbacks. In the same way, streams
improve upon the promise pattern in that we can continuously respond to data
changes on a stream (vs. a one-time resolve from a promise)
2. Imperative code "pulls" data whereas reactive streams "push" data - In
Reactive Programming our code subscribes to be notified of changes and the
streams "push" data to these subscribers
3. RxJS is functional - If you're a fan of functional operators like map, reduce,
and filter then you'll feel right at home with RxJS because streams are, in
some sense, lists and so the powerful functional operators all apply
4. Streams are composable - Think of streams like a pipeline of operations over
your data. You can subscribe to any part of your stream and even combine them
to create new streams
Chat App Overview
In this chapter, we're going to use RxJS to build a chat app. Here's a screenshot:
Data Architecture with Observables - Part 1: Services 311
Completed Chat Application
Usually we try to show every line of code here in the book text. However,
this chat application has a lot of moving parts, so in this chapter we're not
going to have every single line of code in the text. You can find the sample
code for this chapter in the folder code/rxjs/rxjs-chat. We'll call out each
filter where you can view the context, where appropriate.
In this application we've provided a few bots you can chat with. Open up the code
and try it out:
cd code/rxjs/rxjs-chat
npm install
npm start
Now open your browser to http://localhost:4200.
Data Architecture with Observables - Part 1: Services 312
Notice a few things about this application:
• You can click on the threads to chat with another person
• The bots will send you messages back, depending on their personality
• The unread message count in the top corner stays in sync with the number of
unread messages
Let's look at an overview of how this app is constructed. We have
• 3 top-level Angular Components
• 3 models
• and 3 services
Let's look at them one at a time.
Components
The page is broken down into three top-level components:
Data Architecture with Observables - Part 1: Services 313
Chat Top-Level Components
• ChatNavBarComponent - contains the unread messages count
• ChatThreadsComponent - shows a clickable list of threads, along with the most
recent message and the conversation avatar
• ChatWindowComponent - shows the messages in the current thread with an input
box to send new messages
Models
This application also has three models:
Data Architecture with Observables - Part 1: Services 314
Chat Models
• User - stores information about a chat participant
• Message - stores an individual message
• Thread - stores a collection of Messages as well as some data about the
conversation
Services
In this app, each of our models has a corresponding service. The services are singleton
objects that play two roles:
1. Provide streams of data that our application can subscribe to
2. Provide operations to add or modify data
Np. the UsersService:
• publishes a stream that emits the current user and
• offers a setCurrentUser function which will set the current user (that is, emit
the current user from the currentUser stream)
Summary
At a high level, the application data architecture is straightforward:
• The services maintain streams which emit models (e.g. Messages)
Data Architecture with Observables - Part 1: Services 315
• The components subscribe to those streams and render according to the most
recent values
Np. the ChatThreads component listens for the most recent list of threads
from the ThreadService and the ChatWindow subscribes for the most recent list of
messages.
In the rest of this chapter, we're going to go in-depth on how we implement this using
Angular and RxJS. We'll start by implementing our models, then look at how we
create Services to manage our streams and then finally implement the Components.
Implementing the Models
Let's start with the easy stuff and take a look at the models.
User
Our User class is straightforward. We have an id, name and avatarSrc.
code/rxjs/rxjs-chat/src/app/user/user.model.ts
1 import { uuid } from '../util/uuid';
2
3 /**
4 * A User represents an agent that sends messages
5 */
6 export class User {
7 id: string;
8
9 constructor(public name: string,
10 public avatarSrc: string) {
11 this.id = uuid();
12 }
13 }
Notice above that we're using a TS shorthand in the constructor.
When we say public name: string we're telling TS that 1. we
want name to be a public property on this class and 2. assign the argument
value to that property when a new instance is created.
Data Architecture with Observables - Part 1: Services 316
Thread
Similarly, Thread is also a straightforward TS class:
code/rxjs/rxjs-chat/src/app/thread/thread.model.ts
1 import { Message } from '../message/message.model';
2 import { uuid } from '../util/uuid';
3
4 /**
5 * Thread represents a group of Users exchanging Messages
6 */
7 export class Thread {
8 id: string;
9 lastMessage: Message;
10 name: string;
11 avatarSrc: string;
12
13 constructor(id?: string,
14 name?: string,
15 avatarSrc?: string) {
16 this.id = id || uuid();
17 this.name = name;
18 this.avatarSrc = avatarSrc;
19 }
20 }
Note that we store a reference to the lastMessage in our Thread. This lets us show a
preview of the most recent message in the threads list.
Message
Message is also a simple TS class, however in this case we use a slightly
different form of constructor:
Data Architecture with Observables - Part 1: Services 317
code/rxjs/rxjs-chat/src/app/message/message.model.ts
1 import { User } from '../user/user.model';
2 import { Thread } from '../thread/thread.model';
3 import { uuid } from './../util/uuid';
4
5 /**
6 * Message represents one message being sent in a Thread
7 */
8 export class Message {
9 id: string;
10 sentAt: Date;
11 isRead: boolean;
12 author: User;
13 text: string;
14 thread: Thread;
15
16 constructor(obj?: any) {
17 this.id = obj && obj.id || uuid();
18 this.isRead = obj && obj.isRead || false;
19 this.sentAt = obj && obj.sentAt || new Date();
20 this.author = obj && obj.author || null;
21 this.text = obj && obj.text || null;
22 this.thread = obj && obj.thread || null;
23 }
24 }
The pattern you see here in the constructor allows us to simulate using keyword
arguments in the constructor. Using this pattern, we can create a new Message using
whatever data we have available and we don't have to worry about the order of the
arguments. For instance we could do this:
let msg1 = new Message();
# or this
let msg2 = new Message({
text: "Hello Nate Murray!"
})
Now that we've looked at our models, let's take a look at our 1st service: the
UsersService.
Data Architecture with Observables - Part 1: Services 318
Implementing UsersService
The point of the UsersService is to provide a place where our application can learn
about the current user and also notify the rest of the application if the current user
changes.
The 1st thing we need to do is create a TS class and add the @Injectable
decorator.
code/rxjs/rxjs-chat/src/app/user/users.service.ts
10 export class UsersService {
11 // `currentUser` contains the current user
12 currentUser: Subject<User> = new BehaviorSubject<User>(null);
13
14 public setCurrentUser(newUser: User): void {
15 this.currentUser.next(newUser);
16 }
17 }
We make a class that we will be able to use as a dependency to other components
in our application. Briefly, two benefits of dependency-injection
are:
1. we let Angular handle the lifecycle of the object and
2. it's easier to test injected components.
We talk more about @Injectable in the chapter on dependency injection,
but the result is that we can now inject other dependencies into our
constructor like so:
class UsersService {
constructor(public someOtherService: SomeOtherService) {
// do sth with `someOtherService` here
}
}
Data Architecture with Observables - Part 1: Services 319
currentUser stream
Next we setup a stream which we will use to manage our current user:
code/rxjs/rxjs-chat/src/app/user/users.service.ts
12 currentUser: Subject<User> = new BehaviorSubject<User>(null);
There's a lot going on here, so let's break it down:
• We're defining an instance variable currentUser which is a Subject stream.
• Concretely, currentUser is a BehaviorSubject which will contain User.
• However, the 1st value of this stream is null (the constructor argument).
If you haven't worked with RxJS much, then you may not know what Subject or
BehaviorSubject are. You can think of a Subject as a "read/write" stream.
Technically a Subject⁸¹ inherits from both Observable⁸² and Observer⁸³
One consequence of streams is that, because messages are published immediately,
a new subscriber risks missing the latest value of the stream. BehaviourSubject
compensates for this.
BehaviourSubject⁸⁴ has a special property in that it stores the last value. Meaning
that any subscriber to the stream will receive the latest value. This is great for us
because it means that any part of our application can subscribe to the UsersService.
currentUser stream and immediately know who the current user is.
Setting a new user
We need a way to publish a new user to the stream whenever the current user changes
(e.g. logging in).
There's two ways we can expose an API for doing this:
⁸¹https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md
⁸²https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md
⁸³https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observer.md
⁸⁴https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md
Data Architecture with Observables - Part 1: Services 320
1. Add new users to the stream directly:
The most straightforward way to update the current user is to have clients of the
UsersService simply publish a new User directly to the stream like this:
UsersService.currentUser.subscribe((newUser) => {
console.log('New User is: ', newUser.name);
})
// => New User is: originalUserName
let u = new User('Nate', 'anImgSrc');
UsersService.currentUser.next(u);
// => New User is: Nate
Note here that we use the next method on a Subject to push a new value
to the stream
The pro here is that we're able to reuse the existing API from the stream, so we're
not introducing any new code or APIs
2. Create a setCurrentUser(newUser: User) method
The other way we could update the current user is to create a helper method on the
UsersService like this:
code/rxjs/rxjs-chat/src/app/user/users.service.ts
14 public setCurrentUser(newUser: User): void {
15 this.currentUser.next(newUser);
16 }
You'll notice that we're still using the next method on the currentUser stream, so
why bother doing this?
Because there is value in decoupling the implementation of the currentUser from
the implementation of the stream. By wrapping the next in the setCurrentUser call
Data Architecture with Observables - Part 1: Services 321
we give ourselves room to change the implementation of the UsersService without
breaking our clients.
In this case, I wouldn't recommend one method very strongly over the other, but it
can make a big difference on the maintainability of larger projects.
A third option could be to have the updates expose streams of their own
(that is, a stream where we place the action of changing the current user).
We explore this pattern in the MessagesService below.
UsersService.ts
Putting it together, our UsersService looks like this:
code/rxjs/rxjs-chat/src/app/user/users.service.ts
1 import { Injectable } from '@angular/core';
2 import { Subject, BehaviorSubject } from 'rxjs';
3 import { User } from './user.model';
4
5
6 /**
7 * UserService manages our current user
8 */
9 @Injectable()
10 export class UsersService {
11 // `currentUser` contains the current user
12 currentUser: Subject<User> = new BehaviorSubject<User>(null);
13
14 public setCurrentUser(newUser: User): void {
15 this.currentUser.next(newUser);
16 }
17 }
18
19 export const userServiceInjectables: Array<any> = [
20 UsersService
21 ];
Data Architecture with Observables - Part 1: Services 322
The MessagesService
The MessagesService is the backbone of this application. In our app, all messages
flow through the MessagesService.
Our MessagesService has much more sophisticated streams compared to our UsersService.
There are five streams that make up our MessagesService: 3 "data management"
streams and 2 "action" streams.
The three data management streams are:
• newMessages - emits each new Message only once
• messages - emits an array of the current Messages
• updates - performs operations on messages
the newMessages stream
newMessages is a Subject that will publish each new Message only once.
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
14 export class MessagesService {
15 // a stream that publishes new messages only once
16 newMessages: Subject<Message> = new Subject<Message>();
If we want, we can define a helper method to add Messages to this stream:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
90 addMessage(message: Message): void {
91 this.newMessages.next(message);
92 }
It would also be helpful to have a stream that will get all of the messages from a
thread that are not from a particular user. Np. consider the Echo Bot:
Data Architecture with Observables - Part 1: Services 323
Real mature, Echo Bot
When we are implementing the Echo Bot, we don't want to enter an infinite loop
and repeat back the bot's messages to itself.
To implement this we can subscribe to the newMessages stream and filter out all
messages that are
1. part of this thread and
2. not written by the bot.
You can think of this as saying, for a given Thread I want a stream of the messages
that are "for" this User.
Data Architecture with Observables - Part 1: Services 324
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
94 messagesForThreadUser(thread: Thread, user: User): Observable<Message> {
95 return this.newMessages
96 .filter((message: Message) => {
97 // belongs to this thread
98 return (message.thread.id === thread.id) &&
99 // and isn't authored by this user
100 (message.author.id !== user.id);
101 });
102 }
messagesForThreadUser takes a Thread and a User and returns a new stream of
Messages that are filtered on that Thread and not authored by the User. That is, it
is a stream of "everyone else's" messages in this Thread.
the messages stream
Whereas newMessages emits individual Messages, the messages stream emits an
Array of the most recent Messages.
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
19 messages: Observable<Message[]>;
The type Message[] is the same as Array<Message>. Another way of writing
the same thing would be: Observable<Array<Message>>. When we define
the type of messages to be Observable<Message[]> we mean that this
stream emits an Array (of Messages), not individual Messages.
So how does messages get populated? For that we need to talk about the updates
stream and a new pattern: the Operation stream.
The Operation Stream Pattern
Here's the idea:
Data Architecture with Observables - Part 1: Services 325
• We'll maintain state in messages which will hold an Array of the most current
Messages
• We use an updates stream which is a stream of functions to apply to messages
You can think of it this way: any function that is put on the updates stream will
change the list of the current messages. A function that is put on the updates stream
should accept a list of Messages and then return a list of Messages. Let's formalize
this idea by creating an interface in code:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
9 interface IMessagesOperation extends Function {
10 (messages: Message[]): Message[];
11 }
Let's define our updates stream:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
21 // `updates` receives _operations_ to be applied to our `messages`
22 // it's a way we can perform changes on *all* messages (that are currently
23 // stored in `messages`)
24 updates: Subject<any> = new Subject<any>();
Remember, updates receives operations that will be applied to our list of messages.
But how do we make that connection? We do (in the constructor of our MessagesService)
like this:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
30 constructor() {
31 this.messages = this.updates
32 // watch the updates and accumulate operations on the messages
33 .scan((messages: Message[],
34 operation: IMessagesOperation) => {
35 return operation(messages);
36 },
37 initialMessages)
38 // make sure we can share the most recent list of messages across anyone
Data Architecture with Observables - Part 1: Services 326
This code introduces a new stream function: scan⁸⁵. If you're familiar with functional
programming, scan is a lot like reduce: it runs the function for each element in the
incoming stream and accumulates a value. What's special about scan is that it will
emit a value for each intermediate result. That is, it doesn't wait for the stream to
complete before emitting a result, which is exactly what we want.
When we call this.updates.scan, we are creating a new stream that is subscribed
to the updates stream. On each pass, we're given:
1. the messages we're accumulating and
2. the new operation to apply.
and then we return the new Message[].
Sharing the Stream
One thing to know about streams is that they aren't shareable by default. That is,
if one subscriber reads a value from a stream, it can be gone forever. In the case of
our messages, we want to 1. share the same stream among many subscribers and 2.
replay the last value for any subscribers who come "late".
To do that, we use two operators: publishReplay and refCount.
• publishReplay let's us share a subscription between multiple subscribers and
replay n number of values to future subscribers. (see publish⁸⁶ and replay⁸⁷)
• refCount⁸⁸ - makes it easier to use the return value of publish, by managing
when the observable will emit values
⁸⁵https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/scan.md
⁸⁶https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/publish.md
⁸⁷https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/replay.md
⁸⁸https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md
Data Architecture with Observables - Part 1: Services 327
Wait, so what does refCount do?
refCount can be a little tricky to understand because it relates to how one
manages "hot" and "cold" observables. We're not going to dive deep into
explaining how this works and we direct the reader to:
• RxJS docs on refCount⁸⁹
• Introduction to Rx: Hot and Cold observables⁹⁰
• RefCount Marble Diagram⁹¹
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
32 // watch the updates and accumulate operations on the messages
33 .scan((messages: Message[],
34 operation: IMessagesOperation) => {
35 return operation(messages);
36 },
37 initialMessages)
38 // make sure we can share the most recent list of messages across anyone
39 // who's interested in subscribing and cache the last known list of
40 // messages
41 .publishReplay(1)
42 .refCount();
Adding Messages to the messages Stream
Now we could add a Message to the messages stream like so:
var myMessage = new Message(/* params here... */);
updates.next( (messages: Message[]): Message[] => {
return messages.concat(myMessage);
})
⁸⁹https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md
⁹⁰http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#RefCount
⁹¹http://reactivex.io/documentation/operators/refcount.html
Data Architecture with Observables - Part 1: Services 328
Above, we're adding an operation to the updates stream. The effect is that messages
is "subscribed" to that stream and so it will apply that operation which will concat
our newMessage on to the accumulated list of messages.
It's okay if this takes a few minutes to mull over. It can feel a little foreign
if you're not used to this style of programming.
One problem with the above approach is that it's a bit verbose to use. It would be
nice to not have to write that inner function every time. We could do sth like
this:
addMessage(newMessage: Message) {
updates.next( (messages: Message[]): Message[] => {
return messages.concat(newMessage);
})
}
// somewhere else
var myMessage = new Message(/* params here... */);
MessagesService.addMessage(myMessage);
This is a little bit better, but it's not "the reactive way". In part, because this action
of creating a message isn't composable with other streams. (Also this method is
circumventing our newMessages stream. More on that later.)
A reactive way of creating a new message would be to have a stream that accepts
Messages to add to the list. Again, this can be a bit new if you're not used to thinking
this way. Here's how you'd implement it:
First we make an "action stream" called create. (The term "action stream" is only
meant to describe its role in our service. The stream itself is still a regular Subject):
Data Architecture with Observables - Part 1: Services 329
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
26 // action streams
27 create: Subject<Message> = new Subject<Message>();
Next, in our constructor we configure the create stream:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
58 this.create
59 .map( function(message: Message): IMessagesOperation {
60 return (messages: Message[]) => {
61 return messages.concat(message);
62 };
63 })
The map⁹² operator is a lot like the built-in Array.map function in JS except
that it works on streams. That is, it runs the function once for each item in the stream
and emits the return value of the function.
In this case, we're saying "for each Message we receive as input, return an IMessagesOperation
that adds this message to the list". Put another way, this stream will emit
a function which accepts the list of Messages and adds this Message to our list of
messages.
Now that we have the create stream, we still have one thing left to do: we need to
actually hook it up to the updates stream. We do that by using subscribe⁹³.
⁹²https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/select.md
⁹³https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md
Data Architecture with Observables - Part 1: Services 330
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
58 this.create
59 .map( function(message: Message): IMessagesOperation {
60 return (messages: Message[]) => {
61 return messages.concat(message);
62 };
63 })
64 .subscribe(this.updates);
What we're doing here is subscribing the updates stream to listen to the create
stream. This means that if create receives a Message it will emit an IMessagesOperation
that will be received by updates and then the Message will be added to
messages.
Here's a diagram that shows our current situation:
Creating a new message, starting with the create stream
This is great because it means we get a few things:
1. The current list of messages from messages
2. A way to process operations on the current list of messages (via updates)
3. An easy-to-use stream to put create operations on our updates stream (via
create)
Data Architecture with Observables - Part 1: Services 331
Anywhere in our code, if we want to get the most current list of messages, we
just have to go to the messages stream. But we have a problem, we still haven't
connected this flow to the newMessages stream.
It would be great if we had a way to easily connect this stream with any Message
that comes from newMessages. It turns out, it's really easy:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
66 this.newMessages
67 .subscribe(this.create);
Now our diagram looks like this:
Creating a new message, starting with the newMessages stream
Now our flow is complete! It's the best of both worlds: we're able to subscribe to the
stream of individual messages through newMessages, but if we just want the most
up-to-date list, we can subscribe to messages.
Data Architecture with Observables - Part 1: Services 332
It's worth pointing out some implications of this design: if you subscribe
to newMessages directly, you have to be careful about changes that may
happen downstream. Here are three things to consider:
First, you obviously won't get any downstream updates that are applied to
the Messages.
Second, in this case, we have mutable Message objects. So if you subscribe
to newMessages and store a reference to a Message, that Message's attributes
may change.
Third, in the case where you want to take advantage of the mutability of
our Messages you may not be able to. Consider the case where we could put
an operation on the updates queue that makes a copy of each Message and
then mutates the copy. (This is probably a better design than what we're
doing here.) In this case, you couldn't rely on any Message emitted directly
from newMessages being in its "final" state.
That said, as long as you keep these considerations in mind, you shouldn't
have too much trouble.
Our completed MessagesService
Here's what the completed MessagesService looks like:
code/rxjs/rxjs-chat/src/app/message/messages.service.ts
1 import { Injectable } from '@angular/core';
2 import { Subject, Observable } from 'rxjs';
3 import { User } from '../user/user.model';
4 import { Thread } from '../thread/thread.model';
5 import { Message } from '../message/message.model';
6
7 const initialMessages: Message[] = [];
8
9 interface IMessagesOperation extends Function {
10 (messages: Message[]): Message[];
11 }
12
13 @Injectable()
14 export class MessagesService {
15 // a stream that publishes new messages only once
Data Architecture with Observables - Part 1: Services 333
16 newMessages: Subject<Message> = new Subject<Message>();
17
18 // `messages` is a stream that emits an array of the most up to date messages
19 messages: Observable<Message[]>;
20
21 // `updates` receives _operations_ to be applied to our `messages`
22 // it's a way we can perform changes on *all* messages (that are currently
23 // stored in `messages`)
24 updates: Subject<any> = new Subject<any>();
25
26 // action streams
27 create: Subject<Message> = new Subject<Message>();
28 markThreadAsRead: Subject<any> = new Subject<any>();
29
30 constructor() {
31 this.messages = this.updates
32 // watch the updates and accumulate operations on the messages
33 .scan((messages: Message[],
34 operation: IMessagesOperation) => {
35 return operation(messages);
36 },
37 initialMessages)
38 // make sure we can share the most recent list of messages across anyone
39 // who's interested in subscribing and cache the last known list of
40 // messages
41 .publishReplay(1)
42 .refCount();
43
44 // `create` takes a Message and then puts an operation (the inner function)
45 // on the `updates` stream to add the Message to the list of messages.
46 //
47 // That is, for each item that gets added to `create` (by using `next`)
48 // this stream emits a concat operation function.
49 //
50 // Next we subscribe `this.updates` to listen to this stream, which means
51 // that it will receive each operation that is created
52 //
53 // Note that it would be perfectly acceptable to simply modify the
54 // "addMessage" function below to simply add the inner operation function to
55 // the update stream directly and get rid of this extra action stream
56 // entirely. The pros are that it is potentially clearer. The cons are that
57 // the stream is no longer composable.
58 this.create
59 .map( function(message: Message): IMessagesOperation {
Data Architecture with Observables - Part 1: Services 334
60 return (messages: Message[]) => {
61 return messages.concat(message);
62 };
63 })
64 .subscribe(this.updates);
65
66 this.newMessages
67 .subscribe(this.create);
68
69 // similarly, `markThreadAsRead` takes a Thread and then puts an operation
70 // on the `updates` stream to mark the Messages as read
71 this.markThreadAsRead
72 .map( (thread: Thread) => {
73 return (messages: Message[]) => {
74 return messages.map( (message: Message) => {
75 // note that we're manipulating `message` directly here. Mutability
76 // can be confusing and there are lots of reasons why you might want
77 // to, say, copy the Message object or some other 'immutable' here
78 if (message.thread.id === thread.id) {
79 message.isRead = true;
80 }
81 return message;
82 });
83 };
84 })
85 .subscribe(this.updates);
86
87 }
88
89 // an imperative function call to this action stream
90 addMessage(message: Message): void {
91 this.newMessages.next(message);
92 }
93
94 messagesForThreadUser(thread: Thread, user: User): Observable<Message> {
95 return this.newMessages
96 .filter((message: Message) => {
97 // belongs to this thread
98 return (message.thread.id === thread.id) &&
99 // and isn't authored by this user
100 (message.author.id !== user.id);
101 });
102 }
103 }
Data Architecture with Observables - Part 1: Services 335
104
105 export const messagesServiceInjectables: Array<any> = [
106 MessagesService
107 ];
Trying out MessagesService
If you haven't already, this would be a good time to open up the code and play around
with the MessagesService to get a feel for how it works. We've got an example you
can start with in code/rxjs/rxjs-chat/src/app/message/messages.service.spec.ts.
To run the tests in this project, open up your terminal then:
cd /path/to/code/rxjs/rxjs-chat // <-- your path will vary
npm install
npm run test
Let's start by creating a few instances of our models to use:
code/rxjs/rxjs-chat/src/app/message/messages.service.spec.ts
1 import { MessagesService } from './messages.service';
2
3 import { Message } from './message.model';
4 import { Thread } from './../thread/thread.model';
5 import { User } from './../user/user.model';
6
7 describe('MessagesService', () => {
8 it('should test', () => {
9
10 const user: User = new User('Nate', '');
11 const thread: Thread = new Thread('t1', 'Nate', '');
12 const m1: Message = new Message({
13 author: user,
14 text: 'Hi!',
15 thread: thread
16 });
17
Data Architecture with Observables - Part 1: Services 336
18 const m2: Message = new Message({
19 author: user,
20 text: 'Bye!',
21 thread: thread
22 });
Next let's subscribe to a couple of our streams:
code/rxjs/rxjs-chat/src/app/message/messages.service.spec.ts
24 const messagesService: MessagesService = new MessagesService();
25
26 // listen to each message indivdually as it comes in
27 messagesService.newMessages
28 .subscribe( (message: Message) => {
29 console.log('=> newMessages: ' + message.text);
30 });
31
32 // listen to the stream of most current messages
33 messagesService.messages
34 .subscribe( (messages: Message[]) => {
35 console.log('=> messages: ' + messages.length);
36 });
37
38 messagesService.addMessage(m1);
39 messagesService.addMessage(m2);
40
41 // => messages: 1
42 // => newMessages: Hi!
43 // => messages: 2
44 // => newMessages: Bye!
45 });
46
47
48 });
Notice that even though we subscribed to newMessages 1st and newMessages is called
directly by addMessage, our messages subscription is logged first. The reason for
this is because messages subscribed to newMessages earlier than our subscription in
this test (when MessagesService was instantiated). (You shouldn't be relying on the
ordering of independent streams in your code, but why it works this way is worth
thinking about.)
Data Architecture with Observables - Part 1: Services 337
Play around with the MessagesService and get a feel for the streams there. We're
going to be using them in the next section where we build the ThreadsService.
The ThreadsService
On our ThreadsService were going to define four streams that emit respectively:
1. A map of the current set of Threads (in threads)
2. A chronological list of Threads, newest-first (in orderedthreads)
3. The currently selected Thread (in currentThread)
4. The list of Messages for the currently selected Thread (in currentThreadMessages)
Let's walk through how to build each of these streams and we'll learn a little more
about RxJS along the way.
A map of the current set of Threads (in threads)
Let's start by defining our ThreadsService class and the instance variable that will
emit the Threads:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
1 import { Injectable } from '@angular/core';
2 import { Subject, BehaviorSubject, Observable } from 'rxjs/Rx';
3 import { Thread } from './thread.model';
4 import { Message } from '../message/message.model';
5 import { MessagesService } from '../message/messages.service';
6 import * as _ from 'lodash';
7
8 @Injectable()
9 export class ThreadsService {
10
11 // `threads` is a observable that contains the most up to date list of threads
12 threads: Observable<{ [key: string]: Thread }>;
Data Architecture with Observables - Part 1: Services 338
Notice that this stream will emit a map (an object) with the id of the Thread being
the string key and the Thread itself will be the value.
To create a stream that maintains the current list of threads, we start by attaching to
the messagesService.messages stream:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
12 threads: Observable<{ [key: string]: Thread }>;
Recall that each time a new Message is added to the steam, messages will emit an
array of the current Messages. We're going to look at each Message and we want to
return a unique list of the Threads.
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
27 this.threads = messagesService.messages
28 .map( (messages: Message[]) => {
29 const threads: {[key: string]: Thread} = {};
30 // Store the message's thread in our accumulator `threads`
31 messages.map((message: Message) => {
32 threads[message.thread.id] = threads[message.thread.id] ||
33 message.thread;
Notice above that each time we will create a new list of threads. The reason for this
is because we might delete some messages down the line (e.g. leave the conversation).
Because we're recalculating the list of threads each time, we naturally will "delete"
a thread if it has no messages.
In the threads list, we want to show a preview of the chat by using the text of the
most recent Message in that Thread.
Data Architecture with Observables - Part 1: Services 339
List of Threads with Chat Preview
In order to do that, we'll store the most recent Message for each Thread. We know
which Message is newest by comparing the sentAt times:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
34 // Cache the most recent message for each thread
35 const messagesThread: Thread = threads[message.thread.id];
36 if (!messagesThread.lastMessage ||
37 messagesThread.lastMessage.sentAt < message.sentAt) {
38 messagesThread.lastMessage = message;
39 }
40 });
41 return threads;
42 });
Putting it all together, threads looks like this:
Data Architecture with Observables - Part 1: Services 340
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
27 this.threads = messagesService.messages
28 .map( (messages: Message[]) => {
29 const threads: {[key: string]: Thread} = {};
30 // Store the message's thread in our accumulator `threads`
31 messages.map((message: Message) => {
32 threads[message.thread.id] = threads[message.thread.id] ||
33 message.thread;
34
35 // Cache the most recent message for each thread
36 const messagesThread: Thread = threads[message.thread.id];
37 if (!messagesThread.lastMessage ||
38 messagesThread.lastMessage.sentAt < message.sentAt) {
39 messagesThread.lastMessage = message;
40 }
41 });
42 return threads;
43 });
Trying out the ThreadsService
Let's try out our ThreadsService. 1st we'll create a few models to work with:
code/rxjs/rxjs-chat/src/app/thread/threads.service.spec.ts
1 import { Message } from './../message/message.model';
2 import { Thread } from './thread.model';
3 import { User } from './../user/user.model';
4
5 import { ThreadsService } from './threads.service';
6 import { MessagesService } from './../message/messages.service';
7 import * as _ from 'lodash';
8
9 describe('ThreadsService', () => {
10 it('should collect the Threads from Messages', () => {
11
12 const nate: User = new User('Nate Murray', '');
13 const felipe: User = new User('Felipe Coury', '');
14
15 const t1: Thread = new Thread('t1', 'Thread 1', '');
16 const t2: Thread = new Thread('t2', 'Thread 2', '');
17
Data Architecture with Observables - Part 1: Services 341
18 const m1: Message = new Message({
19 author: nate,
20 text: 'Hi!',
21 thread: t1
22 });
23
24 const m2: Message = new Message({
25 author: felipe,
26 text: 'Where did you get that hat?',
27 thread: t1
28 });
29
30 const m3: Message = new Message({
31 author: nate,
32 text: 'Did you bring the briefcase?',
33 thread: t2
34 });
Now let's create an instance of our services:
code/rxjs/rxjs-chat/src/app/thread/threads.service.spec.ts
36 const messagesService: MessagesService = new MessagesService();
37 const threadsService: ThreadsService = new ThreadsService(messagesService);
Notice here that we're passing messagesService as an argument to the
constructor of our ThreadsService. Normally we let the Dependency
Injection system handle this for us. But in our test, we can provide the
dependencies ourselves.
Let's subscribe to threads and log out what comes through:
Data Architecture with Observables - Part 1: Services 342
code/rxjs/rxjs-chat/src/app/thread/threads.service.spec.ts
37 const threadsService: ThreadsService = new ThreadsService(messagesService);
38
39 threadsService.threads
40 .subscribe( (threadIdx: { [key: string]: Thread }) => {
41 const threads: Thread[] = _.values(threadIdx);
42 const threadNames: string = _.map(threads, (t: Thread) => t.name)
43 .join(', ');
44 console.log(`=> threads (${threads.length}): ${threadNames} `);
45 });
46
47 messagesService.addMessage(m1);
48 messagesService.addMessage(m2);
49 messagesService.addMessage(m3);
50
51 // => threads (1): Thread 1
52 // => threads (1): Thread 1
53 // => threads (2): Thread 1, Thread 2
54
55 });
56 });
A chronological list of Threads, newest-first (in
orderedthreads)
threads gives us a map which acts as an "index" of our list of threads. But we want
the threads view to be ordered according to the most recent message.
Data Architecture with Observables - Part 1: Services 343
Time Ordered List of Threads
Let's create a new stream that returns an Array of Threads ordered by the most recent
Message time:
We'll start by defining orderedThreads as an instance property:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
14 // `orderedThreads` contains a newest-first chronological list of threads
15 orderedThreads: Observable<Thread[]>;
Next, in the constructor we'll define orderedThreads by subscribing to threads and
ordered by the most recent message:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
45 this.orderedThreads = this.threads
46 .map((threadGroups: { [key: string]: Thread }) => {
47 const threads: Thread[] = _.values(threadGroups);
48 return _.sortBy(threads, (t: Thread) => t.lastMessage.sentAt).reverse();
49 });
The currently selected Thread (in currentThread)
Our application needs to know which Thread is the currently selected thread. This
lets us know:
Data Architecture with Observables - Part 1: Services 344
1. which thread should be shown in the messages window
2. which thread should be marked as the current thread in the list of threads
The current thread is marked by a dot symbol
Let's create a BehaviorSubject that will store the currentThread:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
17 // `currentThread` contains the currently selected thread
18 currentThread: Subject<Thread> =
19 new BehaviorSubject<Thread>(new Thread());
Notice that we're issuing an empty Thread as the default value. We don't need to
configure the currentThread any further.
Setting the Current Thread
To set the current thread we can have clients either
1. submit new threads via next directly or
2. add a helper method to do it.
Let's define a helper method setCurrentThread that we can use to set the next thread:
Data Architecture with Observables - Part 1: Services 345
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
70 setCurrentThread(newThread: Thread): void {
71 this.currentThread.next(newThread);
72 }
Marking the Current Thread as Read
We want to keep track of the number of unread messages. If we switch to a new
Thread then we want to mark all of the Messages in that Thread as read. We have the
parts we need to do this:
1. The messagesService.markThreadAsRead accepts a Thread and then will mark
all Messages in that Thread as read
2. Our currentThread emits a single Thread that represents the current Thread
So all we need to do is hook them together:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
67 this.currentThread.subscribe(this.messagesService.markThreadAsRead);
The list of Messages for the currently selected Thread (in
currentThreadMessages)
Now that we have the currently selected thread, we need to make sure we can show
the list of Messages in that Thread.
Data Architecture with Observables - Part 1: Services 346
The current list of messages is for the Reverse Bot
Implementing this is a little bit more complicated than it may seem at the surface.
Say we implemented it like this:
var theCurrentThread: Thread;
this.currentThread.subscribe((thread: Thread) => {
theCurrentThread = thread;
})
this.currentThreadMessages.map(
(messages: Message[]) => {
return _.filter(messages,
(message: Message) => {
return message.thread.id == theCurrentThread.id;
})
})
What's wrong with this approach? Well, if the currentThread changes, current-
ThreadMessages won't know about it and so we'll have an outdated list of current-
ThreadMessages!
What if we reversed it and stored the current list of messages in a variable and
subscribed to the changing of currentThread? We'd have the same problem only
Data Architecture with Observables - Part 1: Services 347
this time we would know when the thread changes but not when a new message
came in.
How can we solve this problem?
It turns out, RxJS has a set of operators that we can use to combine multiple streams.
In this case we want to say "if either currentThread or messagesService.messages
changes, then we want to emit sth." For this we use the combineLatest⁹⁴
operator.
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
51 this.currentThreadMessages = this.currentThread
52 .combineLatest(messagesService.messages,
53 (currentThread: Thread, messages: Message[]) => {
When we're combining two streams one or the other will arrive 1st and there's no
guarantee that we'll have a value on both streams, so we need to check to make sure
we have what we need otherwise we'll just return an empty list.
Now that we have both the current thread and messages, we can filter out just the
messages we're interested in:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
51 this.currentThreadMessages = this.currentThread
52 .combineLatest(messagesService.messages,
53 (currentThread: Thread, messages: Message[]) => {
54 if (currentThread && messages.length > 0) {
55 return _.chain(messages)
56 .filter((message: Message) =>
57 (message.thread.id === currentThread.id))
One other detail, since we're already looking at the messages for the current thread,
this is a convenient area to mark these messages as read.
⁹⁴https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/combinelatestproto.md
Data Architecture with Observables - Part 1: Services 348
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
55 return _.chain(messages)
56 .filter((message: Message) =>
57 (message.thread.id === currentThread.id))
58 .map((message: Message) => {
59 message.isRead = true;
60 return message; })
61 .value();
Whether or not we should be marking messages as read here is debatable.
The biggest drawback is that we're mutating objects in what is, essentially,
a "read" thread. i.e. this is a read operation with a side effect, which is generally
a Bad Idea. That said, in this application the currentThreadMessages
only applies to the currentThread and the currentThread should always
have its messages marked as read. That said, the "read with side-effects" is
not a pattern I recommend in general.
Putting it together, here's what currentThreadMessages looks like:
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
51 this.currentThreadMessages = this.currentThread
52 .combineLatest(messagesService.messages,
53 (currentThread: Thread, messages: Message[]) => {
54 if (currentThread && messages.length > 0) {
55 return _.chain(messages)
56 .filter((message: Message) =>
57 (message.thread.id === currentThread.id))
58 .map((message: Message) => {
59 message.isRead = true;
60 return message; })
61 .value();
62 } else {
63 return [];
64 }
65 });
Our Completed ThreadsService
Here's what our ThreadsService looks like:
Data Architecture with Observables - Part 1: Services 349
code/rxjs/rxjs-chat/src/app/thread/threads.service.ts
1 import { Injectable } from '@angular/core';
2 import { Subject, BehaviorSubject, Observable } from 'rxjs/Rx';
3 import { Thread } from './thread.model';
4 import { Message } from '../message/message.model';
5 import { MessagesService } from '../message/messages.service';
6 import * as _ from 'lodash';
7
8 @Injectable()
9 export class ThreadsService {
10
11 // `threads` is a observable that contains the most up to date list of threads
12 threads: Observable<{ [key: string]: Thread }>;
13
14 // `orderedThreads` contains a newest-first chronological list of threads
15 orderedThreads: Observable<Thread[]>;
16
17 // `currentThread` contains the currently selected thread
18 currentThread: Subject<Thread> =
19 new BehaviorSubject<Thread>(new Thread());
20
21 // `currentThreadMessages` contains the set of messages for the currently
22 // selected thread
23 currentThreadMessages: Observable<Message[]>;
24
25 constructor(public messagesService: MessagesService) {
26
27 this.threads = messagesService.messages
28 .map( (messages: Message[]) => {
29 const threads: {[key: string]: Thread} = {};
30 // Store the message's thread in our accumulator `threads`
31 messages.map((message: Message) => {
32 threads[message.thread.id] = threads[message.thread.id] ||
33 message.thread;
34
35 // Cache the most recent message for each thread
36 const messagesThread: Thread = threads[message.thread.id];
37 if (!messagesThread.lastMessage ||
38 messagesThread.lastMessage.sentAt < message.sentAt) {
39 messagesThread.lastMessage = message;
40 }
41 });
42 return threads;
43 });
Data Architecture with Observables - Part 1: Services 350
44
45 this.orderedThreads = this.threads
46 .map((threadGroups: { [key: string]: Thread }) => {
47 const threads: Thread[] = _.values(threadGroups);
48 return _.sortBy(threads, (t: Thread) => t.lastMessage.sentAt).reverse();
49 });
50
51 this.currentThreadMessages = this.currentThread
52 .combineLatest(messagesService.messages,
53 (currentThread: Thread, messages: Message[]) => {
54 if (currentThread && messages.length > 0) {
55 return _.chain(messages)
56 .filter((message: Message) =>
57 (message.thread.id === currentThread.id))
58 .map((message: Message) => {
59 message.isRead = true;
60 return message; })
61 .value();
62 } else {
63 return [];
64 }
65 });
66
67 this.currentThread.subscribe(this.messagesService.markThreadAsRead);
68 }
69
70 setCurrentThread(newThread: Thread): void {
71 this.currentThread.next(newThread);
72 }
73
74 }
75
76 export const threadsServiceInjectables: Array<any> = [
77 ThreadsService
78 ];
Data Model Summary
Our data model and services are complete! Now we have everything we need now to
start hooking it up to our view components! In the next chapter we'll build out our
3 major components to render and interact with these streams.
Data Architecture with
Observables - Part 2: View
Components
Building Our Views: The AppComponent Top-Level
Component
Let's turn our attention to our app and implement our view components.
For the sake of clarity and space, in the following sections I'll be leaving
out some import statements, CSS and a few other similar lines of code. If
you're curious about each line of those details, open up the sample code
because it contains everything we need to run this app.
The 1st thing we're going to do is create our top-level component chat-app
As we talked about earlier, the page is broken down into three top-level components:
Data Architecture with Observables - Part 2: View Components 352
Chat Top-Level Components
• ChatNavBarComponent - contains the unread messages count
• ChatThreadsComponent - shows a clickable list of threads, along with the most
recent message and the conversation avatar
• ChatWindowComponent - shows the messages in the current thread with an input
box to send new messages
Here's what our top-level component looks like in code:
Data Architecture with Observables - Part 2: View Components 353
code/rxjs/rxjs-chat/src/app/app.component.ts
1 import { Component, Inject } from '@angular/core';
2 import { ChatExampleData } from './data/chat-example-data';
3
4 import { UsersService } from './user/users.service';
5 import { ThreadsService } from './thread/threads.service';
6 import { MessagesService } from './message/messages.service';
7
8 @Component({
9 selector: 'app-root',
10 templateUrl: './app.component.html',
11 styleUrls: ['./app.component.css']
12 })
13 export class AppComponent {
14 constructor(public messagesService: MessagesService,
15 public threadsService: ThreadsService,
16 public usersService: UsersService) {
17 ChatExampleData.init(messagesService, threadsService, usersService);
18 }
19 }
and the template:
code/rxjs/rxjs-chat/src/app/app.component.html
1 <div>
2 <chat-page></chat-page>
3 </div>
In this chapter we are adding some style using the CSS framework
Bootstrap⁹⁵
Take a look at the constructor. Here we're injecting our three services: the MessagesService,
ThreadsService and UsersService. We're using those services to
initialize our example data.
If you're interested in the example data you can find it in
code/rxjs/rxjs-chat/src/app/data/chat-example-data.ts.
⁹⁵http://getbootstrap.com
Data Architecture with Observables - Part 2: View Components 354
We'll build our chat-page in a moment, but 1st let's build our thread list in the
ChatThreadsComponent.
The ChatThreadsComponent
Time Ordered List of Threads
code/rxjs/rxjs-chat/src/app/chat-threads/chat-threads.component.ts
1 import {
2 Component,
3 OnInit,
4 Inject
5 } from '@angular/core';
6 import { Observable } from 'rxjs';
7 import { Thread } from '../thread/thread.model';
8 import { ThreadsService } from './../thread/threads.service';
9
10 @Component({
11 selector: 'chat-threads',
12 templateUrl: './chat-threads.component.html',
13 styleUrls: ['./chat-threads.component.css']
14 })
15 export class ChatThreadsComponent {
16 threads: Observable<any>;
Data Architecture with Observables - Part 2: View Components 355
17
18 constructor(public threadsService: ThreadsService) {
19 this.threads = threadsService.orderedThreads;
20 }
21 }
Here we're injecting ThreadsService and then we're keeping a reference to the
orderedThreads .
ChatThreadsComponent template
Lastly, let's look at the template and its configuration:
code/rxjs/rxjs-chat/src/app/chat-threads/chat-threads.component.html
1 <!-- conversations -->
2 <div class="row">
3 <div class="conversation-wrap">
4
5 <chat-thread
6 *ngFor="let thread of threads | async"
7 [thread]="thread">
8 </chat-thread>
9
10 </div>
11 </div>
There's three things to look at here: NgFor with the async pipe, the ChangeDetectionStrategy
and ChatThreadComponent.
The ChatThreadComponent directive component (which matches chat-thread in the
markup) will show the view for the Threads. We'll define that in a moment.
The NgFor iterates over our threads and passes the input [thread] to our ChatThread-
Component directive. But you probably notice sth new in our *ngFor: the pipe
to async.
async is implemented by AsyncPipe and it lets us use an RxJS Observable here in our
view. What's great about async is that it lets us use our async observable as if it was
a sync collection. This is super convenient and really cool.
Data Architecture with Observables - Part 2: View Components 356
On this component we specify a custom changeDetection. Angular has a flexible and
efficient change detection system. One of the benefits is that if we have a component
which has immutable or observable bindings, then we're able to give the change
detection system hints that will make our application run very efficiently.
We talk more about various change-detection strategies in the Advanced
Components Chapter
In this case, instead of watching for changes on an array of Threads, Angular will
subscribe for changes to the threads observable - and trigger an update when a new
event is emitted.
The Single ChatThreadComponent
Let's look at our ChatThreadComponent. This is the component that will be used to
display a single thread. Starting with the @Component:
code/rxjs/rxjs-chat/src/app/chat-thread/chat-thread.component.ts
1 import {
2 Component,
3 OnInit,
4 Input,
5 Output,
6 EventEmitter
7 } from '@angular/core';
8 import { Observable } from 'rxjs';
9 import { ThreadsService } from './../thread/threads.service';
10 import { Thread } from '../thread/thread.model';
11
12 @Component({
13 selector: 'chat-thread',
14 templateUrl: './chat-thread.component.html',
15 styleUrls: ['./chat-thread.component.css']
16 })
17 export class ChatThreadComponent implements OnInit {
18 @Input() thread: Thread;
19 selected = false;
20
Data Architecture with Observables - Part 2: View Components 357
21 constructor(public threadsService: ThreadsService) {
22 }
23
24 ngOnInit(): void {
25 this.threadsService.currentThread
26 .subscribe( (currentThread: Thread) => {
27 this.selected = currentThread &&
28 this.thread &&
29 (currentThread.id === this.thread.id);
30 });
31 }
32
33 clicked(event: any): void {
34 this.threadsService.setCurrentThread(this.thread);
35 event.preventDefault();
36 }
37 }
We'll come back and look at the template in a minute, but 1st let's look at the
component definition controller.
ChatThreadComponent Controller and ngOnInit
Notice that we're implementing a new interface here: OnInit. Angular components
can declare that they listen for certain lifecycle events. We talk more about lifecycle
events here in the Advanced Components chapter.
In this case, because we declared that we implement OnInit, the method ngOnInit
will be called on our component after the component has been checked for changes
the 1st time.
A key reason we will use ngOnInit is because our thread property won't be
available in the constructor.
Above you can see that in ngOnInit we subscribe to threadsService.currentThread
and if the currentThread matches the thread property of this component, we set
selected to true (conversely, if the Thread doesn't match, we set selected to false).
We also setup an event handler clicked. This is how we handle selecting the current
thread. In our template (below), we will bind clicked() to clicking on the thread
view. If we receive clicked() then we tell the threadsService we want to set the
current thread to the Thread of this component.
Data Architecture with Observables - Part 2: View Components 358
ChatThreadComponent template
Here's the code for our template:
code/rxjs/rxjs-chat/src/app/chat-thread/chat-thread.component.html
1 <div class="media conversation">
2 <div class="pull-left">
3 <img class="media-object avatar"
4 src="{{thread.avatarSrc}}">
5 </div>
6 <div class="media-body">
7 <h5 class="media-heading contact-name">{{thread.name}}
8 <span *ngIf="selected">&bull;</span>
9 </h5>
10 <small class="message-preview">{{thread.lastMessage.text}}</small>
11 </div>
12 <a (click)="clicked($event)" class="div-link">Select</a>
13 </div>
Notice we've got some straight-forward bindings like {{thread.avatarSrc}}, {{thread.name}},
and {{thread.lastMessage.text}}.
We've got an *ngIf which will show the &bull; symbol only if this is the selected
thread.
Lastly, we're binding to the (click) event to call our clicked() handler. Notice that
when we call clicked we're passing the argument $event. This is a special variable
provided by Angular that describes the event. We use that in our clicked handler
by calling event.preventDefault();. This makes sure that we don't navigate to a
different page.
The ChatWindowComponent
The ChatWindowComponent is the most complicated component in our app. Let's take
it one section at a time:
Data Architecture with Observables - Part 2: View Components 359
The Chat Window
We start by defining our @Component:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
17 @Component({
18 selector: 'chat-window',
19 templateUrl: './chat-window.component.html',
20 styleUrls: ['./chat-window.component.css'],
21 changeDetection: ChangeDetectionStrategy.OnPush
ChatWindowComponent Class Properties
Our ChatWindowComponent class has four properties :
Data Architecture with Observables - Part 2: View Components 360
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
23 export class ChatWindowComponent implements OnInit {
24 messages: Observable<any>;
25 currentThread: Thread;
26 draftMessage: Message;
27 currentUser: User;
Here's a diagram of where each one is used:
Chat Window Properties
In our constructor we're going to inject four things:
Data Architecture with Observables - Part 2: View Components 361
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
29 constructor(public messagesService: MessagesService,
30 public threadsService: ThreadsService,
31 public UsersService: UsersService,
32 public el: ElementRef) {
33 }
The 1st three are our services. The fourth, el is an ElementRef which we can use to
get access to the host DOM element. We'll use that when we scroll to the bottom of
the chat window when we create and receive new messages.
Remember: by using public messagesService: MessagesService in the
constructor, we are not only injecting the MessagesService but setting
up an instance variable that we can use later in our class via
this.messagesService
ChatWindowComponent ngOnInit
We're going to put the initialization of this component in ngOnInit. The main thing
we're going to be doing here is setting up the subscriptions on our observables which
will then change our component properties.
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
35 ngOnInit(): void {
36 this.messages = this.threadsService.currentThreadMessages;
37
38 this.draftMessage = new Message();
First, we'll save the currentThreadMessages into messages. Next we create an empty
Message for the default draftMessage.
When we send a new message we need to make sure that Message stores a reference
to the sending Thread. The sending thread is always going to be the current thread,
so let's store a reference to the currently selected thread:
Data Architecture with Observables - Part 2: View Components 362
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
40 this.threadsService.currentThread.subscribe(
41 (thread: Thread) => {
42 this.currentThread = thread;
43 });
We also want new messages to be sent from the current user, so let's do the same
with currentUser:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
45 this.UsersService.currentUser
46 .subscribe(
47 (user: User) => {
48 this.currentUser = user;
49 });
ChatWindowComponent sendMessage
Since we're talking about it, let's implement a sendMessage function that will send a
new message:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
65 sendMessage(): void {
66 const m: Message = this.draftMessage;
67 m.author = this.currentUser;
68 m.thread = this.currentThread;
69 m.isRead = true;
70 this.messagesService.addMessage(m);
71 this.draftMessage = new Message();
72 }
The sendMessage function above takes the draftMessage, sets the author and thread
using our component properties. Every message we send has "been read" already (we
wrote it) so we mark it as read.
Notice here that we're not updating the draftMessage text. That's because we're
going to bind the value of the messages text in the view in a few minutes.
After we've updated the draftMessage properties we send it off to the messagesService
and then create a new Message and set that new Message to this.draftMessage.
We do this to make sure we don't mutate an already sent message.
Data Architecture with Observables - Part 2: View Components 363
ChatWindowComponent onEnter
In our view, we want to send the message in two scenarios
1. the user hits the "Send" button or
2. the user hits the Enter (or Return) key.
Let's define a function that will handle that event:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
60 onEnter(event: any): void {
61 this.sendMessage();
62 event.preventDefault();
63 }
ChatWindowComponent scrollToBottom
When we send a message, or when a new message comes in, we want to scroll to the
bottom of the chat window. To do that, we're going to set the scrollTop property of
our host element:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
74 scrollToBottom(): void {
75 const scrollPane: any = this.el
76 .nativeElement.querySelector('.msg-container-base');
77 scrollPane.scrollTop = scrollPane.scrollHeight;
78 }
Now that we have a function that will scroll to the bottom, we have to make sure
that we call it at the right time. Back in ngOnInit let's subscribe to the list of
currentThreadMessages and scroll to the bottom anytime we get a new message:
Data Architecture with Observables - Part 2: View Components 364
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
50 this.messages
51 .subscribe(
52 (messages: Array<Message>) => {
53 setTimeout(() => {
54 this.scrollToBottom();
55 });
56 });
57 }
Why do we have the setTimeout?
If we call scrollToBottom immediately when we get a new message then
what happens is we scroll to the bottom before the new message is rendered.
By using a setTimeout we're telling JS that we want to run this
function when it is finished with the current execution queue. This happens
after the component is rendered, so it does what we want.
ChatWindowComponent template
The opening of our template should look familiar, we start by defining some markup
and the panel header:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.html
1 <div class="chat-window-container">
2 <div class="chat-window">
3 <div class="panel-container">
4 <div class="panel panel-default">
5
6 <div class="panel-heading top-bar">
7 <div class="panel-title-container">
8 <h3 class="panel-title">
9 <span class="glyphicon glyphicon-comment"></span>
10 Chat - {{currentThread.name}}
11 </h3>
12 </div>
13 <div class="panel-buttons-container">
14 <!-- you could put minimize or close buttons here -->
15 </div>
16 </div>
Data Architecture with Observables - Part 2: View Components 365
Next we show the list of messages. Here we use ngFor along with the async pipe
to iterate over our list of messages. We'll describe the individual chat-message
component in a minute.
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.html
18 <div class="panel-body msg-container-base">
19 <chat-message
20 *ngFor="let message of messages | async"
21 [message]="message">
22 </chat-message>
23 </div>
Lastly we have the message input box and closing tags :
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.html
24 <div class="panel-footer">
25 <div class="input-group">
26 <input type="text"
27 class="chat-input"
28 placeholder="Write your message here..."
29 (keydown.enter)="onEnter($event)"
30 [(ngModel)]="draftMessage.text" />
31 <span class="input-group-btn">
32 <button class="btn-chat"
33 (click)="onEnter($event)"
34 >Send</button>
35 </span>
36 </div>
37 </div>
38
39 </div>
40 </div>
41 </div>
The message input box is the most interesting part of this view, so let's talk about
two interesting properties: 1. (keydown.enter) and 2. [(ngModel)].
Handling keystrokes
Angular provides a straightforward way to handle keyboard actions: we bind to
the event on an element. In this case, on the input tag above, we're binding to
Data Architecture with Observables - Part 2: View Components 366
keydown.enter which says if "Enter" is pressed, call the function in the expression,
which in this case is onEnter($event).
Using ngModel
As we've talked about before, Angular doesn't have a general model for two-way
binding. However it can be very useful to have a two-way binding between a
component and its view. As long as the side-effects are kept local to the component,
it can be a very convenient way to keep a component property in sync with the view.
In this case, we're establishing a two-way bind between the value of the input tag
and draftMessage.text. That is, if we type into the input tag, draftMessage.text
will automatically be set to the value of that input. Likewise, if we were to update
draftMessage.text in our code, the value in the input tag would change in the view.
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.html
27 <input type="text"
28 class="chat-input"
29 placeholder="Write your message here..."
30 (keydown.enter)="onEnter($event)"
31 [(ngModel)]="draftMessage.text" />
Clicking "Send"
On our "Send" button we bind the (click) property to the onEnter function of our
component:
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.html
32 <span class="input-group-btn">
33 <button class="btn-chat"
34 (click)="onEnter($event)"
35 >Send</button>
36 </span>
The Entire ChatWindowComponent
We broke that up into a lot of tiny pieces. So that we can get a view of the whole
thing, here's the code listing for the entire ChatWindowComponent:
Data Architecture with Observables - Part 2: View Components 367
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.ts
1 import {
2 Component,
3 Inject,
4 ElementRef,
5 OnInit,
6 ChangeDetectionStrategy
7 } from '@angular/core';
8 import { Observable } from 'rxjs';
9
10 import { User } from '../user/user.model';
11 import { UsersService } from '../user/users.service';
12 import { Thread } from '../thread/thread.model';
13 import { ThreadsService } from '../thread/threads.service';
14 import { Message } from '../message/message.model';
15 import { MessagesService } from '../message/messages.service';
16
17 @Component({
18 selector: 'chat-window',
19 templateUrl: './chat-window.component.html',
20 styleUrls: ['./chat-window.component.css'],
21 changeDetection: ChangeDetectionStrategy.OnPush
22 })
23 export class ChatWindowComponent implements OnInit {
24 messages: Observable<any>;
25 currentThread: Thread;
26 draftMessage: Message;
27 currentUser: User;
28
29 constructor(public messagesService: MessagesService,
30 public threadsService: ThreadsService,
31 public UsersService: UsersService,
32 public el: ElementRef) {
33 }
34
35 ngOnInit(): void {
36 this.messages = this.threadsService.currentThreadMessages;
37
38 this.draftMessage = new Message();
39
40 this.threadsService.currentThread.subscribe(
41 (thread: Thread) => {
42 this.currentThread = thread;
43 });
Data Architecture with Observables - Part 2: View Components 368
44
45 this.UsersService.currentUser
46 .subscribe(
47 (user: User) => {
48 this.currentUser = user;
49 });
50
51 this.messages
52 .subscribe(
53 (messages: Array<Message>) => {
54 setTimeout(() => {
55 this.scrollToBottom();
56 });
57 });
58 }
59
60 onEnter(event: any): void {
61 this.sendMessage();
62 event.preventDefault();
63 }
64
65 sendMessage(): void {
66 const m: Message = this.draftMessage;
67 m.author = this.currentUser;
68 m.thread = this.currentThread;
69 m.isRead = true;
70 this.messagesService.addMessage(m);
71 this.draftMessage = new Message();
72 }
73
74 scrollToBottom(): void {
75 const scrollPane: any = this.el
76 .nativeElement.querySelector('.msg-container-base');
77 scrollPane.scrollTop = scrollPane.scrollHeight;
78 }
79 }
and template:
Data Architecture with Observables - Part 2: View Components 369
code/rxjs/rxjs-chat/src/app/chat-window/chat-window.component.html
1 <div class="chat-window-container">
2 <div class="chat-window">
3 <div class="panel-container">
4 <div class="panel panel-default">
5
6 <div class="panel-heading top-bar">
7 <div class="panel-title-container">
8 <h3 class="panel-title">
9 <span class="glyphicon glyphicon-comment"></span>
10 Chat - {{currentThread.name}}
11 </h3>
12 </div>
13 <div class="panel-buttons-container">
14 <!-- you could put minimize or close buttons here -->
15 </div>
16 </div>
17
18 <div class="panel-body msg-container-base">
19 <chat-message
20 *ngFor="let message of messages | async"
21 [message]="message">
22 </chat-message>
23 </div>
24
25 <div class="panel-footer">
26 <div class="input-group">
27 <input type="text"
28 class="chat-input"
29 placeholder="Write your message here..."
30 (keydown.enter)="onEnter($event)"
31 [(ngModel)]="draftMessage.text" />
32 <span class="input-group-btn">
33 <button class="btn-chat"
34 (click)="onEnter($event)"
35 >Send</button>
36 </span>
37 </div>
38 </div>
39
40 </div>
41 </div>
42 </div>
Data Architecture with Observables - Part 2: View Components 370
The ChatMessageComponent
Each Message is rendered by the ChatMessageComponent.
The ChatMessageComponent
This component is relatively straightforward. The main logic here is rendering a
slightly different view depending on if the message was authored by the current user.
If the Message was not written by the current user, then we consider the message
incoming.
Remember that each ChatMessageComponent belongs to one Message. So in ngOnInit
we will subscribe to the currentUser stream and set incoming depending on if this
Message was written by the current user:
We start by defining the @Component
Data Architecture with Observables - Part 2: View Components 371
code/rxjs/rxjs-chat/src/app/chat-message/chat-message.component.ts
1 import {
2 Component,
3 OnInit,
4 Input
5 } from '@angular/core';
6 import { Observable } from 'rxjs';
7
8 import { UsersService } from './../user/users.service';
9 import { ThreadsService } from './../thread/threads.service';
10 import { MessagesService } from './../message/messages.service';
11
12 import { Message } from './../message/message.model';
13 import { Thread } from './../thread/thread.model';
14 import { User } from './../user/user.model';
15
16 @Component({
17 selector: 'chat-message',
18 templateUrl: './chat-message.component.html',
19 styleUrls: ['./chat-message.component.css']
20 })
21 export class ChatMessageComponent implements OnInit {
22 @Input() message: Message;
23 currentUser: User;
24 incoming: boolean;
25
26 constructor(public UsersService: UsersService) {
27 }
28
29 ngOnInit(): void {
30 this.UsersService.currentUser
31 .subscribe(
32 (user: User) => {
33 this.currentUser = user;
34 if (this.message.author && user) {
35 this.incoming = this.message.author.id !== user.id;
36 }
37 });
38 }
39 }
Data Architecture with Observables - Part 2: View Components 372
The ChatMessageComponent template
In our template we have two interesting ideas:
1. the FromNowPipe
2. [ngClass]
First, here's the code:
code/rxjs/rxjs-chat/src/app/chat-message/chat-message.component.html
1 <div class="msg-container"
2 [ngClass]="{'base-sent': !incoming, 'base-receive': incoming}">
3
4 <div class="avatar"
5 *ngIf="!incoming">
6 <img src="{{message.author.avatarSrc}}">
7 </div>
8
9 <div class="messages"
10 [ngClass]="{'msg-sent': !incoming, 'msg-receive': incoming}">
11 <p>{{message.text}}</p>
12 <p class="time">{{message.sender}} • {{message.sentAt | fromNow}}</p>
13 </div>
14
15 <div class="avatar"
16 *ngIf="incoming">
17 <img src="{{message.author.avatarSrc}}">
18 </div>
19 </div>
The FromNowPipe is a pipe that casts our Messages sent-at time to a human-readable "x
seconds ago" message. You can see that we use it by: {{message.sentAt | fromNow}}
FromNowPipe uses the excellent moment.js⁹⁶ library. If you'd like to learn
about creating your own custom pipes read the source of the FromNowPipe
in code/rxjs/rxjs-chat/src/app/pipes/from-now.pipe.ts
We also make extensive use of ngClass in this view. The idea is, when we say:
⁹⁶http://momentjs.com/
Data Architecture with Observables - Part 2: View Components 373
[ngClass]="{'msg-sent': !incoming, 'msg-receive': incoming}"
We're asking Angular to apply the msg-receive class if incoming is truthy (and apply
msg-sent if incoming is falsey).
By using the incoming property, we're able to display incoming and outgoing
messages differently.
The ChatNavBarComponent
The last component we have to talk about is the ChatNavBarComponent. In the nav-bar
we'll show an unread messages count to the user.
The Unread Count in the ChatNavBarComponent
The best way to try out the unread messages count is to use the "Waiting
Bot". If you haven't already, try sending the message '3' to the Waiting
Bot and then switch to another window. The Waiting Bot will then wait 3
seconds before sending you a message and you will see the unread messages
counter increment.
The ChatNavBarComponent @Component
The only thing the ChatNavBarComponent controller needs to keep track of is the
unreadMessagesCount. This is slightly more complicated than it seems on the surface.
The most straightforward way would be to simply listen to messagesService.messages
and sum the number of Messages where isRead is false. This works fine for all
messages outside of the current thread. However new messages in the current thread
aren't guaranteed to be marked as read by the time messages emits new values.
The safest way to handle this is to combine the messages and currentThread streams
and make sure we don't count any messages that are part of the current thread.
Data Architecture with Observables - Part 2: View Components 374
We do this using the combineLatest operator, which we've already used earlier in
the chapter:
code/rxjs/rxjs-chat/src/app/chat-nav-bar/chat-nav-bar.component.ts
1 import {
2 Component,
3 Inject,
4 OnInit
5 } from '@angular/core';
6 import * as _ from 'lodash';
7
8 import { ThreadsService } from './../thread/threads.service';
9 import { MessagesService } from './../message/messages.service';
10
11 import { Thread } from './../thread/thread.model';
12 import { Message } from './../message/message.model';
13
14 @Component({
15 selector: 'chat-nav-bar',
16 templateUrl: './chat-nav-bar.component.html',
17 styleUrls: ['./chat-nav-bar.component.css']
18 })
19 export class ChatNavBarComponent implements OnInit {
20 unreadMessagesCount: number;
21
22 constructor(public messagesService: MessagesService,
23 public threadsService: ThreadsService) {
24 }
25
26 ngOnInit(): void {
27 this.messagesService.messages
28 .combineLatest(
29 this.threadsService.currentThread,
30 (messages: Message[], currentThread: Thread) =>
31 [currentThread, messages] )
32
33 .subscribe(([currentThread, messages]: [Thread, Message[]]) => {
34 this.unreadMessagesCount =
35 _.reduce(
36 messages,
37 (sum: number, m: Message) => {
38 const messageIsInCurrentThread: boolean = m.thread &&
39 currentThread &&
40 (currentThread.id === m.thread.id);
Data Architecture with Observables - Part 2: View Components 375
41 // note: in a "real" app you should also exclude
42 // messages that were authored by the current user b/c they've
43 // already been "read"
44 if (m && !m.isRead && !messageIsInCurrentThread) {
45 sum = sum + 1;
46 }
47 return sum;
48 },
49 0);
50 });
51 }
52 }
If you're not an expert in TS you might find the above syntax a little bit
hard to parse. In the combineLatest callback function we're returning an array with
currentThread and messages as its two elements.
Then we subscribe to that stream and we're destructuring those objects in the
function call. Next we reduce over the messages and count the number of messages
that are unread and not in the current thread.
The ChatNavBarComponent template
In our view, the only thing we have left to do is display our unreadMessagesCount:
code/rxjs/rxjs-chat/src/app/chat-nav-bar/chat-nav-bar.component.html
1 <nav class="navbar navbar-default">
2 <div class="container-fluid">
3 <div class="navbar-header">
4 <a class="navbar-brand" href="https://ng-book.com/2">
5 <img src="assets/images/logos/ng-book-2-minibook.png"/>
6 ng-book
7 </a>
8 </div>
9 <p class="navbar-text navbar-right">
10 <button class="btn btn-primary" type="button">
11 Messages <span class="badge">{{ unreadMessagesCount }}</span>
12 </button>
13 </p>
14 </div>
15 </nav>
Data Architecture with Observables - Part 2: View Components 376
Summary
There we go, if we put them all together we've got a fully functional chat app!
Completed Chat Application
If you checkout code/rxjs/rxjs-chat/src/app/data/chat-example-data.ts you'll
see we've written a handful of bots for you that you can chat with. Here's a code
excerpt from the Reverse Bot:
let rev: User = new User("Reverse Bot", require("images/avatars/female-avatar-4.png"));
let tRev: Thread = new Thread("tRev", rev.name, rev.avatarSrc);
Data Architecture with Observables - Part 2: View Components 377
code/rxjs/rxjs-chat/src/app/data/chat-example-data.ts
91 messagesService.messagesForThreadUser(tRev, rev)
92 .forEach( (message: Message): void => {
93 messagesService.addMessage(
94 new Message({
95 author: rev,
96 text: message.text.split('').reverse().join(''),
97 thread: tRev
98 })
99 );
100 },
Above you can see that we've subscribed to the messages for the "Reverse Bot" by
using messagesForThreadUser. Try writing a few bots of your own.
Introduction to Redux with
TS
In this chapter and the next we'll be looking at a data-architecture pattern
called Redux. In this chapter we're going to discuss the ideas behind
Redux, build our own mini version and then hook it up to Angular. In
the next chapter we'll use Redux to build a bigger application.
In most of our projects so far, we've managed state in a fairly direct way: We tend
to grab data from services and render them in components, passing values down the
component tree along the way.
Managing our apps in this way works fine for smaller apps, but as our apps
grow, having multiple components manage different parts of the state becomes
cumbersome. Np. passing all of our values down our component tree suffers
from the following downsides:
Intermediate property passing - In order to get state to any component we have
to pass the values down through inputs. This means we have many intermediate
components passing state that it isn't directly using or concerned about
Inflexible refactoring - Because we're passing inputs down through the component
tree, we're introducing a coupling between parent and child components that often
isn't necessary. This makes it more difficult to put a child component somewhere
else in the hierarchy because we have to change all of the new parents to pass the
state
State tree and DOM tree don't match - The "shape" of our state often doesn't
match the "shape" of our view/component hierarchy. By passing all data through
the component tree via props we run into difficulties when we need to reference
data in a far branch of the tree
State throughout our app - If we manage state via components, it's difficult to
get a snapshot of the total state of our app. This can make it hard to know which
Introduction to Redux with TS 379
component "owns" a particular bit of data and which components are concerned
about changes
Pulling data out of our components and into services helps a lot. At least if services
are the "owners" of our data, we have a better idea of where to put things. But this
opens a new question: what are the best practices for "service-owned" data? Are
there any patterns we can follow? In fact, there are.
In this chapter, we're going to discuss a data-architecture pattern called Redux which
was designed to help with these issues. We'll implement our own version of Redux
which will store all of our state in a single place. This idea of holding all of
our application's state in one place might sound a little crazy, but the results are
surprisingly delightful.
Redux
If you haven't heard of Redux yet you can read a bit about it on the official website⁹⁷.
Web application data architecture is evolving and the traditional ways of structuring
data aren't quite adequate for large web apps. Redux has been extremely popular
because it's both powerful and easy to understand.
Data architecture can be a complex topic and so Redux's best feature is probably its
simplicity. If you strip Redux down to the essential core, Redux is fewer than 100
lines of code.
We can build rich, easy to understand, web apps by using Redux as the backbone of
our application. But 1st, let's walk through how to write a minimal Redux and later
we'll work out patterns that emerge as we work out these ideas in a larger app.
⁹⁷http://redux.js.org/
Introduction to Redux with TS 380
There are several attempts to use Redux or create a Redux-inspired system
that works with Angular. Two notable examples are:
• ngrx/store⁹⁸ and
• angular2-redux⁹⁹
ngrx is a Redux-inspired architecture that is heavily observables-based.
angular2-redux uses Redux itself as a dependency and adds some Angular
helpers (dependency-injection, observable wrappers).
Here we're not going to use either. Instead, we're going to use Redux
directly in order to show the concepts without introducing a new dependency.
That said, both of these libraries may be helpful to you when writing
your apps.
Redux: Key Ideas
The key ideas of Redux are this:
• All of your application's data is in a single data structure called the state which
is held in the store
• Your app reads the state from this store
• This store is never mutated directly
• User interaction (and other code) fires actions which describe what happened
• A new state is created by combining the old state and the action by a function
called the reducer.
⁹⁸https://github.com/ngrx/store
⁹⁹https://github.com/InfomediaLtd/angular2-redux
Introduction to Redux with TS 381
Redux Core
If the above bullet list isn't clear yet, don't worry about it - putting these ideas into
practice is the goal of the rest of this chapter.
Core Redux Ideas
What's a reducer?
Let's talk about the reducer first. Here's the idea of a reducer: it takes the old state
and an action and returns a new state.
A reducer must be a pure function¹⁰⁰. That is:
1. It must not mutate the current state directly
2. It must not use any data outside of its arguments
Put another way, a pure function will always return the same value, given the
same set of arguments. And a pure function won't call any functions which have
¹⁰⁰https://en.wikipedia.org/wiki/Pure_function
Introduction to Redux with TS 382
an effect on the outside world, e.g. no database calls, no HTTP calls and no mutating
outside data structures.
Reducers should always treat the current state as read-only. A reducer does not
change the state instead, it returns a new state. (Often this new state will start
with a copy of old state, but let's not get ahead of ourselves.)
Let's define our very 1st reducer. Remember, there are three things involved:
1. An Action, which defines what to do (with optional arguments)
2. The state, which stores all of the data in our application
3. The Reducer which takes the state and the Action and returns a new state.
Defining Action and Reducer Interfaces
Since we're using TS we want to make sure this whole process is typed, so
let's set up an interface for our Action and our Reducer:
The Action Interface
Our Action interface looks like this:
code/redux/redux-chat/tutorial/01-identity-reducer.ts
1 interface Action {
2 type: string;
3 payload?: any;
4 }
Notice that our Action has two fields:
1. type and
2. payload
The type will be an identifying string that describes the action like INCREMENT or
ADD_USER. The payload can be an object of any kind. The ? on payload? means that
this field is optional.
The Reducer Interface
Our Reducer interface looks like this:
Introduction to Redux with TS 383
code/redux/redux-chat/tutorial/01-identity-reducer.ts
6 interface Reducer<T> {
7 (state: T, action: Action): T;
8 }
Our Reducer is using a feature of TS called generics. In this case type T is the
type of the state. Notice that we're saying that a valid Reducer has a function which
takes a state (of type T) and an action and returns a new state (also of type T).
Creating Our 1st Reducer
The simplest possible reducer returns the state itself. (You might call this the identity
reducer because it applies the identity function¹⁰¹ on the state. This is the default case
for all reducers, as we will soon see).
code/redux/redux-chat/tutorial/01-identity-reducer.ts
10 let reducer: Reducer<number> = (state: number, action: Action) => {
11 return state;
12 };
Notice that this Reducer makes the generic type concrete to number by the syntax
Reducer<number>. We'll define more sophisticated states beyond a single number
soon.
We're not using the Action yet, but let's try this Reducer just the same.
¹⁰¹https://en.wikipedia.org/wiki/Identity_function
Introduction to Redux with TS 384
Running the examples in this section
You can find the code for this chapter in the folder code/redux. If the
example is runnable you will see the filename the code is from above each
code box.
In this 1st section, these examples are run outside of the browser and run
by node.js. Because we're using TS in these examples, you should
run them using the commandline tool ts-node, (instead of node directly).
You can install ts-node by running:
1 npm install -g ts-node
Or by doing an npm install in the code/redux/redux-chat directory and
then calling ./node_modules/.bin/ts-node [filename]
Np. to run the example above you might type (not including the
$):
1 $ cd code/redux/redux-chat/tutorial
2 $ npm install
3 $ ./node_modules/.bin/ts-node 01-identity-reducer.ts
Use this same procedure for the rest of the code in this chapter until we
instruct you to switch to your browser.
Running Our 1st Reducer
Let's put it all together and run this reducer:
Introduction to Redux with TS 385
code/redux/redux-chat/tutorial/01-identity-reducer.ts
1 interface Action {
2 type: string;
3 payload?: any;
4 }
5
6 interface Reducer<T> {
7 (state: T, action: Action): T;
8 }
9
10 let reducer: Reducer<number> = (state: number, action: Action) => {
11 return state;
12 };
13
14 console.log( reducer(0, null) ); // -> 0
And run it:
$ cd code/redux/redux-chat/tutorial
$ ./node_modules/.bin/ts-node 01-identity-reducer.ts
0
It seems almost silly to have that as a code example, but it teaches us our 1st principle
of reducers:
By default, reducers return the original state.
In this case, we passed a state of the number 0 and a null action. The result from this
reducer is the state 0.
But let's do sth more interesting and make our state change.
Adjusting the Counter With actions
Eventually our state is going to be much more sophisticated than a single number.
We're going to be holding all of the data for our app in the state, so we'll need a
better data structure for the state eventually.
That said, using a single number for the state lets us focus on other issues for now. So
let's continue with the idea that our state is simply a single number that is storing
a counter.
Introduction to Redux with TS 386
Let's say we want to be able to change the state number. Remember that in Redux
we do not modify the state. Instead, we create actions which instruct the reducer on
how to generate a new state.
Let's create an Action to change our counter. Remember that the only required
property is a type. We might define our 1st action like this:
1 let incrementAction: Action = { type: 'INCREMENT' }
We should also create a second action that instructs our reducer to make the counter
smaller with:
1 let decrementAction: Action = { type: 'DECREMENT' }
Now that we have these actions, let's try using them in our reducer:
code/redux/redux-chat/tutorial/02-adjusting-reducer.ts
10 let reducer: Reducer<number> = (state: number, action: Action) => {
11 if (action.type === 'INCREMENT') {
12 return state + 1;
13 }
14 if (action.type === 'DECREMENT') {
15 return state - 1;
16 }
17 return state;
18 };
And now we can try out the whole reducer:
Introduction to Redux with TS 387
code/redux/redux-chat/tutorial/02-adjusting-reducer.ts
20 let incrementAction: Action = { type: 'INCREMENT' };
21
22 console.log( reducer(0, incrementAction )); // -> 1
23 console.log( reducer(1, incrementAction )); // -> 2
24
25 let decrementAction: Action = { type: 'DECREMENT' };
26
27 console.log( reducer(100, decrementAction )); // -> 99
Neat! Now the new value of the state is returned according to which action we pass
into the reducer.
Reducer switch
Instead of having so many if statements, the common practice is to convert the
reducer body to a switch statement:
code/redux/redux-chat/tutorial/03-adjusting-reducer-switch.ts
10 let reducer: Reducer<number> = (state: number, action: Action) => {
11 switch (action.type) {
12 case 'INCREMENT':
13 return state + 1;
14 case 'DECREMENT':
15 return state - 1;
16 default:
17 return state; // <-- dont forget!
18 }
19 };
20
21 let incrementAction: Action = { type: 'INCREMENT' };
22 console.log(reducer(0, incrementAction)); // -> 1
23 console.log(reducer(1, incrementAction)); // -> 2
24
25 let decrementAction: Action = { type: 'DECREMENT' };
26 console.log(reducer(100, decrementAction)); // -> 99
27
28 // any other action just returns the input state
29 let unknownAction: Action = { type: 'UNKNOWN' };
30 console.log(reducer(100, unknownAction)); // -> 100
Introduction to Redux with TS 388
Notice that the default case of the switch returns the original state. This ensures
that if an unknown action is passed in, there's no error and we get the original state
unchanged.
Q: Wait, all of my application state is in one giant switch statement?
A: Yes and no.
If this is your 1st exposure to Redux reducers it might feel a little weird to
have all of your application state changes be the result of a giant switch.
There are two things you should know:
1. Having your state changes centralized in one place can help a ton
in maintaining your program, particularly because it's easy to track
down where the changes are happening when they're all together.
(Furthermore, you can easily locate what state changes as the result of
any action because you can search your code for the token specified
for that action's type)
2. You can (and often do) break your reducers down into several subreducers
which each manage a different branch of the state tree. We'll
talk about this later.
Action "Arguments"
In the last example our actions contained only a type which told our reducer either
to increment or decrement the state.
But often changes in our app can't be described by a single value - instead we need
parameters to describe the change. This is why we have the payload field in our
Action.
In this counter example, say we wanted to add 9 to the counter. One way to do this
would be to send 9 INCREMENT actions, but that wouldn't be very efficient, especially
if we wanted to add, say, 9000.
Instead, let's add a PLUS action that will use the payload parameter to send a number
which specifies how much we want to add to the counter. Defining this action is easy
enough:
Introduction to Redux with TS 389
1 let plusSevenAction = { type: 'PLUS', payload: 7 };
Next, to support this action, we add a new case to our reducer that will handle a
'PLUS' action:
code/redux/redux-chat/tutorial/04-plus-action.ts
10 let reducer: Reducer<number> = (state: number, action: Action) => {
11 switch (action.type) {
12 case 'INCREMENT':
13 return state + 1;
14 case 'DECREMENT':
15 return state - 1;
16 case 'PLUS':
17 return state + action.payload;
18 default:
19 return state;
20 }
21 };
PLUS will add whatever number is in the action.payload to the state. We can try it
out:
code/redux/redux-chat/tutorial/04-plus-action.ts
23 console.log( reducer(3, { type: 'PLUS', payload: 7}) ); // -> 10
24 console.log( reducer(3, { type: 'PLUS', payload: 9000}) ); // -> 9003
25 console.log( reducer(3, { type: 'PLUS', payload: -2}) ); // -> 1
In the 1st line we take the state 3 and PLUS a payload of 7, which results in 10. Neat!
However, notice that while we're passing in a state, it doesn't really ever change.
That is, we're not storing the result of our reducer's changes and reusing it for future
actions.
Storing Our State
Our reducers are pure functions and do not change the world around them. The
problem is, in our app, things do change. Specifically, our state changes and we need
to keep the new state somewhere.
In Redux, we keep our state in the store. The store has the responsibility of running
the reducer and then keeping the new state. Let's take a look at a minimal store:
Introduction to Redux with TS 390
code/redux/redux-chat/tutorial/05-minimal-store.ts
10 class Store<T> {
11 private _state: T;
12
13 constructor(
14 private reducer: Reducer<T>,
15 initialState: T
16 ) {
17 this._state = initialState;
18 }
19
20 getState(): T {
21 return this._state;
22 }
23
24 dispatch(action: Action): void {
25 this._state = this.reducer(this._state, action);
26 }
27 }
Notice that our Store is generically typed - we specify the type of the state with
generic type T. We store the state in the private variable _state.
We also give our Store a Reducer, which is also typed to operate on T, the state type
this is because each store is tied to a specific reducer. We store the Reducer in the
private variable reducer.
In Redux, we generally have 1 store and 1 top-level reducer per application.
Let's take a closer look at each method of our State:
• In our constructor we set the _state to the initial state.
• getState() simply returns the current _state
• dispatch takes an action, sends it to the reducer and then updates the value
of _state with the return value
Introduction to Redux with TS 391
Notice that dispatch doesn't return anything. It's only updating the store's state
(once the result returns). This is an important principle of Redux: dispatching actions
is a "fire-and-forget" maneuver. Dispatching actions is not a direct manipulation
of the state and it doesn't return the new state.
When we dispatch actions, we're sending off a notification of what happened. If we
want to know what the current state of the system is, we have to check the state of
the store.
Using the Store
Let's try using our store:
code/redux/redux-chat/tutorial/05-minimal-store.ts
43 // create a new store
44 let store = new Store<number>(reducer, 0);
45 console.log(store.getState()); // -> 0
46
47 store.dispatch({ type: 'INCREMENT' });
48 console.log(store.getState()); // -> 1
49
50 store.dispatch({ type: 'INCREMENT' });
51 console.log(store.getState()); // -> 2
52
53 store.dispatch({ type: 'DECREMENT' });
54 console.log(store.getState()); // -> 1
We start by creating a new Store and we save this in store, which we can use to get
the current state and dispatch actions.
The state is set to 0 initially and then we INCREMENT twice and DECREMENT once and
our final state is 1.
Being Notified with subscribe
It's great that our Store keeps track of what changed, but in the above example we
have to ask for the state changes with store.getState(). It would be nice for us
to know immediately when a new action was dispatched so that we could respond.
Introduction to Redux with TS 392
To do this we can implement the Observer pattern - that is, we'll register a callback
function that will subscribe to all changes.
Here's how we want it to work:
1. We will register a listener function using subscribe
2. When dispatch is called, we will iterate over all listeners and call them, which
is the notification that the state has changed.
Registering Listeners
Our listener callbacks are going to be a function that takes no arguments. Let's define
an interface that makes it easy to describe this:
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
10 interface ListenerCallback {
11 (): void;
12 }
After we subscribe a listener, we might want to unsubscribe as well, so lets define
the interface for an unsubscribe function as well:
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
14 interface UnsubscribeCallback {
15 (): void;
16 }
Not much going on here - it's another function that takes no arguments and has no
return value. But by defining these types it makes our code clearer to read.
Our store is going to keep a list of ListenerCallbacks let's add that to our Store:
Introduction to Redux with TS 393
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
18 class Store<T> {
19 private _state: T;
20 private _listeners: ListenerCallback[] = [];
Now we want to be able to add to that list of _listeners with a subscribe function:
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
38 subscribe(listener: ListenerCallback): UnsubscribeCallback {
39 this._listeners.push(listener);
40 return () => { // returns an "unsubscribe" function
41 this._listeners = this._listeners.filter(l => l !== listener);
42 };
43 }
subscribe accepts a ListenerCallback (i.e. a function with no arguments and no
return value) and returns an UnsubscribeCallback (the same signature). Adding the
new listener is easy: we push it on to the _listeners array.
The return value is a function which will update the list of _listeners to be
the list of _listeners without the listener we just added. That is, it returns the
UnsubscribeCallback that we can use to remove this listener from the list.
Notifying Our Listeners
Whenever our state changes, we want to call these listener functions. What this
means is, whenever we dispatch a new action, whenever the state changes, we want
to call all of the listeners:
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
33 dispatch(action: Action): void {
34 this._state = this.reducer(this._state, action);
35 this._listeners.forEach((listener: ListenerCallback) => listener());
36 }
The Complete Store
We'll try this out below, but before we do that, here's the complete code listing for
our new Store:
Introduction to Redux with TS 394
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
18 class Store<T> {
19 private _state: T;
20 private _listeners: ListenerCallback[] = [];
21
22 constructor(
23 private reducer: Reducer<T>,
24 initialState: T
25 ) {
26 this._state = initialState;
27 }
28
29 getState(): T {
30 return this._state;
31 }
32
33 dispatch(action: Action): void {
34 this._state = this.reducer(this._state, action);
35 this._listeners.forEach((listener: ListenerCallback) => listener());
36 }
37
38 subscribe(listener: ListenerCallback): UnsubscribeCallback {
39 this._listeners.push(listener);
40 return () => { // returns an "unsubscribe" function
41 this._listeners = this._listeners.filter(l => l !== listener);
42 };
43 }
44 }
Trying Out subscribe
Now that we can subscribe to changes in our store, let's try it out:
Introduction to Redux with TS 395
code/redux/redux-chat/tutorial/06-store-w-subscribe.ts
61 let store = new Store<number>(reducer, 0);
62 console.log(store.getState()); // -> 0
63
64 // subscribe
65 let unsubscribe = store.subscribe(() => {
66 console.log('subscribed: ', store.getState());
67 });
68
69 store.dispatch({ type: 'INCREMENT' }); // -> subscribed: 1
70 store.dispatch({ type: 'INCREMENT' }); // -> subscribed: 2
71
72 unsubscribe();
73 store.dispatch({ type: 'DECREMENT' }); // (nothing logged)
74
75 // decrement happened, even though we weren't listening for it
76 console.log(store.getState()); // -> 1
Above we subscribe to our store and in the callback function we'll log subscribed:
and then the current store state.
Notice that the listener function is not given the current state as an
argument. This might seem like an odd choice, but because there are some
nuances to deal with, it's easier to think of the notification of state changed
as separate from the current state. Without digging too much into the
weeds, you can read more about this choice here¹⁰², here¹⁰³ and here¹⁰⁴.
We store the unsubscribe callback and then notice that after we call unsubscribe()
our log message isn't called. We can still dispatch actions, we just won't see the
results until we ask the store for them.
¹⁰²https://github.com/reactjs/redux/issues/1707
¹⁰³https://github.com/reactjs/redux/issues/1513
¹⁰⁴https://github.com/reactjs/redux/issues/303
Introduction to Redux with TS 396
If you're the type of person who likes RxJS and Observables, you might
notice that implementing our own subscription listeners could also be
implemented using RxJS. You could rewrite our Store to use Observables
instead of our own subscriptions.
In fact, we've already done this for you and you can find the sample code
in the file code/redux/redux-chat/tutorial/06b-rx-store.ts.
Using RxJS for the Store is an interesting and powerful pattern if you're
willing to use RxJS for the backbone of our application data.
Here we're not going to use Observables very heavily, particularly because
we want to discuss Redux itself and how to think about data architecture
with a single state tree. Redux itself is powerful enough to use in our
applications without Observables.
Once you get the concepts of using "straight" Redux, adding in Observables
isn't difficult (if you already understand RxJS, that is). For now, we're
going to use "straight" Redux and we'll give you some guidance on some
Observable-based Redux-wrappers at the end.
The Core of Redux
The above store is the essential core of Redux. Our reducer takes the current state
and action and returns a new state, which is held by the store.
There are obviously many more things that we need to add to build a large,
production web app. However, all of the new ideas that we'll cover are patterns
that flow from building on this simple idea of an immutable, central store of state.
If you understand the ideas presented above, you would be likely to invent many of
the patterns (and libraries) you find in more advanced Redux apps.
There's still a lot for us to cover about day-to-day use of Redux though. Np.
we need to know:
• How to carefully handle more complex data structures in our state
• How to be notified when our state changes without having to poll the state
(with subscriptions)
• How to intercept our dispatch for debugging (a.k.a. middleware)
Introduction to Redux with TS 397
• How to compute derived values (with selectors)
• How to split up large reducers into more manageable, smaller ones (and
recombine them)
• How to deal with asynchronous data
We'll explain each of these issues and describe common patterns over the rest of this
chapter and the next.
Let's 1st deal with handling more complex data structures in our state. To do that,
we're going to need an example that's more interesting than a counter. Let's start
building a chat app where users can send each other messages.
A Messaging App
In our messaging app, as in all Redux apps, there are three main parts to the data
model:
1. The state
2. The actions
3. The reducer
Messaging App state
The state in our counter app was a single number. However in our messaging app,
the state is going to be an object.
This state object will have a single property, messages. messages will be an array of
strings, with each string representing an individual message in the application. For
example:
Introduction to Redux with TS 398
1 // an example `state` value
2 {
3 messages: [
4 'here is message one',
5 'here is message two'
6 ]
7 }
We can define the type for the app's state like this:
code/redux/redux-chat/tutorial/07-messages-reducer.ts
7 interface AppState {
8 messages: string[];
9 }
Messaging App actions
Our app will process two actions: ADD_MESSAGE and DELETE_MESSAGE.
The ADD_MESSAGE action object will always have the property message, the message
to be added to the state. The ADD_MESSAGE action object has this shape:
1 {
2 type: 'ADD_MESSAGE',
3 message: 'Whatever message we want here'
4 }
The DELETE_MESSAGE action object will delete a specified message from the state. A
challenge here is that we have to be able to specify which message we want to delete.
If our messages were objects, we could assign each message an id property when it
is created. However, to simplify this example, our messages are just simple strings,
so we'll have to get a handle to the message another way. The easiest way for now
is to just use the index of the message in the array (as a proxy for the ID).
With that in mind, the DELETE_MESSAGE action object has this shape:
Introduction to Redux with TS 399
1 {
2 type: 'DELETE_MESSAGE',
3 index: 2 // <- or whatever index is appropriate
4 }
We can define the types for these actions by using the interface ... extends syntax
in TS:
code/redux/redux-chat/tutorial/07-messages-reducer.ts
11 interface AddMessageAction extends Action {
12 message: string;
13 }
14
15 interface DeleteMessageAction extends Action {
16 index: number;
17 }
In this way our AddMessageAction is able to specify a message and the DeleteMessageAction
will specify an index.
Messaging App reducer
Remember that our reducer needs to handle two actions: ADD_MESSAGE and DELETE_-
MESSAGE. Let's talk about these individually.
Reducing ADD_MESSAGE
Introduction to Redux with TS 400
code/redux/redux-chat/tutorial/07-messages-reducer.ts
19 let reducer: Reducer<AppState> =
20 (state: AppState, action: Action): AppState => {
21 switch (action.type) {
22 case 'ADD_MESSAGE':
23 return {
24 messages: state.messages.concat(
25 (<AddMessageAction>action).message
26 ),
27 };
We start by switching on the action.type and handling the ADD_MESSAGE case.
TS objects already have a type, so why are we adding a type
field?
There are many different ways we might choose to handle this sort of
"polymorphic dispatch". Keeping a string in a type field (where type means
"action-type") is a straightforward, portable way we can use to distinguish
different types of actions and handle them in one reducer. In part, it means
that you don't have to create a new interface for every action.
That said, it would be more satisfying to be able to use reflection to
switch on the concrete type. While this might become possible with more
advanced type guards¹⁰⁵, this isn't currently possible in today's TS.
Broadly speaking, types are a compile-time construct and this code is
compiled down to JS and we can lose some of the typing metadata.
That said, if switching on a type field bothers you and you'd like to
use language features directly, you could use the decoration reflection
metadata¹⁰⁶. For now, a simple type field will suffice.
Adding an Item Without Mutation
When we handle an ADD_MESSAGE action, we need to add the given message to the
state. As will all reducer handlers, we need to return a new state. Remember that
our reducers must be pure and not mutate the old state.
¹⁰⁵https://basarat.gitbooks.io/TS/content/docs/types/typeGuard.html
¹⁰⁶http://blog.wolksoftware.com/decorators-metadata-reflection-in-TS-from-novice-to-expert-part-4
Introduction to Redux with TS 401
What would be the problem with the following code?
1 case 'ADD_MESSAGE':
2 state.messages.push( action.message );
3 return { messages: messages };
4 // ...
The problem is that this code mutates the state.messages array, which changes our
old state! Instead what we want to do is create a copy of the state.messages array
and add our new message to the copy.
code/redux/redux-chat/tutorial/07-messages-reducer.ts
22 case 'ADD_MESSAGE':
23 return {
24 messages: state.messages.concat(
25 (<AddMessageAction>action).message
26 ),
27 };
The syntax <AddMessageAction>action will cast our action to the more
specific type. That is, notice that our reducer takes the more general type
Action, which does not have the message field. If we leave off the cast, then
the compiler will complain that Action does not have a field message.
Instead, we know that we have an ADD_MESSAGE action so we cast it to an
AddMessageAction. We use parentheses to make sure the compiler knows
that we want to cast action and not action.message.
Remember that the reducer must return a new AppState. When we return an object
from our reducer it must match the format of the AppState that was input. In this
case we only have to keep the key messages, but in more complicated states we have
more fields to worry about.
Deleting an Item Without Mutation
Remember that when we handle the DELETE_MESSAGE action we are passing the index
of the item in the array as the faux ID. (Another common way of handling the same
idea would be to pass a real item ID.) Again, because we do not want to mutate the
old messages array, we need to handle this case with care:
Introduction to Redux with TS 402
code/redux/redux-chat/tutorial/07-messages-reducer.ts
28 case 'DELETE_MESSAGE':
29 let idx = (<DeleteMessageAction>action).index;
30 return {
31 messages: [
32 ...state.messages.slice(0, idx),
33 ...state.messages.slice(idx + 1, state.messages.length)
34 ]
Here we use the slice operator twice. 1st we take all of the items up until the item
we are removing. And we concatenate the items that come after.
There are four common non-mutating operations:
• Adding an item to an array
• Removing an item from an array
• Adding / changing a key in an object
• Removing a key from an object
The 1st two (array) operations we just covered. We'll talk more about the
object operations further down, but for now know that a common way to
do this is to use Object.assign. As in:
1 Object.assign({}, oldObject, newObject)
2 // <-------<-------------
You can think of Object.assign as merging objects in from the right into
the object on the left. newObject is merged into oldObject which is merged
into {}. This way all of the fields in oldObject will be kept, except for
where the field exists in newObject. Neither oldObject nor newObject will
be mutated.
Of course, handling all of this on your own takes great care and it is easy to
make a mistake. This is one of the reasons many people use Immutable.js¹⁰⁷,
which is a set of data structures that help enforce immutability.
¹⁰⁷https://facebook.github.io/immutable-js/
Introduction to Redux with TS 403
Trying Out Our Actions
Now let's try running our actions:
code/redux/redux-chat/tutorial/07-messages-reducer.ts
42 let store = new Store<AppState>(reducer, { messages: [] });
43 console.log(store.getState()); // -> { messages: [] }
44
45 store.dispatch({
46 type: 'ADD_MESSAGE',
47 message: 'Would you say the fringe was made of silk?'
48 } as AddMessageAction);
49
50 store.dispatch({
51 type: 'ADD_MESSAGE',
52 message: 'Wouldnt have no other kind but silk'
53 } as AddMessageAction);
54
55 store.dispatch({
56 type: 'ADD_MESSAGE',
57 message: 'Has it really got a team of snow white horses?'
58 } as AddMessageAction);
59
60 console.log(store.getState());
61 // ->
62 // { messages:
63 // [ 'Would you say the fringe was made of silk?',
64 // 'Wouldnt have no other kind but silk',
65 // 'Has it really got a team of snow white horses?' ] }
Here we start with a new store and we call store.getState() and see that we have
an empty messages array.
Next we add three messages¹⁰⁸ to our store. For each message we specify the type as
ADD_MESSAGE and we cast each object to an AddMessageAction.
Finally we log the new state and we can see that messages contains all three messages.
Our three dispatch statements are a bit ugly for two reasons:
1. we manually have to specify the type string each time. We could use a constant,
but it would be nice if we didn't have to do this and
¹⁰⁸https://en.wikipedia.org/wiki/The_Surrey_with_the_Fringe_on_Top
Introduction to Redux with TS 404
2. we're manually casting to an AddMessageAction
Instead of creating these objects as an object directly we should create a function
that will create these objects. This idea of writing a function to create actions is so
common in Redux that the pattern has a name: Action Creators.
Action Creators
Instead of creating the ADD_MESSAGE actions directly as objects, let's create a function
to do this for us:
code/redux/redux-chat/tutorial/08-action-creators.ts
19 class MessageActions {
20 static addMessage(message: string): AddMessageAction {
21 return {
22 type: 'ADD_MESSAGE',
23 message: message
24 };
25 }
26 static deleteMessage(index: number): DeleteMessageAction {
27 return {
28 type: 'DELETE_MESSAGE',
29 index: index
30 };
31 }
32 }
Here we've created a class with two static methods addMessage and deleteMessage.
They return an AddMessageAction and a DeleteMessageAction respectively.
You definitely don't have to use static methods for your action creators. You
could use plain functions, functions in a namespace, even instance methods
on an object, etc. The key idea is to keep them organized in a way that
makes them easy to use.
Now let's use our new action creators:
Introduction to Redux with TS 405
code/redux/redux-chat/tutorial/08-action-creators.ts
55 let store = new Store<AppState>(reducer, { messages: [] });
56 console.log(store.getState()); // -> { messages: [] }
57
58 store.dispatch(
59 MessageActions.addMessage('Would you say the fringe was made of silk?'));
60
61 store.dispatch(
62 MessageActions.addMessage('Wouldnt have no other kind but silk'));
63
64 store.dispatch(
65 MessageActions.addMessage('Has it really got a team of snow white horses?'));
66
67 console.log(store.getState());
68 // ->
69 // { messages:
70 // [ 'Would you say the fringe was made of silk?',
71 // 'Wouldnt have no other kind but silk',
72 // 'Has it really got a team of snow white horses?' ] }
This feels much nicer!
An added benefit is that if we eventually decided to change the format of our
messages, we could do it without having to update all of our dispatch statements.
Np. say we wanted to add the time each message was created. We could
add a created_at field to addMessage and now all AddMessageActions will be given
a created_at field:
1 class MessageActions {
2 static addMessage(message: string): AddMessageAction {
3 return {
4 type: 'ADD_MESSAGE',
5 message: message,
6 // sth like this
7 created_at: new Date()
8 };
9 }
10 // ....
Introduction to Redux with TS 406
Using Real Redux
Now that we've built our own mini-redux you might be asking, "What do I need to
do to use the real Redux?" Thankfully, not very much. Let's update our code to use
the real Redux now!
If you haven't already, you'll want to run npm install in the
code/redux/redux-chat/tutorial directory.
The 1st thing we need to do is import Action, Reducer and Store from the redux
package. We're also going to import a helper method createStore while we're at it:
code/redux/redux-chat/tutorial/09-real-redux.ts
1 import {
2 Action,
3 Reducer,
4 Store,
5 createStore
6 } from 'redux';
Next, instead of specifying our initial state when we create the store instead we're
going to let the reducer create the initial state. Here we'll do this as the default
argument to the reducer. This way if there is no state passed in (e.g. the 1st time it
is called at initialization) we will use the initial state:
code/redux/redux-chat/tutorial/09-real-redux.ts
35 let initialState: AppState = { messages: [] };
36
37 let reducer: Reducer<AppState> =
38 (state: AppState = initialState, action: Action) => {
What's neat about this is that the rest of our reducer stays the same!
The last thing we need to do is create the store using the createStore helper method
from Redux:
Introduction to Redux with TS 407
code/redux/redux-chat/tutorial/09-real-redux.ts
58 let store: Store<AppState> = createStore<AppState>(reducer);
After that, everything else just works!
code/redux/redux-chat/tutorial/09-real-redux.ts
58 let store: Store<AppState> = createStore<AppState>(reducer);
59 console.log(store.getState()); // -> { messages: [] }
60
61 store.dispatch(
62 MessageActions.addMessage('Would you say the fringe was made of silk?'));
63
64 store.dispatch(
65 MessageActions.addMessage('Wouldnt have no other kind but silk'));
66
67 store.dispatch(
68 MessageActions.addMessage('Has it really got a team of snow white horses?'));
69
70 console.log(store.getState());
71 // ->
72 // { messages:
73 // [ 'Would you say the fringe was made of silk?',
74 // 'Wouldnt have no other kind but silk',
75 // 'Has it really got a team of snow white horses?' ] }
Now that we have a handle on using Redux in isolation, the next step is to hook it
up to our web app. Let's do that now.
Using Redux in Angular
In the last section we walked through the core of Redux and showed how to create
reducers and use stores to manage our data in isolation. Now it's time to level-up
and integrate Redux with our Angular components.
In this section we're going to create a minimal Angular app that contains just a
counter which we can increment and decrement with a button.
Introduction to Redux with TS 408
Counter App
By using such a small app we can focus on the integration points between Redux and
Angular and then we can move on to a larger app in the next section. But 1st, let's
see how to build this counter app!
Here we are going to be integrating Redux directly with Angular without
any helper libraries in-between. There are several open-source libraries
with the goal of making this process easier and you can find them in the
references section below.
That said, it can be much easier to use those libraries once you understand
what is going on underneath the hood, which is what we work through
here.
Planning Our App
If you recall, the three steps to planning our Redux apps are to:
1. Define the structure of our central app state
2. Define actions that will change that state and
Introduction to Redux with TS 409
3. Define a reducer that takes the old state and an action and returns a new state.
For this app, we're just going to increment and decrement a counter. We did this in
the last section and so our actions, store and reducer will all be very familiar.
The other thing we need to do when writing Angular apps is decide where we will
create components. In this app, we'll have a top-level AppComponent which contains
the view we see in the screenshot.
At a high level we're going to do the following:
1. Create our Store and make it accessible to our whole app via dependency
injection
2. Subscribe to changes to the Store and display them in our components
3. When sth changes (a button is pressed) we will dispatch an action to the
Store.
Enough planning, let's look at how this works in practice!
Setting Up Redux
Defining the Application State
Let's take a look at our AppState:
code/redux/redux-chat/redux-counter/src/app/app.state.ts
9 export interface AppState {
10 counter: number;
11 };
Here we are defining our core state structure as AppState - it is an object with one
key, counter which is a number. In the next example (the chat app) we'll talk about
how to have more sophisticated states, but for now this will be fine.
Defining the Reducers
Next lets define the reducer which will handle incrementing and decrementing the
counter in the application state:
Introduction to Redux with TS 410
code/redux/redux-chat/redux-counter/src/app/counter.reducer.ts
6 import {
7 INCREMENT,
8 DECREMENT
9 } from './counter.actions';
10
11 const initialState: AppState = { counter: 0 };
12
13 // Create our reducer that will handle changes to the state
14 export const counterReducer: Reducer<AppState> =
15 (state: AppState = initialState, action: Action): AppState => {
16 switch (action.type) {
17 case INCREMENT:
18 return Object.assign({}, state, { counter: state.counter + 1 });
19 case DECREMENT:
20 return Object.assign({}, state, { counter: state.counter - 1 });
21 default:
22 return state;
23 }
24 };
We start by importing the constants INCREMENT and DECREMENT, which are exported by
our action creators. They're just defined as the strings 'INCREMENT' and 'DECREMENT',
but it's nice to get the extra help from the compiler in case we make a typo. We'll
look at those action creators in a minute.
The initialState is an AppState which sets the counter to 0.
The counterReducer handles two actions: INCREMENT, which adds 1 to the current
counter and DECREMENT, which subtracts 1. Both actions use Object.assign to ensure
that we don't mutate the old state, but instead create a new object that gets returned
as the new state.
Since we're here, let's look at the action creators
Defining Action Creators
Our action creators are functions which return objects that define the action to be
taken. increment and decrement below return an object that defines the appropriate
type.
Introduction to Redux with TS 411
code/redux/redux-chat/redux-counter/src/app/counter.actions.ts
1 import {
2 Action,
3 ActionCreator
4 } from 'redux';
5
6 export const INCREMENT: string = 'INCREMENT';
7 export const increment: ActionCreator<Action> = () => ({
8 type: INCREMENT
9 });
10
11 export const DECREMENT: string = 'DECREMENT';
12 export const decrement: ActionCreator<Action> = () => ({
13 type: DECREMENT
14 });
Notice that our action creator functions return the type ActionCreator<Action>.
ActionCreator is a generic class defined by Redux that we use to define functions
that create actions. In this case we're using the concrete class Action, but we could
use a more specific Action class, such as AddMessageAction that we defined in the
last section.
Creating the Store
Now that we have our reducer and state, we could create our store like so:
1 let store: Store<AppState> = createStore<AppState>(counterReducer);
However, one of the awesome things about Redux is that it has a robust set of
developer tools. Specifically, there is a Chrome extension¹⁰⁹ that will let us monitor
the state of our application and dispatch actions.
¹⁰⁹https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en
Introduction to Redux with TS 412
Counter App With Redux Devtools
What's really neat about the Redux Devtools is that it gives us clear insight to every
action that flows through the system and it's affect on the state.
Go ahead and install the Redux Devtools Chrome extension¹¹⁰ now!
In order to use the Devtools we have to do one thing: add it to our store.
code/redux/redux-chat/redux-counter/src/app/app.store.ts
16 const devtools: StoreEnhancer<AppState> =
17 window['devToolsExtension'] ?
18 window['devToolsExtension']() : f => f;
Not everyone who uses our app will necessarily have the Redux Devtools installed.
The code above will check for window.devToolsExtension, which is defined by
Redux Devtools and if it exists, we will use it. If it doesn't exist, we're just returning
an identity function (f => f) that will return whatever is passed to it.
Middleware is a term for a function that enhances the functionality of
another library. The Redux Devtools is one of many possible middleware
libraries for Redux. Redux supports lots of interesting middleware and it's
easy to write our own.
You can read more about Redux middleware here¹¹¹
¹¹⁰https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en
¹¹¹http://redux.js.org/docs/advanced/Middleware.html
Introduction to Redux with TS 413
In order to use this devtools we pass it as middleware to our Redux store:
code/redux/redux-chat/redux-counter/src/app/app.store.ts
20 export function createAppStore(): Store<AppState> {
21 return createStore<AppState>(
22 reducer,
23 compose(devtools)
24 );
25 }
Now whenever we dispatch an action and change our state, we can inspect it in our
browser!
Providing the Store
Now that we have the Redux core setup, let's turn our attention to our Angular
components. Let's create our top-level app component, AppComponent. This will be
the component we use to bootstrap Angular:
We're going to use the AppComponent as the root component. Remember that since
this is a Redux app, we need to make our store instance accessible everywhere in our
app. How should we do this? We'll use dependency injection (DI).
If you recall from the dependency injection chapter, when we want to make
sth available via DI, then we use the providers configuration to add it to
the list of providers in our NgModule.
When we provide sth to the DI system, we specify two things:
1. the token to use to refer this injectable dependency
2. the way to inject the dependency
Oftentimes if we want to provide a singleton service we might use the useClass
option as in:
Introduction to Redux with TS 414
1 { provide: SpotifyService, useClass: SpotifyService }
In the case above, we're using the class SpotifyService as the token in the DI system.
The useClass option tells Angular to create an instance of SpotifyService and reuse
that instance whenever the SpotifyService injection is requested (e.g. maintain a
Singleton).
One problem with us using this method is that we don't want Angular to create our
store - we did it ourselves above with createStore. We just want to use the store
we've already created.
To do this we'll use the useValue option of provide. We've done this before with
configurable values like API_URL:
1 { provide: API_URL, useValue: 'http://localhost/api' }
The one thing we have left to figure out is what token we want to use to inject. Our
store is of type Store<AppState>:
code/redux/redux-chat/redux-counter/src/app/app.store.ts
20 export function createAppStore(): Store<AppState> {
21 return createStore<AppState>(
22 reducer,
23 compose(devtools)
24 );
25 }
26
27 export const appStoreProviders = [
28 { provide: AppStore, useFactory: createAppStore }
29 ];
Store is an interface, not a class and, unfortunately, we can't use interfaces as a
dependency injection key.
If you're interested in why we can't use an interface as a DI key, it's because
TS interfaces are removed after compilation and not available at
runtime.
If you'd like to read more, see here¹¹², here¹¹³ and here¹¹⁴.
¹¹²http://stackoverflow.com/questions/32254952/binding-a-class-to-an-interface
¹¹³https://github.com/angular/angular/issues/135
¹¹⁴http://victorsavkin.com/post/126514197956/dependency-injection-in-angular-1-and-angular-2
Introduction to Redux with TS 415
This means we need to create our own token that we'll use for injecting the store.
Thankfully, Angular makes this easy to do. Let's create this token in it's own file so
that way we can import it from anywhere in our application;
code/redux/redux-chat/redux-counter/src/app/app.store.ts
14 export const AppStore = new InjectionToken('App.store');
Here we have created a const AppStore which uses the InjectionToken class from
Angular. InjectionToken is a better choice than injecting a string directly because it
helps us avoid collisions.
Now we can use this token AppStore with provide. Let's do that now.
Bootstrapping the App
Back in app.module.ts, let's create the NgModule we'll use to bootstrap our app:
code/redux/redux-chat/redux-counter/src/app/app.module.ts
1 import { BrowserModule } from '@angular/platform-browser';
2 import { NgModule } from '@angular/core';
3 import { FormsModule } from '@angular/forms';
4 import { HttpClientModule } from "@angular/common/http";
5
6 import { appStoreProviders } from './app.store';
7
8 import { AppComponent } from './app.component';
9
10 @NgModule({
11 declarations: [
12 AppComponent
13 ],
14 imports: [
15 BrowserModule,
16 FormsModule,
17 HttpClientModule
18 ],
19 providers: [ appStoreProviders ],
20 bootstrap: [AppComponent]
21 })
22 export class AppModule { }
Introduction to Redux with TS 416
Now we are able to get a reference to our Redux store anywhere in our app by
injecting AppStore. The place we need it most now is our AppComponent.
Notice that we exported the function appStoreProviders from
app.store.ts and then used that function in providers. Why not
use the { provide: ..., useFactory: ... } syntax directly? The answer
is related to AOT - if we want to ahead-of-time compile a provider that
uses a function, we must 1st export is as a function from another module.
The AppComponent
With our setup out of the way, we can start creating our component that actually
displays the counter to the user and provides buttons for the user to change the state.
imports
Let's start by looking at the imports:
code/redux/redux-chat/redux-counter/src/app/app.component.ts
1 import { Component, Inject } from '@angular/core';
2 import { Store } from 'redux';
3 import { AppStore } from './app.store';
4 import { AppState } from './app.state';
5 import * as CounterActions from './counter.actions';
We import Store from Redux as well as our injector token AppStore, which will get
us a reference to the singleton instance of our store. We also import the AppState
type, which helps us know the structure of the central state.
Lastly, we import our action creators with * as CounterActions. This syntax will
let us call CounterActions.increment() to create an INCREMENT action.
Introduction to Redux with TS 417
The template
Let's look at the template of our AppComponent.
In this chapter we are adding some style using the CSS framework
Bootstrap¹¹⁵
Counter App Template
code/redux/redux-chat/redux-counter/src/app/app.component.html
1 <div class="row">
2 <div class="col-sm-6 col-md-4">
3 <div class="thumbnail">
4 <div class="caption">
5 <h3>Counter</h3>
6 <p>Custom Store</p>
7
8 <p>
9 The counter value is:
10 <b>{{ counter }}</b>
11 </p>
¹¹⁵http://getbootstrap.com
Introduction to Redux with TS 418
12
13 <p>
14 <button (click)="increment()"
15 class="btn btn-primary">
16 Increment
17 </button>
18 <button (click)="decrement()"
19 class="btn btn-default">
20 Decrement
21 </button>
22 </p>
23 </div>
24 </div>
25 </div>
26 </div>
The three things to note here are that we're:
1. displaying the value of the counter in {{ counter }}
2. calling the increment() function in a button and
3. calling the decrement() function in a button.
The constructor
Remember that this component depends on the Store, so we need to inject it in the
constructor. This is how we use our custom AppStore token to inject a dependency:
code/redux/redux-chat/redux-counter/src/app/app.component.ts
1 import { Component, Inject } from '@angular/core';
2 import { Store } from 'redux';
3 import { AppStore } from './app.store';
4 import { AppState } from './app.state';
5 import * as CounterActions from './counter.actions';
6
7 @Component({
8 selector: 'app-root',
9 templateUrl: './app.component.html',
10 styleUrls: ['./app.component.css']
11 })
12 export class AppComponent {
Introduction to Redux with TS 419
13 counter: number;
14
15 constructor(@Inject(AppStore) private store: Store<AppState>) {
16 store.subscribe(() => this.readState());
17 this.readState();
18 }
19
20 readState() {
21 const state: AppState = this.store.getState() as AppState;
22 this.counter = state.counter;
23 }
24
25 increment() {
26 this.store.dispatch(CounterActions.increment());
27 }
28
29 decrement() {
30 this.store.dispatch(CounterActions.decrement());
31 }
32 }
We use the @Inject decorator to inject AppStore - notice that we define the type of
the variable store to Store<AppState>. Having a different injection token than the
type of the dependency injected is a little different than when we use the class as the
injection token (and Angular infers what to inject).
We set the store to an instance variable (with private store). Now that we
have the store we can listen for changes. Here we call store.subscribe and call
this.readState(), which we define below.
The store will call subscribe only when a new action is dispatched, so in this case
we need to make sure we manually call readState at least once to ensure that our
component gets the initial data.
The method readState reads from our store and updates this.counter to the current
value. Because this.counter is a property on this class and bound in the view,
Angular will detect when it changes and re-render this component.
We define two helper methods: increment and decrement, each of which dispatch
their respective actions to the store.
Introduction to Redux with TS 420
Putting It All Together
Try it out!
cd code/redux/redux-chat/redux-counter
npm install
npm start
open http://localhost:4200
Working Counter App
Congratulations! You've created your 1st Angular and Redux app!
What's Next
Now that we've built a basic app using Redux and Angular, we should try building
a more complicated app. When we build bigger apps we encounter new challenges
Introduction to Redux with TS 421
like:
• How do we combine reducers?
• How do we extract data from different branches of the state?
• How should we organize our Redux code?
In the next chapter, we'll build a chat app which will tackle all of these questions!
References
If you want to learn more about Redux, here are some good resources:
• Official Redux Website¹¹⁶
• This Video Tutorial by Redux's Creator¹¹⁷
• Real World Redux¹¹⁸ (presentation slides)
• The power of higher-order reducers¹¹⁹
To learn more about Redux and Angular checkout:
• angular2-redux¹²⁰
• ng2-redux¹²¹
• ngrx/store¹²²
Onward!
¹¹⁶http://redux.js.org/
¹¹⁷https://egghead.io/courses/getting-started-with-redux
¹¹⁸https://speakerdeck.com/chrisui/real-world-redux
¹¹⁹http://slides.com/omnidan/hor
¹²⁰https://github.com/InfomediaLtd/angular2-redux
¹²¹https://github.com/angular-redux/ng2-redux
¹²²https://github.com/ngrx/store
Intermediate Redux in Angular
In the last chapter we learned about Redux, the popular and elegant data architecture.
In that chapter, we built an extremely basic app that tied our Angular components
and the Redux store together.
In this chapter we're going to take on those ideas and build on them to create a more
sophisticated chat app.
Here's a screenshot of the app we're going to build:
Completed Chat Application
Intermediate Redux in Angular 423
Context For This Chapter
Earlier in this book we built a chat app using RxJS. We're going to be building that
same app again only this time with Redux. The point is for you to be able to compare
and contrast how the same app works with different data architecture strategies.
You are not required to have read the RxJS chapter in order to work through this one.
This chapter stands on its own with regard to the RxJS chapters. If you have read that
chapter, you'll be able to skim through some of the sections here where the code is
largely the same (Np. the data models themselves don't change much).
We do expect that you've read through the previous Redux chapter or at least have
some familiarity with Redux.
Chat App Overview
In this application we've provided a few bots you can chat with. Open up the code
and try it out:
cd code/redux/redux-chat
npm install
npm start
Now open your browser to http://localhost:4200.
Notice a few things about this application:
• You can click on the threads to chat with another person
• The bots will send you messages back, depending on their personality
• The unread message count in the top corner stays in sync with the number of
unread messages
Let's look at an overview of how this app is constructed. We have
• 3 top-level Angular Components
• 3 models
• and 2 reducers, with their respective action creators
Let's look at them one at a time.
Intermediate Redux in Angular 424
Components
The page is broken down into three top-level components:
Redux Chat Top-Level Components
• ChatNavBarComponent - contains the unread messages count
• ChatThreadsComponent - shows a clickable list of threads, along with the most
recent message and the conversation avatar
• ChatWindowComponent - shows the messages in the current thread with an input
box to send new messages
Models
This application also has three models:
Intermediate Redux in Angular 425
Redux Chat Models
• User - stores information about a chat participant
• Message - stores an individual message
• Thread - stores a collection of Messages as well as some data about the
conversation
Reducers
In this app, we have two reducers:
• UsersReducer - handles information about the current user
• ThreadsReducer - handles threads and their messages
Summary
At a high level our data architecture looks like this:
• All information about the users and threads (which hold messages) are contained
in our central store
• Components subscribe to changes in that store and display the appropriate data
(unread count, list of threads, the messages themselves
• When the user sends a message, our components dispatch an action to the store
In the rest of this chapter, we're going to go in-depth on how we implement this using
Angular and Redux. We'll start by implementing our models, then look at how we
create our app state and reducers and then finally we'll implement the Components.
Intermediate Redux in Angular 426
Implementing the Models
Let's start with the easy stuff and take a look at the models.
We're going to be specifying each of our model definitions as interfaces. This isn't
a requirement and you're free to use more elaborate objects if you wish. That said,
objects with methods that mutate their internal state can break the functional model
that we're striving for.
That is, all mutations to our app state should only be made by the reducers - the
objects in the state should be immutable themselves.
So by defining an interface for our models,
1. we're able to ensure that the objects we're working with conform to an expected
format at compile time and
2. we don't run the risk of someone accidentally adding a method to the model
object that would work in an unexpected way.
User
Our User interface has an id, name and avatarSrc.
code/redux/redux-chat/src/app/user/user.model.ts
1 /**
2 * A User represents an agent that sends messages
3 */
4 export interface User {
5 id: string;
6 name: string;
7 avatarSrc: string;
8 isClient?: boolean;
9 }
We also have a boolean isClient (the question mark indicates that this field is
optional). We will set this value to true for the User that represents the client, the
person using the app.
Intermediate Redux in Angular 427
Thread
Similarly, Thread is also a TS interface:
code/redux/redux-chat/src/app/thread/thread.model.ts
1 import { Message } from '../message/message.model';
2
3 /**
4 * Thread represents a group of Users exchanging Messages
5 */
6 export interface Thread {
7 id: string;
8 name: string;
9 avatarSrc: string;
10 messages: Message[];
11 }
We store the id of the Thread, the name and the current avatarSrc. We also expect
an array of Messages in the messages field.
Message
Message is our third and final model interface:
code/redux/redux-chat/src/app/message/message.model.ts
1 import { User } from '../user/user.model';
2 import { Thread } from '../thread/thread.model';
3
4 /**
5 * Message represents one message being sent in a Thread
6 */
7 export interface Message {
8 id?: string;
9 sentAt?: Date;
10 isRead?: boolean;
11 thread?: Thread;
12 author: User;
13 text: string;
14 }
Intermediate Redux in Angular 428
Each message has:
• id - the id of the message
• sentAt - when the message was sent
• isRead - a boolean indicating that the message was read
• author - the User who wrote this message
• text - the text of the message
• thread - a reference to the containing Thread
App State
Now that we have our models, let's talk about the shape of our central state. In the
previous chapter, our central state was a single object with the key counter which
had the value of a number. This app, however, is more complicated.
Here's the 1st part of our app state:
code/redux/redux-chat/src/app/app.reducer.ts
18 export interface AppState {
19 users: UsersState;
20 threads: ThreadsState;
21 }
Our AppState is also an interface and it has two top level keys: users and threads
- these are defined by two more interfaces UsersState and ThreadsState, which are
defined in their respective reducers.
A Word on Code Layout
This is a common pattern we use in Redux apps: the top level state has a toplevel
key for each reducer. In our app we're going to keep this top-level reducer
in app.reducer.ts.
Each reducer will have it's own file. In that file we'll store:
• The interface that describes that branch of the state tree
Intermediate Redux in Angular 429
• The value of the initial state, for that branch of the state tree
• The reducer itself
• Any selectors that query that branch of the state tree - we haven't talked about
selectors yet, but we will soon.
The reason we keep all of these different things together is because they all deal with
the structure of this branch of the state tree. By putting these things in the same file
it's very easy to refactor everything at the same time.
You're free to have multiple layers of nesting, if you so desire. It's a nice way to break
up large modules in your app.
The Root Reducer
Since we're talking about how to split up reducers, let's look at our root reducer now:
code/redux/redux-chat/src/app/app.reducer.ts
18 export interface AppState {
19 users: UsersState;
20 threads: ThreadsState;
21 }
22
23 const rootReducer: Reducer<AppState> = combineReducers<AppState>({
24 users: UsersReducer,
25 threads: ThreadsReducer
26 });
27
28 export default rootReducer;
Notice the symmetry here - our UsersReducer will operate on the users key, which is
of type UsersState and our ThreadsReducer will operate on the threads key, which
is of type ThreadsState.
This is made possible by the combineReducers function which takes a map of keys
and reducers and returns a new reducer that operates appropriately on those keys.
Of course we haven't finished looking at the structure of our AppState yet, so let's
do that now.
Intermediate Redux in Angular 430
The UsersState
Our UsersState holds a reference to the currentUser.
code/redux/redux-chat/src/app/user/users.reducer.ts
18 export interface UsersState {
19 currentUser: User;
20 };
21
22 const initialState: UsersState = {
23 currentUser: null
24 };
You could imagine that this branch of the state tree could hold information about
all of the users, when they were last seen, their idle time, etc. But for now this will
suffice.
We'll use initialState in our reducer when we define it below, but for now we're
just going to set the current user to null.
The ThreadsState
Let's look at the ThreadsState:
code/redux/redux-chat/src/app/thread/threads.reducer.ts
25 export interface ThreadsEntities {
26 [id: string]: Thread;
27 }
28
29 export interface ThreadsState {
30 ids: string[];
31 entities: ThreadsEntities;
32 currentThreadId?: string;
33 };
34
35 const initialState: ThreadsState = {
36 ids: [],
37 currentThreadId: null,
38 entities: {}
39 };
Intermediate Redux in Angular 431
We start by defining an interface called ThreadsEntities which is a map of thread
ids to Threads. The idea is that we'll be able to look up any thread by id in this map.
In the ThreadsState we're also storing an array of the ids. This will store the list of
possible ids that we might find in entities.
This strategy is used by the commonly-used library normalizr¹²³. The idea
is that when we standardize how we store entities in our Redux state,
we're able to build helper libraries and it's clearer to work with. Instead
of wondering what the format is for each tree of the state, when we use
normalizr a lot of the choices have been made for us and we're able to
work more quickly.
I've opted not to teach normalizr in this chapter because we're learning so
many other things. That said, I would be very likely to use normalizr in
my production applications.
That said, normalizr is totally optional - nothing major changes in our app
by not using it.
If you'd like to learn how to use normalizr, checkout the official docs¹²⁴,
this blog post¹²⁵ and the thread referenced by Redux creator Dan Abramov
here¹²⁶
We store the currently viewed thread in currentThreadId - the idea here is that we
want to know which thread the user is currently looking at.
We set our initialState to "empty" values.
Visualizing Our AppState
Redux Devtools provides us with a "Chart" view that lets us inspect the state of our
app. Here's what mine looks like after being booted with all of the demo data:
¹²³https://github.com/paularmstrong/normalizr
¹²⁴https://github.com/paularmstrong/normalizr
¹²⁵https://medium.com/@mcowpercoles/using-normalizr-js-in-a-redux-store-96ab33991369#.l8ur7ipu6
¹²⁶https://twitter.com/dan_abramov/status/663032263702106112
Intermediate Redux in Angular 432
Redux Chat State Chart
What's neat is that we can hover over an individual node and see the attributes of
that piece of data:
Intermediate Redux in Angular 433
Inspecting the current thread
Building the Reducers (and Action Creators)
Now that we have our central state, we can start changing it using our reducers!
Since reducers handle actions, we need to know the format of our actions in our
reducer. So let's build our action creators at the same time we build our reducers
Set Current User Action Creators
The UsersState stores the current user. This means we need an action to set the
current user. We're going to keep our actions in the actions folder and name the
Intermediate Redux in Angular 434
actions to match their corresponding reducer, in this case UserActions.
code/redux/redux-chat/src/app/user/user.actions.ts
20 export const SET_CURRENT_USER = '[User] Set Current';
21 export interface SetCurrentUserAction extends Action {
22 user: User;
23 }
24 export const setCurrentUser: ActionCreator<SetCurrentUserAction> =
25 (user) => ({
26 type: SET_CURRENT_USER,
27 user: user
28 });
Here we define the const SET_CURRENT_USER, which we'll use to switch on in our
reducer.
We also define a new subinterface SetCurrentUserAction which extends Action to
add a user property. We'll use the user property to indicate which user we want to
make the current user.
The function setCurrentUser is our proper action creator function. It takes user as
an argument and returns a SetCurrentUserAction which we can give to our reducer.
UsersReducer - Set Current User
Now we turn our attention to our UsersReducer:
code/redux/redux-chat/src/app/user/users.reducer.ts
26 export const UsersReducer =
27 function(state: UsersState = initialState, action: Action): UsersState {
28 switch (action.type) {
29 case UserActions.SET_CURRENT_USER:
30 const user: User = (<UserActions.SetCurrentUserAction>action).user;
31 return {
32 currentUser: user
33 };
34 default:
35 return state;
36 }
37 };
Intermediate Redux in Angular 435
Our UsersReducer takes a UsersState as the 1st argument. Notice that this isn't the
AppState! Our "child reducer" only works with it's branch of the state tree.
Our UsersReducer, like all reducers, returns a new state, in this case it is of type
UsersState.
Next we switch on the action.type and we handle the UserActions.SET_CURRENT_-
USER.
In order to set the current user, we need to get the user from the incoming action.
To do this, we 1st cast the action to UserActions.SetCurrentUserAction and then
we read the .user field.
It might seem a little weird that we originally created a
SetCurrentUserAction but then now we switch on a type string
instead of using the type directly.
Indeed, we are fighting TS a little here. We lose interface metadata
when the TS is compiled to JS. We could instead try some
sort of reflection (through decorator metadata, or looking at a constructor
etc.).
While down-casting our SetCurrentUserAction to an Action on dispatch
and then re-casting is a bit ugly, it's a straightforward and portable way to
handle this "polymorphic dispatch" for this app.
We need to return a new UsersState. Since UsersState only has one key, we return
an object with the currentUser set to the incoming action's user.
Thread and Messages Overview
The core of our application is messages in threads. There are three actions we need
to support:
1. Adding a new thread to the state
2. Adding messages to a thread
3. Selecting a thread
Let's start by creating a new thread
Intermediate Redux in Angular 436
Adding a New Thread Action Creators
Here's the action creator for adding a new Thread to our state:
code/redux/redux-chat/src/app/thread/thread.actions.ts
22 export const ADD_THREAD = '[Thread] Add';
23 export interface AddThreadAction extends Action {
24 thread: Thread;
25 }
26 export const addThread: ActionCreator<AddThreadAction> =
27 (thread) => ({
28 type: ADD_THREAD,
29 thread: thread
30 });
Notice that this is structurally very similar to our previous action creator. We define
a const ADD_THREAD that we can switch on, a custom Action and an action creator
addThread which generates the Action.
Notice that we don't initialize the Thread itself here - the Thread is accepted as an
argument.
Adding a New Thread Reducer
Now let's start our ThreadsReducer by handling ADD_THREAD:
code/redux/redux-chat/src/app/thread/threads.reducer.ts
45 export const ThreadsReducer =
46 function(state: ThreadsState = initialState, action: Action): ThreadsState {
47 switch (action.type) {
48
49 // Adds a new Thread to the list of entities
50 case ThreadActions.ADD_THREAD: {
51 const thread = (<ThreadActions.AddThreadAction>action).thread;
52
53 if (state.ids.includes(thread.id)) {
54 return state;
55 }
56
57 return {
Intermediate Redux in Angular 437
58 ids: [ ...state.ids, thread.id ],
59 currentThreadId: state.currentThreadId,
60 entities: Object.assign({}, state.entities, {
61 [thread.id]: thread
62 })
63 };
64 }
65
66 // Adds a new Message to a particular Thread
Our ThreadsReducer handles the ThreadsState. When we handle the ADD_THREAD
action, we cast the action object back into a ThreadActions.AddThreadAction and
then pull the Thread out.
Next we check to see if this new thread.id already appears in the list of state.ids.
If it does, then we don't make any changes, but instead return the current state.
However if this thread is new, then we need to add it to our current state.
Remember when we create a new ThreadsState we need to take care to not mutate
our old state. This looks more complicated than any state we've done so far, but it's
not very different in principle.
We start by adding our thread.id to the ids array. Here we're using the ES6 spread
operator (...) to indicate that we want to put all of the existing state.ids into this
new array and then append thread.id to the end.
currentThreadId does not change when we add a new thread, so we return the old
state.currentThreadId for this field.
For entities, remember that it is an object where the key is the string id of each
thread and the value is the thread itself. We're using Object.assign here to create a
new object that merges the old state.entities with our newly added thread into a
new object.
Intermediate Redux in Angular 438
You might be kind of tired of meticulously copying these objects when we
need to make changes. That's a common response! In fact, it's easy to make
mutations here by accident.
This is why Immutable.js¹²⁷ was written. Immutable.js is often used with
Redux for this purpose. When we use Immutable, these careful updates are
handled for us.
I'd encourage you to take a look at Immutable.js and see if it is a good fit
for your reducers.
Now we can add new threads to our central state!
Adding New Messages Action Creators
Now that we have threads we can start adding messages to them.
Let's define a new action for adding messages:
code/redux/redux-chat/src/app/thread/thread.actions.ts
32 export const ADD_MESSAGE = '[Thread] Add Message';
33 export interface AddMessageAction extends Action {
34 thread: Thread;
35 message: Message;
36 }
The AddMessageAction adds a Message to a Thread.
Here's the action creator for adding a message:
¹²⁷https://facebook.github.io/immutable-js/
Intermediate Redux in Angular 439
code/redux/redux-chat/src/app/thread/thread.actions.ts
37 export const addMessage: ActionCreator<AddMessageAction> =
38 (thread: Thread, messageArgs: Message): AddMessageAction => {
39 const defaults = {
40 id: uuid(),
41 sentAt: new Date(),
42 isRead: false,
43 thread: thread
44 };
45 const message: Message = Object.assign({}, defaults, messageArgs);
46
47 return {
48 type: ADD_MESSAGE,
49 thread: thread,
50 message: message
51 };
52 };
The addMessage action creator accepts a thread and an object we use for crafting
the message. Notice here that we keep a list of defaults. The idea here is that we
want to encapsulate creating an id, setting the timestamp and setting the isRead
status. Someone who wants to send a message shouldn't have to worry about how
the UUIDs are formed, for instance.
That said, maybe the client using this library crafted the message beforehand and if
they send a message with an existing id, we want to keep it. To enable this default
behavior we merge the messageArgs into the defaults and copy those values to a
new object.
Lastly we return the ADD_MESSAGE action with the thread and new message.
Adding A New Message Reducer
Now we will add our ADD_MESSAGE handler to our ThreadsReducer. When a new
message is added, we need to take the thread and add the message to it.
There is one tricky thing we need to handle that may not be obvious at this point: if
the thread is the "current thread" we need to mark this message as read.
Intermediate Redux in Angular 440
The user will always have one thread that is the "current thread" that they're looking
at. We're going to say that if a new message is added to the current thread, then it's
automatically marked as read.
code/redux/redux-chat/src/app/thread/threads.reducer.ts
67 case ThreadActions.ADD_MESSAGE: {
68 const thread = (<ThreadActions.AddMessageAction>action).thread;
69 const message = (<ThreadActions.AddMessageAction>action).message;
70
71 // special case: if the message being added is in the current thread, then
72 // mark it as read
73 const isRead = message.thread.id === state.currentThreadId ?
74 true : message.isRead;
75 const newMessage = Object.assign({}, message, { isRead: isRead });
76
77 // grab the old thread from entities
78 const oldThread = state.entities[thread.id];
79
80 // create a new thread which has our newMessage
81 const newThread = Object.assign({}, oldThread, {
82 messages: [...oldThread.messages, newMessage]
83 });
84
85 return {
86 ids: state.ids, // unchanged
87 currentThreadId: state.currentThreadId, // unchanged
88 entities: Object.assign({}, state.entities, {
89 [thread.id]: newThread
90 })
91 };
92 }
93
94 // Select a particular thread in the UI
The code is a bit long because we're being careful not to mutate the original thread,
but it is not much different than what we've done so far in principle.
We start by extracting the thread and message.
Next we mark the message as read, if its part of the "current thread" (we'll look at
how to set the current thread next).
Intermediate Redux in Angular 441
Then we grab the oldThread and create a newThread which has the newMessage
appended on to the old messages.
Finally we return the new ThreadsState. The current list of thread ids and the
currentThreadId are unchanged by adding a message, so we pass the old values
here. The only thing we change is that we update entities with our newThread.
Now let's implement the last part of our data backbone: selecting a thread.
Selecting A Thread Action Creators
Our user can have multiple chat sessions in progress at the same time. However, we
only have one chat window (where the user can read and send messages). When the
user clicks on a thread, we want to show that thread's messages in the chat window.
Selecting A Thread
We need to keep track of which thread is the currently selected thread. To do that,
we'll use the currentThreadId property in the ThreadsState.
Let's create the actions for this:
Intermediate Redux in Angular 442
code/redux/redux-chat/src/app/thread/thread.actions.ts
54 export const SELECT_THREAD = '[Thread] Select';
55 export interface SelectThreadAction extends Action {
56 thread: Thread;
57 }
58 export const selectThread: ActionCreator<SelectThreadAction> =
59 (thread) => ({
60 type: SELECT_THREAD,
61 thread: thread
62 });
There's nothing conceptually new in this action: we've got a new type of SELECT_-
THREAD and we pass the Thread that we're selecting as an argument.
Selecting A Thread Reducer
To select a thread we need to do two things:
1. set currentThreadId to the selected thread's id
2. mark all messages in that thread as read
Here's the code for that reducer:
code/redux/redux-chat/src/app/thread/threads.reducer.ts
95 case ThreadActions.SELECT_THREAD: {
96 const thread = (<ThreadActions.SelectThreadAction>action).thread;
97 const oldThread = state.entities[thread.id];
98
99 // mark the messages as read
100 const newMessages = oldThread.messages.map(
101 (message) => Object.assign({}, message, { isRead: true }));
102
103 // give them to this new thread
104 const newThread = Object.assign({}, oldThread, {
105 messages: newMessages
106 });
107
108 return {
109 ids: state.ids,
Intermediate Redux in Angular 443
110 currentThreadId: thread.id,
111 entities: Object.assign({}, state.entities, {
112 [thread.id]: newThread
113 })
114 };
115 }
116
117 default:
118 return state;
119 }
120 };
We start by getting the thread-to-select and then using that thread.id to get the
current Thread that exists in state to get the values.
This maneuver is a bit defensive. Why not just use the thread that is passed
in? That might be the right design decision for some apps. In this case we
protect against some external mutation of thread by reading the last known
values of that thread in state.entities.
Next we create a copy of all of the old messages and set them as isRead: true. Then
we assign those new read messages to newThread.
Finally we return our new ThreadsState.
Reducers Summary
We did it! Above is everything we need for the backbone of our data architecture.
To recap, we have a UsersReducer which maintains the current user. We have a
ThreadsReducer which manages:
• The list of threads
• The messages in those threads
• The currently selected thread
We can derive everything else that we need (e.g. the unread count) from these pieces
of data.
Now we need to hook them up to our components!
Intermediate Redux in Angular 444
Building the Angular Chat App
As we mentioned earlier in the chapter, the page is broken down into three top-level
components:
Redux Chat Top-Level Components
• ChatNavBarComponent - contains the unread messages count
• ChatThreadsComponent - shows a clickable list of threads, along with the most
recent message and the conversation avatar
• ChatWindowComponent - shows the messages in the current thread with an input
box to send new messages
We're going to bootstrap our app much like we did in the last chapter. We're going
to initialize our Redux store at the top of the app and provide it via Angular's
Intermediate Redux in Angular 445
dependency injection system (take a look at the previous chapter if this looks
unfamiliar):
code/redux/redux-chat/src/app/app.store.ts
1 import { InjectionToken } from '@angular/core';
2 import {
3 createStore,
4 Store,
5 compose,
6 StoreEnhancer
7 } from 'redux';
8
9 import {
10 AppState,
11 default as reducer
12 } from './app.reducer';
13
14 export const AppStore = new InjectionToken('App.store');
15
16 const devtools: StoreEnhancer<AppState> =
17 window['devToolsExtension'] ?
18 window['devToolsExtension']() : f => f;
19
20 export function createAppStore(): Store<AppState> {
21 return createStore<AppState>(
22 reducer,
23 compose(devtools)
24 );
25 }
26
27 export const appStoreProviders = [
28 { provide: AppStore, useFactory: createAppStore }
29 ];
The top-level AppComponent
Our AppComponent component is the top-level component. It doesn't do much other
than render the ChatPage.
Intermediate Redux in Angular 446
code/redux/redux-chat/src/app/app.component.ts
1 import { Component, Inject } from '@angular/core';
2 import * as Redux from 'redux';
3
4 import { AppStore } from './app.store';
5 import { AppState } from './app.reducer';
6 import { ChatExampleData } from './data/chat-example-data';
7
8 @Component({
9 selector: 'app-root',
10 templateUrl: './app.component.html',
11 styleUrls: ['./app.component.css']
12 })
13 export class AppComponent {
14 constructor(@Inject(AppStore) private store: Redux.Store<AppState>) {
15 ChatExampleData(store);
16 }
17 }
and the template:
code/redux/redux-chat/src/app/app.component.html
1 <div>
2 <chat-page></chat-page>
3 </div>
For this app the bots operate on data on the client and are not connected
to a server. The function ChatExampleData() sets up the initial data for the
app. We won't be covering this code in detail in the book, so feel free to
look at the code on disk if you want to learn more about how it works.
We're not using a router in this app, but if we were, we would put it here at the top
level of the app. For now, we're going to create a ChatPage which will render the bulk
of our app.
We don't have any other pages in this app, but it's a good idea to give each page it's
own component in case we add some in the future.
Intermediate Redux in Angular 447
The ChatPage
Our chat page renders our three main components:
• ChatNavBarComponent
• ChatThreadsComponent and
• ChatWindowComponent
Here it is in code:
code/redux/redux-chat/src/app/chat-page/chat-page.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'chat-page',
5 templateUrl: './chat-page.component.html',
6 styleUrls: ['./chat-page.component.css']
7 })
8 export class ChatPageComponent implements OnInit {
9 constructor() { }
10 ngOnInit() { }
11 }
and the template:
code/redux/redux-chat/src/app/chat-page/chat-page.component.html
1 <div>
2 <chat-nav-bar></chat-nav-bar>
3 <div class="container">
4 <chat-threads></chat-threads>
5 <chat-window></chat-window>
6 </div>
7 </div>
For this app we are using a design pattern called container components and these
three components are all container components. Let's talk about what that means.
Intermediate Redux in Angular 448
Container vs. Presentational Components
It is hard to reason about our apps if there is data spread throughout all of our
components. However, our apps are dynamic - they need to be populated with
runtime data and they need to be responsive to user interaction.
One of the patterns that has emerged in managing this tension is the idea of
presentational vs. container components. The idea is this:
1. You want to minimize the number of components which interact with outside
data sources. (e.g. APIs, the Redux Store, Cookies etc.)
2. Therefore deliberately put data access into "container" components and
3. Require purely 'functional' presentation components to have all of their properties
(inputs and outputs) managed by container components.
The great thing about this design is that presentational components are predictable.
They're reusable because they don't make assumptions about your overall dataarchitecture,
they only give requirements for their own use.
But even beyond reuse, they're predictable. Given the same inputs, they always
return the same outputs (e.g. render the same way).
If you squint, you can see that the philosophy that requires reducers to
be pure functions is the same that requires presentational components be
'pure components'
It would be great if our entire app could be all presentational components, but of
course, the real world has messy, changing data. So we try to put this complexity of
adapting our real-world data into our container components.
Intermediate Redux in Angular 449
If you're an advanced programmer you may see that there is a loose
analogy between MVC and container/presentation components. That is,
the presentational component is sort of a "view" of data that is passed in.
A container component is sort of a "controller" in that it takes the "model"
(the data from the rest of the app) and adapts it for the presentational
components.
That said, if you haven't been programming very long, take this analogy
with a grain of salt as Angular components are already a view and a
controller themselves.
In our app the container components are going to be the components which interact
with the store. This means our container components will be anything that:
1. Reads data from the store
2. Subscribes to the store for changes
3. Dispatches actions to the store
Our three main components are container components and anything below them
will be presentational (i.e. functional / pure / not interact with the store).
Let's build our 1st container component, the nav bar.
Building the ChatNavBarComponent
In the nav bar we'll show an unread messages count to the user.
The Unread Count in the ChatNavBarComponent
The best way to try out the unread messages count is to use the "Waiting
Bot". If you haven't already, try sending the message '3' to the Waiting
Bot and then switch to another window. The Waiting Bot will then wait 3
seconds before sending you a message and you will see the unread messages
counter increment.
Intermediate Redux in Angular 450
Let's look at the component code first:
code/redux/redux-chat/src/app/chat-nav-bar/chat-nav-bar.component.ts
1 import { Component, Inject } from '@angular/core';
2 import { AppStore } from '../app.store';
3 import * as Redux from 'redux';
4 import {
5 AppState,
6 getUnreadMessagesCount
7 } from '../app.reducer';
8
9 @Component({
10 selector: 'chat-nav-bar',
11 templateUrl: './chat-nav-bar.component.html',
12 styleUrls: ['./chat-nav-bar.component.css']
13 })
14 export class ChatNavBarComponent {
15 unreadMessagesCount: number;
16
17 constructor(@Inject(AppStore) private store: Redux.Store<AppState>) {
18 store.subscribe(() => this.updateState());
19 this.updateState();
20 }
21
22 updateState() {
23 this.unreadMessagesCount = getUnreadMessagesCount(this.store.getState());
24 }
25 }
and the template:
code/redux/redux-chat/src/app/chat-nav-bar/chat-nav-bar.component.html
1 <nav class="navbar navbar-default">
2 <div class="container-fluid">
3 <div class="navbar-header">
4 <a class="navbar-brand" href="https://ng-book.com/2">
5 <img src="assets/images/logos/ng-book-2-minibook.png"/>
6 ng-book
7 </a>
8 </div>
9 <p class="navbar-text navbar-right">
10 <button class="btn btn-primary" type="button">
Intermediate Redux in Angular 451
11 Messages <span class="badge">{{ unreadMessagesCount }}</span>
12 </button>
13 </p>
14 </div>
15 </nav>
Our template gives us the DOM structure and CSS necessary for rending a nav bar
(these CSS-classes come from the CSS framework Bootstrap).
The only variable we're showing in this template is unreadMessagesCount.
Our ChatNavBarComponent has unreadMessagesCount as an instance variable. This
number will be set to the sum of unread messages in all threads.
Notice in our constructor we do three things:
1. Inject our store
2. Subscribe to any changes in the store
3. Call this.updateState()
We call this.updateState() after subscribe because we want to make sure this
component is initialized with the most recent data. subscribe will only be called if
sth changes after this component is initialized.
updateState() is the most interesting function - we set unreadMessagesCount to the
value of the function getUnreadMessagesCount. What is getUnreadMessagesCount
and where did it come from?
getUnreadMessagesCount is a new concept called selectors.
Redux Selectors
Thinking about our AppState, how might we go about getting the unread messages
count? How about sth like this:
Intermediate Redux in Angular 452
// get the state
let state = this.store.getState();
// get the threads state
let threadsState = state.threads;
// get the entities from the threads
let threadsEntities = threadsState.entities;
// get all of the threads from state
let allThreads = Object.keys(threadsEntities)
.map((threadId) => entities[threadId]);
// iterate over all threads and ...
let unreadCount = allThreads.reduce(
(unreadCount: number, thread: Thread) => {
// foreach message in that thread
thread.messages.forEach((message: Message) => {
if (!message.isRead) {
// if it's unread, increment unread count
++unreadCount;
}
});
return unreadCount;
},
0);
Should we put this logic in the ChatNavBarComponent? There's two problems with
that approach:
1. This chunk of code reaches deep into our AppState. A better approach would
be to co-locate this logic next to where the state itself is written.
2. What if we need the unread count somewhere else in the app? How could we
share this logic?
Solving these problems is the idea behind selectors.
Selectors are functions that take a part of the state and return a value.
Let's take a look at how to make a few selectors.
Intermediate Redux in Angular 453
Threads Selectors
Let's start with an easy one. Say we have our AppState and we want to get the
ThreadsState:
code/redux/redux-chat/src/app/thread/threads.reducer.ts
122 export const getThreadsState = (state): ThreadsState => state.threads;
Pretty easy, right? Here we're saying, given the top-level AppState, we can find the
ThreadsState at state.threads.
Let's say that we want to get the current thread. We could do it like this:
const getCurrentThread = (state: AppState): Thread => {
let currentThreadId = state.threads.currentThreadId;
return state.threads.entities[currentThreadId];
}
For this small example, this selector works fine. But it's worth thinking about how we
can make our selectors maintainable as the app grows. It would be nice if we could
use selectors to query other selectors. It also would be nice to be able to specify a
selector that has multiple selectors as a dependency.
This is what the reselect¹²⁸ library provides. With reselect we can create small,
focused selectors and then combine them together into bigger functionality.
Let's look at how we will get the current thread using createSelector from reselect.
code/redux/redux-chat/src/app/thread/threads.reducer.ts
124 export const getThreadsEntities = createSelector(
125 getThreadsState,
126 ( state: ThreadsState ) => state.entities );
We start by writing getThreadsEntities. getThreadsEntities uses createSelector
and passes two arguments:
1. getThreadsState, the selector we defined above and
¹²⁸https://github.com/reactjs/reselect#createselectorinputselectors--inputselectors-resultfunc
Intermediate Redux in Angular 454
2. A callback function which will receive the value of the selector in #1 and return
the value we want to select.
This might seem like a lot of overhead to call state.entities, but it sets us up for
a much more maintainable selectors down the line. Let's look at getCurrentThread
using createSelector:
code/redux/redux-chat/src/app/thread/threads.reducer.ts
147 export const getCurrentThread = createSelector(
148 getThreadsEntities,
149 getThreadsState,
150 ( entities: ThreadsEntities, state: ThreadsState ) =>
151 entities[state.currentThreadId] );
Notice here that we're citing two selectors as dependencies: getThreadsEntities and
getThreadsState - when these selectors resolve they become the arguments to the
callback function. We can then combine them together to return the selected thread.
Unread Messages Count Selector
Now that we understand how selectors work, let's create a selector that will
get the number of unread messages. If you look at our 1st attempt at unread
messages above, we can see that each variable could instead become it's own selector
(getThreadsState, getThreadsEntities, etc.)
Here's a selector that will get all Threads:
code/redux/redux-chat/src/app/thread/threads.reducer.ts
128 export const getAllThreads = createSelector(
129 getThreadsEntities,
130 ( entities: ThreadsEntities ) => Object.keys(entities)
131 .map((threadId) => entities[threadId]));
And then given all of the threads, we can get the sum of the unread messages over
all threads:
Intermediate Redux in Angular 455
code/redux/redux-chat/src/app/thread/threads.reducer.ts
133 export const getUnreadMessagesCount = createSelector(
134 getAllThreads,
135 ( threads: Thread[] ) => threads.reduce(
136 (unreadCount: number, thread: Thread) => {
137 thread.messages.forEach((message: Message) => {
138 if (!message.isRead) {
139 ++unreadCount;
140 }
141 });
142 return unreadCount;
143 },
144 0));
Now that we have this selector, we can use it to get the number of unread messages
in our ChatNavBarComponent (and anywhere else in our app where we might need
it).
Building the ChatThreadsComponent
Next let's build our thread list in the ChatThreadsComponent.
Time Ordered List of Threads
Intermediate Redux in Angular 456
ChatThreadsComponent Controller
Let's take a look at our component controller ChatThreadsComponent before we look
at the template:
code/redux/redux-chat/src/app/chat-threads/chat-threads.component.ts
1 import {
2 Component,
3 OnInit,
4 Inject
5 } from '@angular/core';
6 import { AppStore } from '../app.store';
7 import * as Redux from 'redux';
8 import {
9 Thread
10 } from '../thread/thread.model';
11 import * as ThreadActions from '../thread/thread.actions';
12 import {
13 AppState,
14 getCurrentThread,
15 getAllThreads
16 } from '../app.reducer';
17
18 @Component({
19 selector: 'chat-threads',
20 templateUrl: './chat-threads.component.html',
21 styleUrls: ['./chat-threads.component.css']
22 })
23 export class ChatThreadsComponent {
24 threads: Thread[];
25 currentThreadId: string;
26
27 constructor(@Inject(AppStore) private store: Redux.Store<AppState>) {
28 store.subscribe(() => this.updateState());
29 this.updateState();
30 }
31
32 updateState() {
33 const state = this.store.getState();
34
35 // Store the threads list
36 this.threads = getAllThreads(state);
37
Intermediate Redux in Angular 457
38 // We want to mark the current thread as selected,
39 // so we store the currentThreadId as a value
40 this.currentThreadId = getCurrentThread(state).id;
41 }
42
43 handleThreadClicked(thread: Thread) {
44 this.store.dispatch(ThreadActions.selectThread(thread));
45 }
46 }
We're storing two instance variables on this component:
• threads - the list of Threads
• currentThreadId - the current thread (conversation) that the user is participating
in
In our constructor we keep a reference to the Redux store and subscribe to updates.
When the store changes, we call updateState().
updateState() keeps our instance variables in sync with the Redux store. Notice that
we're using two selectors:
• getAllThreads and
• getCurrentThread
which keep their respective instance variables up to date.
The one new idea we've added is an event handler: handleThreadClicked. handleThreadClicked
will dispatch the selectThread action. The idea here is that when
a thread is clicked on, we'll tell our store to set this new thread as the selected thread
and the rest of the application should update in turn.
ChatThreadsComponent template
Let's look at the ChatThreadsComponent template and its configuration:
Intermediate Redux in Angular 458
code/redux/redux-chat/src/app/chat-threads/chat-threads.component.html
1 <!-- conversations -->
2 <div class="row">
3 <div class="conversation-wrap">
4 <chat-thread
5 *ngFor="let thread of threads"
6 [thread]="thread"
7 [selected]="thread.id === currentThreadId"
8 (onThreadSelected)="handleThreadClicked($event)">
9 </chat-thread>
10 </div>
11 </div>
In our template we're using ngFor to iterate over our threads. We're using a new
directive to render the individual threads called ChatThreadComponent.
ChatThreadComponent is a presentational component. We won't be able to access
the store in ChatThreadComponent, neither for fetching data nor dispatching actions.
Instead, we're going to pass everything we need to this component through inputs
and handle any interaction through outputs.
We'll look at the implementation of ChatThreadComponent next, but look at the inputs
and outputs we have in this template first.
• We're sending the input [thread] with the individual thread
• On the input [selected] we're passing a boolean which indicates if this thread
(thread.id) is the "current" thread (currentThreadId)
• If the thread is clicked, we will emit the output event (onThreadSelected)
- when this happens we'll call handleThreadClicked() (which dispatches a
thread selected event to the store).
Let's dig in to the ChatThreadComponent.
The Single ChatThreadComponent
The ChatThreadComponent will be used to display a single thread in the list of
threads. Remember that ChatThreadComponent is a presentational component - it
doesn't manipulate any data that isn't given to it directly.
Here's the component controller code:
Intermediate Redux in Angular 459
code/redux/redux-chat/src/app/chat-thread/chat-thread.component.ts
1 import {
2 Component,
3 OnInit,
4 Input,
5 Output,
6 EventEmitter
7 } from '@angular/core';
8 import { Thread } from '../thread/thread.model';
9
10 @Component({
11 selector: 'chat-thread',
12 templateUrl: './chat-thread.component.html',
13 styleUrls: ['./chat-thread.component.css']
14 })
15 export class ChatThreadComponent implements OnInit {
16 @Input() thread: Thread;
17 @Input() selected: boolean;
18 @Output() onThreadSelected: EventEmitter<Thread>;
19
20 constructor() {
21 this.onThreadSelected = new EventEmitter<Thread>();
22 }
23
24 ngOnInit() { }
25
26 clicked(event: any): void {
27 this.onThreadSelected.emit(this.thread);
28 event.preventDefault();
29 }
30 }
The main thing to look at here is the onThreadSelected EventEmitter. If you haven't
used EventEmitters much, the idea is that it's an implementation of the observer
pattern. We use it as the "output channel" for this component - when we want to
send data we call onThreadSelected.emit and pass whatever data we want along
with it.
In this case, we want to emit the current thread as the argument to the EventEmitter.
When this element is clicked, we will call onThreadSelected.emit(this.thread)
which will trigger the callback in our parent (ChatThreadsComponent) component.
Intermediate Redux in Angular 460
Here is where we specify our @Input()s of thread and selected, as well as the
@Output() of onThreadSelected.
ChatThreadComponent template
Here's the code for our @Component decorator and template:
code/redux/redux-chat/src/app/chat-thread/chat-thread.component.html
1 <div class="media conversation">
2 <div class="pull-left">
3 <img class="media-object avatar"
4 src="{{thread.avatarSrc}}">
5 </div>
6 <div class="media-body">
7 <h5 class="media-heading contact-name">{{thread.name}}
8 <span *ngIf="selected">&bull;</span>
9 </h5>
10 <small class="message-preview">
11 {{thread.messages[thread.messages.length - 1].text}}
12 </small>
13 </div>
14 <a (click)="clicked($event)" class="div-link">Select</a>
15 </div>
Notice that in our view we've got some straight-forward bindings like {{thread.avatarSrc}},
{{thread.name}}. In the message-preview tag we've got the following:
{{ thread.messages[thread.messages.length - 1].text }}
This gets the last message in the thread and displays the text of that message. The
idea is we are showing a preview of the most recent message in that thread.
We've got an *ngIf which will show the &bull; symbol only if this is the selected
thread.
Lastly, we're binding to the (click) event to call our clicked() handler. Notice that
when we call clicked we're passing the argument $event. This is a special variable
provided by Angular that describes the event. We use that in our clicked handler
by calling event.preventDefault();. This makes sure that we don't navigate to a
different page.
Intermediate Redux in Angular 461
Building the ChatWindowComponent
The ChatWindowComponent is the most complicated component in our app. Let's take
it one section at a time:
The Chat Window
Our ChatWindowComponent class has three properties: currentThread (which holds a
Thread (that contains Message[] as a property), draftMessage and currentUser:
code/redux/redux-chat/src/app/chat-window/chat-window.component.ts
23 export class ChatWindowComponent {
24 currentThread: Thread;
25 draftMessage: { text: string };
26 currentUser: User;
Here's a diagram of where each one is used:
Intermediate Redux in Angular 462
Chat Window Properties
In our constructor we're going to inject two things:
code/redux/redux-chat/src/app/chat-window/chat-window.component.ts
28 constructor(@Inject(AppStore) private store: Redux.Store<AppState>,
29 private el: ElementRef) {
30 store.subscribe(() => this.updateState() );
31 this.updateState();
32 this.draftMessage = { text: '' };
33 }
The 1st is our Redux Store. The second, el is an ElementRef which we can use to
get access to the host DOM element. We'll use that when we scroll to the bottom of
the chat window when we create and receive new messages.
In our constructor we subscribe to our store, as we have in our other container
components.
The next thing we do is to set a default draftMessage with an empty string for the
Intermediate Redux in Angular 463
text. We'll use the draftMessage to keep track of the input box as the user is typing
their message.
ChatWindowComponent updateState()
When the store changes we will update the instance variables for this component:
code/redux/redux-chat/src/app/chat-window/chat-window.component.ts
35 updateState() {
36 const state = this.store.getState();
37 this.currentThread = getCurrentThread(state);
38 this.currentUser = getCurrentUser(state);
39 this.scrollToBottom();
40 }
Here we store the current thread and the current user. If a new message comes
in, we also want to scroll to the bottom of the window. It's a bit coarse to call
scrollToBottom here, but it's a simple way to make sure that the user doesn't have
to scroll manually each time there is a new message (or they switch to a new thread).
ChatWindowComponent scrollToBottom()
To scroll to the bottom of the chat window, we're going to use the ElementRef el
that we saved in the constructor. To make this element scroll, we're going to set the
scrollTop property of our host element:
code/redux/redux-chat/src/app/chat-window/chat-window.component.ts
42 scrollToBottom(): void {
43 const scrollPane: any = this.el
44 .nativeElement.querySelector('.msg-container-base');
45 if (scrollPane) {
46 setTimeout(() => scrollPane.scrollTop = scrollPane.scrollHeight);
47 }
48 }
Intermediate Redux in Angular 464
Why do we have the setTimeout?
If we call scrollToBottom immediately when we get a new message then
what happens is we scroll to the bottom before the new message is rendered.
By using a setTimeout we're telling JS that we want to run this
function when it is finished with the current execution queue. This happens
after the component is rendered, so it does what we want.
ChatWindowComponent sendMessage
When we want to send a new message, we'll do it by taking:
• The current thread
• The current user
• The draft message text
And then dispatching a new addMessage action on the store. Here's what it looks like
in code:
code/redux/redux-chat/src/app/chat-window/chat-window.component.ts
50 sendMessage(): void {
51 this.store.dispatch(ThreadActions.addMessage(
52 this.currentThread,
53 {
54 author: this.currentUser,
55 isRead: true,
56 text: this.draftMessage.text
57 }
58 ));
59 this.draftMessage = { text: '' };
60 }
The sendMessage function above takes the draftMessage, sets the author and thread
using our component properties. Every message we send has "been read" already (we
wrote it) so we mark it as read.
After we dispatch the message, we create a new Message** and set that new Message
to this.draftMessage. This will clear the search box and by creating a new object
we ensure we don't mutate the message that was sent to the store.
Intermediate Redux in Angular 465
ChatWindowComponent onEnter
In our view, we want to send the message in two scenarios
1. the user hits the "Send" button or
2. the user hits the Enter (or Return) key.
Let's define a function that will handle both events:
code/redux/redux-chat/src/app/chat-window/chat-window.component.ts
62 onEnter(event: any): void {
63 this.sendMessage();
64 event.preventDefault();
65 }
We create this onEnter event handler as a separate function from
sendMessage because onEnter will accept an event as an argument and
then call event.preventDefault(). This way we could call sendMessage in
scenarios other than in response to a browser event. In this case, we're not
really calling sendMessage in any other situation, but I find that it's nice to
separate the event handler from the function that 'does the work'.
That is, a sendMessage function that also 1. requires an event to be passed
to it and 2. handles that event feels like a function that may be handling
too many concerns.
Now that we've handled the controller code, let's look at the template
ChatWindowComponent template
We start our template by opening the panel tags: and showing the chat name in the
header:
Intermediate Redux in Angular 466
code/redux/redux-chat/src/app/chat-window/chat-window.component.html
1 <div class="chat-window-container">
2 <div class="chat-window">
3 <div class="panel-container">
4 <div class="panel panel-default">
5
6 <div class="panel-heading top-bar">
7 <div class="panel-title-container">
8 <h3 class="panel-title">
9 <span class="glyphicon glyphicon-comment"></span>
10 Chat - {{currentThread.name}}
11 </h3>
12 </div>
13 <div class="panel-buttons-container" >
14 <!-- you could put minimize or close buttons here -->
15 </div>
16 </div>
17
18 <div class="panel-body msg-container-base">
19 <chat-message
20 *ngFor="let message of currentThread.messages"
21 [message]="message">
22 </chat-message>
23 </div>
24
25 <div class="panel-footer">
26 <div class="input-group">
27 <input type="text"
28 class="chat-input"
29 placeholder="Write your message here..."
30 (keydown.enter)="onEnter($event)"
31 [(ngModel)]="draftMessage.text" />
32 <span class="input-group-btn">
33 <button class="btn-chat"
34 (click)="onEnter($event)"
35 >Send</button>
36 </span>
37 </div>
38 </div>
39
40 </div>
41 </div>
42 </div>
43 </div>
Intermediate Redux in Angular 467
Next we show the list of messages. Here we use ngFor to iterate over our list of
messages. We'll describe the individual chat-message component in a minute.
code/redux/redux-chat/src/app/chat-window/chat-window.component.html
18 <div class="panel-body msg-container-base">
19 <chat-message
20 *ngFor="let message of currentThread.messages"
21 [message]="message">
22 </chat-message>
23 </div>
Lastly we have the message input box and closing tags:
code/redux/redux-chat/src/app/chat-window/chat-window.component.html
25 <div class="panel-footer">
26 <div class="input-group">
27 <input type="text"
28 class="chat-input"
29 placeholder="Write your message here..."
30 (keydown.enter)="onEnter($event)"
31 [(ngModel)]="draftMessage.text" />
32 <span class="input-group-btn">
33 <button class="btn-chat"
34 (click)="onEnter($event)"
35 >Send</button>
36 </span>
37 </div>
38 </div>
39
40 </div>
41 </div>
42 </div>
The message input box is the most interesting part of this view, so let's talk about
two interesting properties: 1. (keydown.enter) and 2. [(ngModel)].
Handling keystrokes
Angular provides a straightforward way to handle keyboard actions: we bind to
the event on an element. In this case, we're binding to keydown.enter which says
if "Enter" is pressed, call the function in the expression, which in this case is
onEnter($event).
Intermediate Redux in Angular 468
code/redux/redux-chat/src/app/chat-window/chat-window.component.html
27 <input type="text"
28 class="chat-input"
29 placeholder="Write your message here..."
30 (keydown.enter)="onEnter($event)"
31 [(ngModel)]="draftMessage.text" />
Using ngModel
As we've talked about before, we don't generally use two-way data binding as the
crux of our data architecture (like we might have in Angular 1). This is particularly
true when we're using Redux which is strictly a one-way data flow.
However it can be very useful to have a two-way binding between a component and
its view. As long as the side-effects are kept local to the component, it can be a very
convenient way to keep a component property in sync with the view.
In this case, we're establishing a two-way bind between the value of the input tag
and draftMessage.text. That is, if we type into the input tag, draftMessage.text
will automatically be set to the value of that input. Likewise, if we were to update
draftMessage.text in our code, the value in the input tag would change in the view.
Clicking "Send"
On our "Send" button we bind the (click) property to the onEnter function of our
component:
code/redux/redux-chat/src/app/chat-window/chat-window.component.html
33 <button class="btn-chat"
34 (click)="onEnter($event)"
35 >Send</button>
We're using the same onEnter function to handle the events which should send the
draft message for both the button and hitting the enter button.
Intermediate Redux in Angular 469
The ChatMessageComponent
Instead of putting the rendering code for each individual message in this component,
instead we're going to create another presentational component ChatMessageComponent.
Tip: If you're using ngFor that's a good indication you should create a new
component.
Each Message is rendered by the ChatMessageComponent.
The ChatMessageComponent
This component is relatively straightforward. The main logic here is rendering a
slightly different view depending on if the message was authored by the current user.
If the Message was not written by the current user, then we consider the message
incoming.
Intermediate Redux in Angular 470
Setting incoming
Remember that each ChatMessageComponent belongs to one Message. So in ngOnInit
we will set incoming depending on if this Message was written by the current user:
code/redux/redux-chat/src/app/chat-message/chat-message.component.ts
1 import {
2 Component,
3 OnInit,
4 Input
5 } from '@angular/core';
6 import { Message } from '../message/message.model';
7
8 @Component({
9 selector: 'chat-message',
10 templateUrl: './chat-message.component.html',
11 styleUrls: ['./chat-message.component.css']
12 })
13 export class ChatMessageComponent implements OnInit {
14 @Input() message: Message;
15 incoming: boolean;
16
17 ngOnInit(): void {
18 this.incoming = !this.message.author.isClient;
19 }
20 }
The ChatMessageComponent template
In our template we have two interesting ideas:
1. the FromNowPipe
2. [ngClass]
First, here's the code:
Intermediate Redux in Angular 471
code/redux/redux-chat/src/app/chat-message/chat-message.component.html
1 <div class="msg-container"
2 [ngClass]="{'base-sent': !incoming, 'base-receive': incoming}">
3
4 <div class="avatar"
5 *ngIf="!incoming">
6 <img src="{{message.author.avatarSrc}}">
7 </div>
8
9 <div class="messages"
10 [ngClass]="{'msg-sent': !incoming, 'msg-receive': incoming}">
11 <p>{{message.text}}</p>
12 <p class="time">{{message.sender}} • {{message.sentAt | fromNow}}</p>
13 </div>
14
15 <div class="avatar"
16 *ngIf="incoming">
17 <img src="{{message.author.avatarSrc}}">
18 </div>
19 </div>
The FromNowPipe is a pipe that casts our Messages sent-at time to a human-readable "x
seconds ago" message. You can see that we use it by: {{message.sentAt | fromNow}}
FromNowPipe uses the excellent moment.js¹²⁹ library.
You can read the source of the FromNowPipe in
code/redux/redux-chat/src/app/pipes/from-now.pipe.ts
We also make extensive use of ngClass in this view. The idea is, when we say:
[ngClass]="{'msg-sent': !incoming, 'msg-receive': incoming}"
We're asking Angular to apply the msg-receive class if incoming is truthy (and apply
msg-sent if incoming is falsey).
By using the incoming property, we're able to display incoming and outgoing
messages differently.
¹²⁹http://momentjs.com/
Intermediate Redux in Angular 472
Summary
There we go, if we put them all together we've got a fully functional chat app!
Completed Chat Application
If you checkout code/redux/redux-chat/src/app/data/chat-example-data.ts you'll
see we've written a handful of bots for you that you can chat with. Checkout the code
and try writing a few bots of your own!
Advanced Components
Throughout this book, we've learned how to use Angular's built-in directives and
how to create components of our own. In this chapter we'll take a deep dive into
advanced features we can use to make components.
In this chapter we'll learn the following concepts:
• Styling components (with encapsulation)
• Modifying host DOM elements
• Modifying templates with content projection
• Accessing neighbor directives
• Using lifecycle hooks
• Detecting changes
How to Use This Chapter
This chapter gives a tour of advanced Angular APIs. It's assumed the reader
is familiar with the basics of creating components, using built-in directives,
and organizing component files.
As this is an intermediate/advanced level chapter, it's assumed the reader
is able to fill in some of the basics (such as importing dependencies).
This chapter comes with runnable code, found in the advanced-components
folder. If at any time you feel you're lacking context, checkout the example
code for this chapter.
To run the demos in this chapter, change into the project folder and run:
1 npm install
2 npm start
Then open your browser to http://localhost:4200
Advanced Components 474
Styling
Angular provides a mechanism for specifying component-specific styles. CSS stands
for cascading style sheet, but sometimes we don't want the cascade. Instead we want
to provide styles for a component that won't leak out into the rest of our page.
Angular provides two attributes that allow us to define CSS classes for our component.
To define the style for our component, we use the View attribute styles to define inline
styles, or styleUrls, to use external CSS files. We can also declare those attributes
directly on the Component decorator.
Let's write a component that uses inline styles:
code/advanced-components/src/app/styling/inline-style/inline-style.component.ts
1 import { Component } from '@angular/core';
2
3 @Component({
4 selector: 'app-inline-style',
5 styles: [`
6 .highlight {
7 border: 2px solid red;
8 background-color: yellow;
9 text-align: center;
10 margin-bottom: 20px;
11 }
12 `],
13 template: `
14 <h4 class="ui horizontal divider header">
15 Inline style example
16 </h4>
17
18 <div class="highlight">
19 This uses component <code>styles</code>
20 property
21 </div>
22 `
23 })
24 export class InlineStyleComponent {
25 }
Advanced Components 475
In this example we defined the styles we want to use by declaring the .highlight
class as an item on the array on the styles parameter.
Further on in the template we reference that class on the div using <div class="highlight">.
And the result is exactly what we expect - a div with a red border and yellow
background:
Example of component using styles
Another way to declare CSS classes is to use the styleUrls property. This allows us
to declare our CSS in an external file and just reference them from the component.
Let's write another component that uses this, but 1st let's create a file called
external.css with the following class:
code/advanced-components/src/app/styling/external-style/external-style.component.css
1 .highlight {
2 border: 2px dotted red;
3 text-align: center;
4 margin-bottom: 20px;
5 }
Then we can write the code that references it:
code/advanced-components/src/app/styling/external-style/external-style.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-external-style',
5 styleUrls: ['./external-style.component.css'],
6 template: `
7 <h4 class="ui horizontal divider header">
8 External style example
9 </h4>
10
11 <div class="highlight">
Advanced Components 476
12 This uses component <code>styleUrls</code>
13 property
14 </div>
15 `
16 })
17 export class ExternalStyleComponent {
18 }
And when we load the page, we see our div with a dotted border:
Example of component using styleUrls
View (Style) Encapsulation
One interesting thing about this example is that both components define a class called
highlight with different properties, but the attributes of one didn't leak into the
other.
This happens because Angular styles are encapsulated by the component context
by default. If we inspect the page and expand the <head>, we'll notice that Angular
injected a < style> tag with our style:
Advanced Components 477
Injected style
You'll also notice that the CSS class has been scoped with _ngcontent-hve-2:
1 .highlight[\_ngcontent-hve-2] {
2 border: 2px solid red;
3 background-color: yellow;
4 text-align: center;
5 margin-bottom: 20px;
6 }
And if we check how our <div> is rendered, you'll find that _ng-content-hve-2 was
added:
Advanced Components 478
Injected style
The same thing happens for our external style:
Advanced Components 479
External style
and:
Advanced Components 480
External style
Angular allows us to change this behavior, by using the encapsulation property.
This property can have the following values, defined by the ViewEncapsulation
enum:
• Emulated - this is the default option and it will encapsulate the styles using the
technique we just explained above
• Native - with this option, Angular will use the Shadow DOM (more on this
below)
• None - with this option set, Angular won't encapsulate the styles at all, allowing
them to leak to other elements on the page
Advanced Components 481
Shadow DOM Encapsulation
You might be wondering: what is the point of using the Shadow DOM? By using
the Shadow DOM the component uses a unique DOM tree that is hidden from the
other elements on the page. This allows styles defined within that element to be
invisible to the rest of the page.
For a deep dive into Shadow DOM, please check this guide by Eric
Bidelman¹³⁰.
Let's create another component that uses the Native encapsulation (Shadow DOM)
to understand how this works:
code/advanced-components/src/app/styling/native-encapsulation/native-encapsulation.
component.ts
1 import {
2 Component,
3 ViewEncapsulation
4 } from '@angular/core';
5
6 @Component({
7 selector: 'app-native-encapsulation',
8 styles: [`
9 .highlight {
10 text-align: center;
11 border: 2px solid black;
12 border-radius: 3px;
13 margin-botton: 20px;
14 }`],
15 template: `
16 <h4 class="ui horizontal divider header">
17 Native encapsulation example
18 </h4>
19
20 <div class="highlight">
21 This component uses <code>ViewEncapsulation.Native</code>
22 </div>
23 `,
24 encapsulation: ViewEncapsulation.Native
¹³⁰http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/
Advanced Components 482
25 })
26 export class NativeEncapsulationComponent {
27 }
In this case, if we inspect the source code, we'll see:
Native encapsulation
Everything inside the #shadow-root element has been encapsulated and isolated from
the rest of the page.
No Encapsulation
Finally, if we create a component that specifies ViewEncapsulation.None, no style
encapsulation will be added:
Advanced Components 483
code/advanced-components/src/app/styling/no-encapsulation/no-encapsulation.component.ts
1 import {
2 Component,
3 ViewEncapsulation
4 } from '@angular/core';
5
6 @Component({
7 selector: 'app-no-encapsulation',
8 styles: [`
9 .highlight {
10 border: 2px dashed red;
11 text-align: center;
12 margin-bottom: 20px;
13 }
14 `],
15 template: `
16 <h4 class="ui horizontal divider header">
17 No encapsulation example
18 </h4>
19
20 <div class="highlight">
21 This component uses <code>ViewEncapsulation.None</code>
22 </div>
23 `,
24 encapsulation: ViewEncapsulation.None
25 })
26 export class NoEncapsulationComponent {
27 }
When we inspect the element:
Advanced Components 484
No encapsulation
We can see that nothing was injected on the HTML. Also on the header we can
find that the < style> tag was also injected exactly like we defined on the styles
parameter:
1 .highlight {
2 border: 2px dashed red;
3 text-align: center;
4 margin-bottom: 20px;
5 }
One side-effect of using ViewEncapsulation.None is that, since we don't have any
encapsulation, this style "leaks" into other components. If we check the picture
above, the ViewEncapsulation.Native component style was affected by this new
component's style. But sometimes this can be exactly what you want.
Advanced Components 485
You can comment out the <app-no-encapsulation></app-no-encapsulation> code
on the StyleSampleApp template to see the difference.
Creating a Popup - Referencing and Modifying
Host Elements
The host element is the element to which the directive or component is bound.
Sometimes we have a component that needs to attach markup or behavior to its
host element.
In this example, we're going to create a Popup directive that will attach behavior to
its host element which will display a message when clicked.
Components vs. Directives - What's the difference?
Components and directives are closely related, but they are slightly different.
You may have heard that "components are directives with a view". This
isn't exactly true. Components come with functionality that makes it easy
to add views, but directives can have views too. In fact, components are
implemented with directives.
One great example of a directive that renders a conditional view is NgIf.
But we can attach behaviors to an element without a template by using a
directive.
Think of it this way: Components are Directives and Components always
have a view. Directives may or may not have a view.
If you choose to render a view (a template) in your Directive, you can have
more control over how that template is rendered. We'll talk more about
how to use that control later in this chapter.
Advanced Components 486
Popup Structure
Now let's write our 1st directive. We want this directive to show an alert when
we click a DOM element that includes the attribute popup. The message displayed
will be identified by the element's message attribute.
Here's what we want it to look like:
1 <element popup message="Some message"></element>
In order to make this directive work, there are a couple of things we need to do:
• receive the message attribute from the host
• be notified when the host element is clicked
Let's start coding our directive:
code/advanced-components/src/app/host/popup-demo/steps/host-1.ts
11 @Directive({
12 selector: '[popup]'
13 })
14 export class PopupDirective {
15 constructor() {
16 console.log('Directive bound');
17 }
18 }
We use the Directive decorator and set the selector option to [popup]. This will
make this directive bind to any elements that define the popup attribute.
Now let's create an app that has an element that has the popup attribute:
Advanced Components 487
code/advanced-components/src/app/host/popup-demo/steps/host-1.ts
20 @Component({
21 selector: 'app-popup-demo',
22 template: `
23 <div class="ui message" popup>
24 <div class="header">
25 Learning Directives
26 </div>
27
28 <p>
29 This should use our Popup diretive
30 </p>
31 </div>
32 `
33 })
34 export class PopupDemoComponent1 {
35 }
When we run this application, we expect the message Directive bound to be logged
on the console, indicating we have successfully bound to the 1st <div> in our
template:
Advanced Components 488
Binding to host element
Using ElementRef
If we want to learn more about the host element a directive is bound to, we can use
the built-in ElementRef class.
This class holds the information about a given Angular element, including the native
DOM element using the nativeElement property.
In order to see the elements our directive is binding to, we can change our directive
constructor to receive the ElementRef and log it to the console:
Advanced Components 489
code/advanced-components/src/app/host/popup-demo/steps/host-2.ts
9 import { Component, Directive, ElementRef } from '@angular/core';
10
11 @Directive({
12 selector: '[popup]'
13 })
14 export class PopupDirective {
15 constructor(_elementRef: ElementRef) {
16 console.log(_elementRef);
17 }
18 }
We can also add a second element to the page that uses our directive, so we can see
two different ElementRefs logged to the console:
code/advanced-components/src/app/host/popup-demo/steps/host-2.ts
20 @Component({
21 selector: 'app-pop-demo',
22 template: `
23 <div class="ui message" popup>
24 <div class="header">
25 Learning Directives
26 </div>
27
28 <p>
29 This should use our Popup diretive
30 </p>
31 </div>
32
33 <i class="alarm icon" popup></i>
34 `
35 })
36 export class PopupDemoComponent2 {
37 }
When we run our app now, we can see two different ElementRefs: one with
div.ui.message and the other with i.alarm.icon. This means that the directive was
successfully bound to two different host elements:
Advanced Components 490
ElementRefs
Binding to the host
Moving on, our next goal is to do sth when the host element is clicked.
We learned before that the way we bind events in elements in Angular is using the
(event) syntax.
In order to bind events of the host element, we'll do sth very similar, but the
syntax is different. In order to bind the directive to a host's click event, we're going
to use the decorator HostListener.
The HostListener decorator allows a directive to listen to events on its host
element.
We'll do this by decorating a function on the component with the @HostListener()
decoration.
Advanced Components 491
We also want the host element to define what message will pop up when the element
is clicked, using the message attribute.
First, let's add an inputs attribute to the directive. We'll do this by importing Input
and using the @Input decorator with the property we will use for this input:
1 import { Component, Input } from '@angular/core';
2 ...
3 class Popup {
4 @Input() message: String;
5 ...
6 }
We're saying that we're having a property with the name message and expect to
receive an input with the same name.
Then, let's add the HostListener decoration. We'll do this by adding @HostLisener('click')
on the function we want to call when the host is clicked:
code/advanced-components/src/app/host/popup-demo/steps/host-3.ts
14 HostListener
15 } from '@angular/core';
16
17 @Directive({
18 selector: '[popup]'
19 })
20 export class PopupDirective {
21 @Input() message: String;
22
23 constructor(_elementRef: ElementRef) {
24 console.log(_elementRef);
25 }
26
27 @HostListener('click') displayMessage(): void {
28 alert(this.message);
29 }
30 }
Then when the host element is clicked we'll call the directive's displayMessage
method, which will display the message the host element defines.
And finally, we need to change our app template a bit to add the message we want
displayed for each element:
Advanced Components 492
code/advanced-components/src/app/host/popup-demo/steps/host-3.ts
32 @Component({
33 selector: 'app-popup-demo',
34 template: `
35 <div class="ui message" popup
36 message="Clicked the message">
37 <div class="header">
38 Learning Directives
39 </div>
40
41 <p>
42 This should use our Popup diretive
43 </p>
44 </div>
45
46 <i class="alarm icon" popup
47 message="Clicked the alarm icon"></i>
48 `
49 })
50 export class PopupDemoComponent3 {
51 }
Notice that we use the popup directive twice and we pass a different message each
time we use it. This means when we run the app, we're able to click either on the
message or on the alarm icon and we'll see different messages:
Advanced Components 493
Popup 1
Popup 2
Adding a Button using exportAs
Now let's say we have a new requirement: we want to trigger the alert manually by
clicking a button. How could we trigger the popup message from outside the host
Advanced Components 494
element?
In order to achieve this, we need to make the directive available from elsewhere
in the template. As we discussed in previous chapters, the way to reference a
component is by using template reference variable. We can reference directives
the same way.
In order to give the templates a reference to a directive we use the exportAs attribute.
This will allow the host element (or a child of the host element) to define a template
variable that references the directive using the #var="exportName" syntax.
Let's add the exportAs attribute to our directive:
code/advanced-components/src/app/host/popup-demo/steps/host-4.ts
17 @Directive({
18 selector: '[popup]',
19 exportAs: 'popup',
20 })
21 export class PopupDirective {
22 @Input() message: String;
23
24 constructor(_elementRef: ElementRef) {
25 console.log(_elementRef);
26 }
27
28 @HostListener('click') displayMessage(): void {
29 alert(this.message);
30 }
31 }
And now we need to change the two elements to export the template reference:
Advanced Components 495
code/advanced-components/src/app/host/popup-demo/steps/host-4.ts
35 template: `
36 <div class="ui message" popup #popup1="popup"
37 message="Clicked the message">
38 <div class="header">
39 Learning Directives
40 </div>
41
42 <p>
43 This should use our Popup diretive
44 </p>
45 </div>
46
47 <i class="alarm icon" popup #popup2="popup"
48 message="Clicked the alarm icon"></i>
See that we used the template var #popup1 for the div.message and #popup2 for the
icon.
Now let's add two buttons, one to trigger each popup:
code/advanced-components/src/app/host/popup-demo/steps/host-4.ts
49 <div style="margin-top: 20px;">
50 <button (click)="popup1.displayMessage()" class="ui button">
51 Display popup for message element
52 </button>
53
54 <button (click)="popup2.displayMessage()" class="ui button">
55 Display popup for alarm icon
56 </button>
57 </div>
Now reload the page and click each of the buttons and each message will appear as
expected.
Creating a Message Pane with Content
Projection
Sometimes when we are creating components we want to pass inner markup as an
argument to the component. This technique is called content projection. The idea is
Advanced Components 496
that it lets us specify a bit of markup that will be expanded into a bigger template.
Angular 1 dug deep in the dictionary and called this transclusion.
Let's create a new directive that will render a nicely styled message like this:
Popup 1
Our goal is to write markup like this:
1 <div message header="My Message">
2 This is the content of the message
3 </div>
Which will render into the more complicated HTML like:
1 <div class="ui message">
2 <div class="header">
3 My Message
4 </div>
5
6 <p>
7 This is the content of the message
8 </p>
9 </div>
We have two challenges here: we need to change the host element <div> to add the
ui and message CSS classes and we need to add the div's contents to a specific place
in our markup.
Advanced Components 497
Changing the Host's CSS
To add attributes to the host element, we use a new decorator, similar to when
we listened to events on the host: the HostBinding decorator. But now, instead of
specifying the event name we want to listen for, we'll define the attribute name we
want to 'bind' to. In this component, it looks like this:
1 @HostBinding('attr.class') cssClass = 'ui message';
This decoration tells angular that we want the value of cssClass to be kept in sync
with the host's attribute class.
Using ng-content
Our next challenge is to include the original host element children in a specific part
of a view. To do that, we use the ng-content directive.
Since this directive needs a template, let's use a component instead and write the
following code:
code/advanced-components/src/app/content-projection/content-projection-demo/messageo.
component.ts
1 /* tslint:disable:component-selector */
2 import {
3 Component,
4 OnInit,
5 Input,
6 HostBinding
7 } from '@angular/core';
8
9 @Component({
10 selector: '[app-message]',
11 template: `
12 <div class="header">
13 {{ header }}
14 </div>
15 <p>
16 <ng-content></ng-content>
17 </p>
18 `
Advanced Components 498
19 })
20 export class MessageComponent implements OnInit {
21 @Input() header: string;
22 @HostBinding('attr.class') cssClass = 'ui message';
23
24 ngOnInit(): void {
25 console.log('header', this.header);
26 }
27 }
A few highlights:
• We use the @Input decorator to indicate we want to receive a header attribute,
set on the host element
• We set the host element's class attribute to ui message using the host attribute
of our component
• We use <ng-content></ng-content> to project the host element's children into
a specific location of our template
When we open the app in the browser and inspect the message div, we see it worked
exactly like we planned:
Advanced Components 499
projected content
Querying Neighbor Directives - Writing Tabs
It's great when you can create a component that fully encapsulates its own behavior.
However, as a component grows in features, it might make sense to split it up into
several smaller components that work together.
A great example of components that work together is a tab pane that has multiple
tabs. The tab panel or tabset, as it's usually called, is composed of multiple tabs. In
this scenario we have a parent component (the tabset) and multiple child components
Advanced Components 500
(the tabs). The tabset and the tabs don't make sense separately, but putting all of the
logic in one component is cumbersome. So in this example, we're going to cover how
to make separate components that work together.
Let's start writing those components in a way that we'll be able to use the following
markup:
1 <tabset>
2 <tab title="Tab 1">Tab 1</tab>
3 <tab title="Tab 2">Tab 2</tab>
4 ...
5 </tabset>
We're going to use Semantic UI Tab styles¹³¹ to render the tabs.
ContentTabComponent
Let's start by writing the ContentTabComponent
code/advanced-components/src/app/tabs/content-tabs-demo/content-tab.component.ts
1 import {
2 Component,
3 OnInit,
4 Input
5 } from '@angular/core';
6
7 @Component({
8 selector: 'tab',
9 templateUrl: './content-tab.component.html'
10 })
11 export class ContentTabComponent implements OnInit {
12 @Input() title: string;
13 active = false;
14 name: string;
15
16 constructor() { }
17
18 ngOnInit() { }
19 }
and the template:
¹³¹http://semantic-ui.com/modules/tab.html#/examples
Advanced Components 501
code/advanced-components/src/app/tabs/content-tabs-demo/content-tab.component.html
1 <div class="ui bottom attached tab segment"
2 [class.active]="active">
3
4 <ng-content></ng-content>
5
6 </div>
There are not many new concepts here. We're declaring a component that will use
the ContentTabComponent selector and it will allow a title input to be set.
Then we're rendering a <div> and using the content projection concept we learned
in the previous section to inline the contents of the <tab> directive inside the div.
Next we declare 3 properties on our components: title, active and name. One thing
to notice is the @Input('title') decorator we added to the title property. This
decorator is a way to ask Angular to automatically bind the value of the input title
into the property title.
ContentTabsetComponent Component
Now let's move on to the ContentTabsetComponent component that will be used to
wrap the tabs:
code/advanced-components/src/app/tabs/content-tabs-demo/content-tabset.component.ts
1 import {
2 Component,
3 AfterContentInit,
4 QueryList,
5 ContentChildren
6 } from '@angular/core';
7
8 import { ContentTabComponent } from './content-tab.component';
9
10 @Component({
11 selector: 'tabset',
12 templateUrl: './content-tabset.component.html'
13 })
14 export class ContentTabsetComponent implements AfterContentInit {
15 @ContentChildren(ContentTabComponent) tabs: QueryList<ContentTabComponent>;
Advanced Components 502
16
17 ngAfterContentInit(): void {
18 this.tabs.toArray()[0].active = true;
19 }
20
21 setActive(tab: ContentTabComponent): void {
22 this.tabs.toArray().forEach((t) => t.active = false);
23 tab.active = true;
24 }
25
26 constructor() { }
27 }
and the template:
code/advanced-components/src/app/tabs/content-tabs-demo/content-tabset.component.html
1 <div class="ui top attached tabular menu">
2 <a *ngFor="let tab of tabs"
3 class="item"
4 [class.active]="tab.active"
5 (click)="setActive(tab)">
6
7 {{ tab.title }}
8
9 </a>
10 </div>
11 <ng-content></ng-content>
Let's break down the implementation so we can learn about the new concepts it
introduces.
ContentTabsetComponent @Component Decorator
The @Component section doesn't have many new ideas. We're using the <tabset> tab
as our selector.
The template itself uses ngFor to iterate through the tabs and if the tab has the active
flag set to true, it will add the active CSS class to the <a> element that renders the
tab.
We also specify that we are rendering the tabs themselves after the initial div, right
where ng-content is.
Advanced Components 503
ContentTabsetComponent class
Now let's turn our attention to the ContentTabsetComponent class. The 1st new
idea we see here is that the ContentTabsetComponent class is implementing AfterContentInit.
This lifecycle hook will tell Angular to call a method of our class
(ngAfterContentInit) once the contents of the child directives have been initialized.
ContentTabsetComponent ContentChildren and QueryList
Next thing we do is declare the tabs property that will hold every ContentTab-
Component component we declare inside the ContentTabsetComponent. Notice that
instead of declaring this list as an array of ContentTabComponents, we use the class
QueryList, passing a generic of ContentTabComponent. Why is this?
QueryList is a class provided by Angular and when we use QueryList with a
ContentChildren Angular populates this with the components that match the
query and then keeps the items up to date if the state of the application changes.
However, QueryList requires a ContentChildren to populate it, so let's take a look
at that now.
On the tabs instance variable, we add the @ContentChildren(Tab) decorator. This
decorator will tell Angular to inject all the direct child directives (of the ContentTab-
Component type) into the tabs parameter. We then assign it to the tabs property of our
component. With this we now have access to all the child ContentTabComponent
components.
Initializing the ContentTabsetComponent
When this component is initialized, we want to make the 1st tab active. To do this
we use the ngAfterContentInit function (that is described by the AfterContentInit
hook). Notice that we use this.tabs.toArray() to cast Angular's QueryList into a
native TS array.
ContentTabsetComponent setActive
Finally we define a setActive method. This method is used when we click a tab
on our template e.g. using (click)="setActive(tab)". This function will iterate
through all the tabs, setting their active properties to false. Then we set the tab
we clicked to active.
Advanced Components 504
Using the ContentTabsetComponent
Now the next step is to code the application component that makes use of both of
the components we created. Here's how we write the component:
code/advanced-components/src/app/tabs/content-tabs-demo/content-tabs-demo.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-content-tabs-demo',
5 templateUrl: './content-tabs-demo.component.html'
6 })
7 export class ContentTabsDemoComponent implements OnInit {
8 tabs: any;
9
10 constructor() { }
11
12 ngOnInit() {
13 this.tabs = [
14 { title: 'About', content: 'This is the About tab' },
15 { title: 'Blog', content: 'This is our blog' },
16 { title: 'Contact us', content: 'Contact us here' },
17 ];
18 }
19
20 }
and template:
code/advanced-components/src/app/tabs/content-tabs-demo/content-tabs-demo.component.html
1 <tabset>
2 <tab title="First tab">
3 Lorem ipsum dolor sit amet, consectetur adipisicing elit.
4 Quibusdam magni quia ut harum facilis, ullam deleniti porro
5 dignissimos quasi at molestiae sapiente natus, neque voluptatum
6 ad consequuntur cupiditate nemo sunt.
7 </tab>
8
9 <tab
10 *ngFor="let tab of tabs"
11 [title]="tab.title">
12 {{ tab.content }}
Advanced Components 505
13 </tab>
14 </tabset>
We're declaring that we're using tabs-sample-app as our component's selector and
using the ContentTabsetComponent and ContentTabComponent components.
On the template we then create a ContentTabsetComponent and we add 1st a static
tab (First tab) and we add a few more tabs from the tabs property of the component
controller class, to illustrate how we can render tabs dynamically.
Tabset application
Lifecycle Hooks
Lifecycle hooks are the way Angular allows you to add code that runs before or after
each step of the directive or component lifecycle.
The list of hooks Angular offers are:
• OnInit
Advanced Components 506
• OnDestroy
• DoCheck
• OnChanges
• AfterContentInit
• AfterContentChecked
• AfterViewInit
• AfterViewChecked
Using these hooks each follow a similar pattern:
In order to be notified about those events you
1. declare that your directive or component class implements the interface and
then
2. declare the ng method of the hook (e.g. ngOnInit)
Every method name is ng plus the name of the hook. Np. for OnInit we
declare the method ngOnInit, for AfterContentInit we declare ngAfterContentInit
and so on.
When Angular knows that a component implements these functions, it will invoke
them at the appropriate time.
Let's take a look at each hook individually and when we would use each of them.
It is actually not mandatory for the class to implement the interface,
one could just create the method of the hook. But it is considered good
practice¹³² and has benefits from strong typing and editor tooling.
OnInit and OnDestroy
The OnInit hook is called when your directive properties have been initialized, and
before any of the child directive properties are initialized.
¹³²https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html
Advanced Components 507
Similarly, the OnDestroy hook is called when the directive instance is destroyed. This
is typically used if we need to do some cleanup every time our directive is destroyed.
In order to illustrate let's write a component that implements both OnInit and
OnDestroy:
code/advanced-components/src/app/lifecycle/on-init/on-init.component.ts
1 import {
2 Component,
3 OnInit,
4 OnDestroy
5 } from '@angular/core';
6
7 @Component({
8 selector: 'app-on-init',
9 template: `
10 <div class="ui label">
11 <i class="cubes icon"></i> Init/Destroy
12 </div>
13 `
14 })
15 export class OnInitComponent implements OnInit, OnDestroy {
16 constructor() { }
17
18 ngOnInit(): void {
19 console.log('On init');
20 }
21
22 ngOnDestroy(): void {
23 console.log('On destroy');
24 }
25 }
For this component, we're just logging On init and On destroy to the console when
the hooks are called.
Now in order to test those hooks let's use our component in our app component using
ngFor to conditionally display it based on a boolean property. Let's also add a button
that allows us to toggle that flag. This way, when the flag is false, our component
will be removed from the page, causing the OnDestroy hook to be called. Similarly
when the flag is toggled to true, the OnInit hook will be called.
Here's how our app component will look:
Advanced Components 508
code/advanced-components/src/app/lifecycle/on-init/on-init-demo.component.ts
1 import { Component } from '@angular/core';
2
3 @Component({
4 selector: 'app-on-init-demo',
5 templateUrl: './on-init-demo.component.html'
6 })
7 export class OnInitDemoComponent {
8 display: boolean;
9
10 constructor() {
11 this.display = true;
12 }
13
14 toggle(): void {
15 this.display = !this.display;
16 }
17 }
and the template:
code/advanced-components/src/app/lifecycle/on-init/on-init-demo.component.html
1 <h4 class="ui horizontal divider header">
2 OnInit and OnDestroy
3 </h4>
4
5 <button class="ui primary button" (click)="toggle()">
6 Toggle
7 </button>
8 <app-on-init *ngIf="display"></app-on-init>
When we 1st run the application, we can see that the OnInit hook was called when
the component was 1st instantiated:
Advanced Components 509
Initial state of our component
When I click the Toggle button for the 1st time, the component is destroyed and the
hook is called as expected:
Advanced Components 510
OnDestroy hook
And if we click it another time:
Advanced Components 511
OnDestroy hook
OnChanges
The OnChanges hook is called after one or more of our component properties have
been changed. The ngOnChanges method receives a parameter which tells which
properties have changed.
To understand this better, let's write a comment block component that has two inputs:
name and comment:
Advanced Components 512
code/advanced-components/src/app/lifecycle/on-changes/on-changes.component.ts
1 import {
2 Component,
3 OnInit,
4 OnChanges,
5 Input,
6 SimpleChange
7 } from '@angular/core';
8
9 @Component({
10 selector: 'app-on-changes',
11 templateUrl: './on-changes.component.html'
12 })
13 export class OnChangesComponent implements OnChanges {
14 @Input('name') name: string;
15 @Input('comment') comment: string;
16
17 ngOnChanges(changes: {[propName: string]: SimpleChange}): void {
18 console.log('Changes', changes);
19 }
20 }
and template:
code/advanced-components/src/app/lifecycle/on-changes/on-changes.component.html
1 <div class="ui comments">
2 <div class="comment">
3 <a class="avatar">
4 <img src="assets/images/avatars/matt.jpg">
5 </a>
6 <div class="content">
7 <a class="author">{{name}}</a>
8 <div class="text">
9 {{comment}}
10 </div>
11 </div>
12 </div>
13 </div>
The important thing about this component is that it implements the OnChanges
interface and it declares the ngOnChanges method with this signature:
Advanced Components 513
code/advanced-components/src/app/lifecycle/on-changes/on-changes.component.ts
17 ngOnChanges(changes: {[propName: string]: SimpleChange}): void {
18 console.log('Changes', changes);
19 }
This method will be triggered whenever the values of either the name or comment
properties change. When that happens, we receive an object that maps changed fields
to SimpleChange objects.
Each SimpleChange instance has two fields: currentValue and previousValue. If both
name and comment properties change for our component, we expect the value of
changes in our method to be sth like:
1 {
2 name: {
3 currentValue: 'new name value',
4 previousValue: 'old name value'
5 },
6 comment: {
7 currentValue: 'new comment value',
8 previousValue: 'old comment value'
9 }
10 }
Now, let's change the app component to use our component and also add a little form
where we can play with the name and comment properties of our component:
code/advanced-components/src/app/lifecycle/on-changes/on-changes-demo.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-on-changes-demo',
5 templateUrl: './on-changes-demo.component.html',
6 styles: []
7 })
8 export class OnChangesDemoComponent implements OnInit {
9 display: boolean;
10 name: string;
11 comment: string;
12
Advanced Components 514
13 constructor() { }
14
15 ngOnInit() {
16 this.display = true;
17 this.name = 'Felipe Coury';
18 this.comment = 'I am learning so much!';
19 }
20
21 setValues(namefld, commentfld): void {
22 this.name = namefld.value;
23 this.comment = commentfld.value;
24 }
25
26 toggle(): void {
27 this.display = !this.display;
28 }
29
30 }
and template:
code/advanced-components/src/app/lifecycle/on-changes/on-changes-demo.component.html
1 <h4 class="ui horizontal divider header">
2 OnChanges
3 </h4>
4
5 <div class="ui form">
6 <div class="field">
7 <label>Name</label>
8 <input
9 type="text"
10 #namefld
11 value="{{name}}"
12 (keyup)="setValues(namefld, commentfld)">
13 </div>
14
15 <div class="field">
16 <label>Comment</label>
17 <textarea
18 #commentfld
19 (keyup)="setValues(namefld, commentfld)"
20 rows="2">{{comment}}</textarea>
21 </div>
Advanced Components 515
22 </div>
23
24 <app-on-changes
25 [name]="name"
26 [comment]="comment"
27 ></app-on-changes>
Note the important pieces we added to the template. We declare a new form with
name and comment fields.
When the keyup event is fired for either the name or comment fields, we are calling
setValues with the template references namefld and commentfld that represent the
input and textarea.
This method just takes the value from those fields and updates the name and
comment properties accordingly:
code/advanced-components/src/app/lifecycle/on-changes/on-changes-demo.component.ts
21 setValues(namefld, commentfld): void {
22 this.name = namefld.value;
23 this.comment = commentfld.value;
24 }
So now, the 1st time we open the app, we can see that our OnChanges hook is called:
Advanced Components 516
OnChanges
This happens when the initial values are set, on the constructor of the Lifecycle-
SampleApp component.
Now if we play with the name, we can see that the hook is called repeatedly. In the
case below, we pasted the name Nate Murray on top of the previous name and the
values for the changes are displayed as expected:
Advanced Components 517
OnChanges
DoCheck
The default notification system implemented by OnChanges is triggered every time
the Angular change detection mechanism notices there was a change on any of the
directive properties.
However, there may be times when the overhead added by this change notification
may be too much, especially if performance is a concern.
There may be times when we just want to do sth in case an item was removed
or added, or if only a particular property changed, for instance.
If we run into one of these scenarios, we can use the DoCheck hook.
Advanced Components 518
It's important to note that the OnChanges hook gets overridden by DoCheck
so if we implement both, OnChanges will be ignored.
Checking for changes
In order to evaluate what changed, Angular provides differs. Differs will evaluate
a given property of your directive to determine what changed.
There are two types of built-in differs: iterable differs and key-value differs.
Iterable differs
Iterable differs should be used when we have a list-like structure and we're only
interested in knowing things that were added or removed from that list.
Key-value differs
Key-value differs should be used for dictionary-like structures and work at the key
level. This differ will identify changes when a new key is added, when a key removed
and when the value of a key changed.
Rendering a comment with DoCheck
To illustrate these concepts, let's build a component that renders a stream of
comments, like below:
Advanced Components 519
DoCheck example
Let's write a component that will render one individual comment. 1st, the template:
code/advanced-components/src/app/lifecycle/differs/comment.component.html
1 <div class="ui feed">
2 <div class="event">
3 <div class="label" *ngIf="comment.author">
4 <img src="assets/images/avatars/{{comment.author.toLowerCase()}}.jpg">
5 </div>
6 <div class="content">
7 <div class="summary">
8 <a class="user">
9 {{comment.author}}
10 </a> posted a comment
11 <div class="date">
12 1 Hour Ago
13 </div>
14 </div>
15 <div class="extra text">
16 {{comment.comment}}
17 </div>
18 <div class="meta">
19 <a class="trash" (click)="remove()">
20 <i class="trash icon"></i> Remove
21 </a>
22 <a class="trash" (click)="clear()">
Advanced Components 520
23 <i class="eraser icon"></i> Clear
24 </a>
25 <a class="like" (click)="like()">
26 <i class="like icon"></i> {{comment.likes}} Likes
27 </a>
28 </div>
29 </div>
30 </div>
31 </div>
and in the component:
code/advanced-components/src/app/lifecycle/differs/comment.component.ts
1 import {
2 Component,
3 Input,
4 Output,
5 EventEmitter,
6 KeyValueDiffers,
7 DoCheck
8 } from '@angular/core';
9
10 @Component({
11 selector: 'app-comment',
12 templateUrl: './comment.component.html'
13 })
14 export class CommentComponent implements DoCheck {
15 @Input() comment: any;
16 @Output() onRemove: EventEmitter<any>;
17 differ: any;
Here we are declaring the component metadata. Our component will receive the
comment that should be rendered and it will emit an event with the remove button
icon clicked.
On the class declaration we indicate we're implementing the DoCheck interface. We
then declare the input property comment and the output event onRemove. We also
declare a differ property.
Advanced Components 521
code/advanced-components/src/app/lifecycle/differs/comment.component.ts
19 constructor(differs: KeyValueDiffers) {
20 this.differ = differs.find([]).create();
21 this.onRemove = new EventEmitter();
22 }
On the constructor we're receiving a KeyValueDiffers instance on the differs
variable. We then use this variable to create an instance of the key value differ
using this syntax differs.find([]).create(null). We're also initializing our event
emitter onRemove.
Next, let's implement the ngDoCheck method, required by the interface:
code/advanced-components/src/app/lifecycle/differs/comment.component.ts
24 ngDoCheck(): void {
25 const changes = this.differ.diff(this.comment);
26
27 if (changes) {
28 changes.forEachAddedItem(r =>
29 this.logChange('added', r)
30 );
31 changes.forEachRemovedItem(r =>
32 this.logChange('removed', r)
33 );
34 changes.forEachChangedItem(r =>
35 this.logChange('changed', r)
36 );
37 }
38 }
This is how you check for changes, if you're using a key-value differ. You call the
diff method, providing the property you want to check. In our case, we want to
know if there were changes to the comment property.
When no changes are detected, the returned value will be null. Now, if there are
changes, we can call three different iterable methods on the differ:
• forEachAddedItem, for keys that were added
• forEachRemovedItem, for keys that were removed
Advanced Components 522
• forEachChangedItem, for keys that were changed
Each method will call the provided callback with a record. For the key-value differ,
this record will be an instance of the KVChangeRecord class.
Example of a KVChangeRecord instance
The important fields for understanding what changed are key, previousValue and
currentValue.
Next, let's write a method that will log to the console a nice sentence about what
changed:
code/advanced-components/src/app/lifecycle/differs/comment.component.ts
40 logChange(action, r) {
41 if (action === 'changed') {
42 console.log(
43 r.key,
44 action,
45 'from',
46 r.previousValue,
47 'to',
48 r.currentValue
49 );
50 }
51 if (action === 'added') {
52 console.log(action, r.key, 'with', r.currentValue);
53 }
54 if (action === 'removed') {
55 console.log(
56 action,
57 r.key,
58 '(was ' + r.previousValue + ')'
59 );
60 }
61 }
Advanced Components 523
Finally, let's write the methods that will help us change things on our component, to
trigger our DoCheck hook:
code/advanced-components/src/app/lifecycle/differs/comment.component.ts
63 remove(): void {
64 this.onRemove.emit(this.comment);
65 }
66
67 clear(): void {
68 delete this.comment.comment;
69 }
70
71 like(): void {
72 this.comment.likes += 1;
73 }
The remove() method will emit the event indicating that the user asked for this
comment to be removed, the clear() method will remove the comment text from
the comment object and the like() method will increase the like counter for the
comment.
Rendering a list of comments with CommentsListComponent
Now that we have written a component for one individual comment, let's write a
second component that will be responsible for rendering the list of comments. First
the template:
code/advanced-components/src/app/lifecycle/differs/comments-list.component.html
1 <app-comment
2 *ngFor="let comment of comments"
3 [comment]="comment"
4 (onRemove)="removeComment($event)">
5 </app-comment>
6
7 <button
8 class="ui primary button"
9 (click)="addComment()">
10 Add
11 </button>
Advanced Components 524
The component template is straightforward: we're using the component we created
above and then using ngFor to iterate through a list of comments, rendering them.
We also have a button that will allow the user to add more comments to the list.
Now let's implement our comment list class CommentsListComponent:
code/advanced-components/src/app/lifecycle/differs/comments-list.component.ts
1 /* tslint:disable:max-line-length,quotemark */
2 import {
3 Component,
4 IterableDiffers,
5 DoCheck
6 } from '@angular/core';
7
8 @Component({
9 selector: 'app-comments-list',
10 templateUrl: './comments-list.component.html'
11 })
12 export class CommentsListComponent implements DoCheck {
13 comments: any[];
14 iterable: boolean;
15 authors: string[];
16 texts: string[];
17 differ: any;
Here we declare the variables we'll use: comments, iterable, authors and texts.
code/advanced-components/src/app/lifecycle/differs/comments-list.component.ts
19 constructor(differs: IterableDiffers) {
20 this.differ = differs.find([]).create(null);
21 this.comments = [];
22
23 this.authors = ['Elliot', 'Helen', 'Jenny', 'Joe', 'Justen', 'Matt'];
24 this.texts = [
25 "Ours is a life of constant reruns. We're always circling back to where we'd we sta\
26 rted, then starting all over again. Even if we don't run extra laps that day, we surely w\
27 ill come back for more of the same another day soon.",
28 'Really cool!',
29 'Thanks!'
30 ];
31
32 this.addComment();
33 }
Advanced Components 525
For this component, we'll be using an iterable differ. We can see that the class we're
using to create the differ is now IterableDiffers. However, the way we create a
differ remains the same.
On the constructor we also initialize a list of authors and a list of comment texts to
be used when adding new comments.
Finally, we call the addComment() method so we don't initialize the app with an empty
list of comments.
The next three methods are used to add a new comment:
code/advanced-components/src/app/lifecycle/differs/comments-list.component.ts
33 getRandomInt(max: number): number {
34 return Math.floor(Math.random() * (max + 1));
35 }
36
37 getRandomItem(array: string[]): string {
38 const pos: number = this.getRandomInt(array.length - 1);
39 return array[pos];
40 }
41
42 addComment(): void {
43 this.comments.push({
44 author: this.getRandomItem(this.authors),
45 comment: this.getRandomItem(this.texts),
46 likes: this.getRandomInt(20)
47 });
48 }
49
50 removeComment(comment) {
51 const pos = this.comments.indexOf(comment);
52 this.comments.splice(pos, 1);
53 }
We are declaring two methods that will return a random integer and a random item
from an array, respectively.
Finally, the addComment() method will push a new comment to the list, with a random
author, random text and a random number of likes.
Next, we have the removeComment() method, that will be used to remove one
comment from the list:
Advanced Components 526
code/advanced-components/src/app/lifecycle/differs/comments-list.component.ts
50 removeComment(comment) {
51 const pos = this.comments.indexOf(comment);
52 this.comments.splice(pos, 1);
53 }
And finally we declare our change detection method ngDoCheck():
code/advanced-components/src/app/lifecycle/differs/comments-list.component.ts
55 ngDoCheck(): void {
56 const changes = this.differ.diff(this.comments);
57
58 if (changes) {
59 changes.forEachAddedItem(r => console.log('Added', r.item));
60 changes.forEachRemovedItem(r => console.log('Removed', r.item));
61 }
62 }
The iterable differ behaves the same way as the key-value differ but it only provides
methods for items that were added or removed.
When we run the app now, we get the list of comments with one comment:
Advanced Components 527
Initial state
We can also see that a few things were logged to the console, like:
1 added author with Matt
2 ...
3 added likes with 14
Let's see what happens when we add a new comment to the list by clicking the Add
button:
Advanced Components 528
Comment added
We can see that the iterable differs identified that we added a new object to the list
{author: "Hellen", comment: "Thanks!", likes: 17}.
We also got individual changes to the comment object logged, as detected by the
key-value differ:
1 added author with Helen
2 added comment with Thanks!
3 added likes with 17
Now we can click the like button for this new comment:
Advanced Components 529
Number of likes changed
And now only the like change was detected.
If we click the Clear icon, it will remove the comment key from the comment object:
Advanced Components 530
Comment text cleared
And the log confirms that we removed that key.
Finally, let's remove the last comment, by clicking the Remove icon:
Advanced Components 531
Comment removed
And as expected, we get a removed object log.
AfterContentInit, AfterViewInit, AfterContentChecked
and AfterViewChecked
The AfterContentInit hook is called after OnInit, right after the initialization of the
content of the component or directive has finished.
The AfterContentChecked works similarly, but it's called after the directive check
has finished. The check, in this context, is the change detection system check.
The other two hooks: AfterViewInit and AfterViewChecked are triggered right after
the content ones above, right after the view has been fully initialized. Those two
hooks are only applicable to components and not to directives.
Also, the AfterXXXInit hooks are only called once during the directive lifecycle,
while the AfterXXXChecked hooks are called after every change detection cycle.
Advanced Components 532
To better understand this, let's write another component that logs to the console
during each lifecycle hook. It will also have a counter that we can increment by
clicking a button:
code/advanced-components/src/app/lifecycle/all-hooks/all-hooks.component.ts
1 import {
2 Component,
3 OnInit,
4 OnDestroy,
5 DoCheck,
6 OnChanges,
7 AfterContentInit,
8 AfterContentChecked,
9 AfterViewInit,
10 AfterViewChecked
11 } from '@angular/core';
12
13 @Component({
14 selector: 'app-all-hooks',
15 templateUrl: './all-hooks.component.html'
16 })
17 export class AllHooksComponent implements OnInit,
18 OnDestroy, DoCheck,
19 OnChanges, AfterContentInit,
20 AfterContentChecked, AfterViewInit,
21 AfterViewChecked {
22 counter: number;
23
24 constructor() {
25 console.log('AllHooksComponent --------- [constructor]');
26 this.counter = 1;
27 }
28 inc() {
29 console.log('AllHooksComponent --------- [counter]');
30 this.counter += 1;
31 }
32 ngOnInit() {
33 console.log('AllHooksComponent - OnInit');
34 }
35 ngOnDestroy() {
36 console.log('AllHooksComponent - OnDestroy');
37 }
38 ngDoCheck() {
39 console.log('AllHooksComponent - DoCheck');
Advanced Components 533
40 }
41 ngOnChanges() {
42 console.log('AllHooksComponent - OnChanges');
43 }
44 ngAfterContentInit() {
45 console.log('AllHooksComponent - AfterContentInit');
46 }
47 ngAfterContentChecked() {
48 console.log('AllHooksComponent - AfterContentChecked');
49 }
50 ngAfterViewInit() {
51 console.log('AllHooksComponent - AfterViewInit');
52 }
53 ngAfterViewChecked() {
54 console.log('AllHooksComponent - AfterViewChecked');
55 }
56
57 }
Now let's add it to the app component, along with a Toggle button, like the one we
used for the OnDestroy hook:
code/advanced-components/src/app/lifecycle/all-hooks/all-hooks-demo.component.html
1 <h4 class="ui horizontal divider header">
2 AfterContentInit, AfterViewInit, AfterContentChecked and AfterViewChecked
3 </h4>
4
5 <app-all-hooks
6 *ngIf="displayAfters"
7 ></app-all-hooks>
8
9 <button class="ui primary button" (click)="toggleAfters()">
10 Toggle
11 </button>
The final implementation for the app demo component now will look like this:
Advanced Components 534
code/advanced-components/src/app/lifecycle/all-hooks/all-hooks-demo.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-all-hooks-demo',
5 templateUrl: './all-hooks-demo.component.html',
6 styles: []
7 })
8 export class AllHooksDemoComponent implements OnInit {
9 displayAfters = true;
10
11 constructor() { }
12
13 ngOnInit() { }
14
15 toggleAfters(): void {
16 this.displayAfters = !this.displayAfters;
17 }
18 }
When the application starts, we can see each hook is logged:
Advanced Components 535
App started
Now let's clear the console and click the Increment button:
Advanced Components 536
After counter increment
You can see that now only the DoCheck, AfterContentCheck and AfterViewCheck
hooks were triggered.
Sure enough, if we click the Toggle button:
Advanced Components 537
App started
And click it again:
Advanced Components 538
App started
All the hooks are triggered.
Advanced Templates
Template elements are special elements used to create views that can be dynamically
manipulated.
In order to make working with templates simpler, Angular provides some syntactic
sugar to create templates, so we often don't create them by hand.
Np. when we write:
Advanced Components 539
1 <app-comment
2 *ngFor="let comment of comments"
3 [comment]="comment"
4 (onRemove)="removeComment($event)">
5 </app-comment>
This gets converted into:
1 <app-comment
2 template="ngFor let comment of comments; #i=index"
3 [comment]="comment"
4 (onRemove)="removeComment($event)">
5 </app-comment>
Which then gets converted into:
1 <template
2 ngFor
3 [ngForOf]="comments"
4 let-comment="$implicit"
5 let-index="i">
6 <app-comment
7 [comment]="comment"
8 (onRemove)="removeComment($event)">
9 </app-comment>
10 </template>
It's important that we understand this underlying concept so we can build our own
directives.
Rewriting ngIf - ngBookIf
Let's create a directive that does exactly what ngIf does. Let's call it ngBookIf.
ngBookIf @Directive
We start by declaring the @Directive decorator for our class:
Advanced Components 540
1 @Directive({
2 selector: '[ngBookIf]'
3 })
We're using [ngBookIf] as the selector because, as we learned above, when we use
*ngBookIf="condition", it will be converted to:
1 <template ngBookIf [ngBookIf]="condition">
Since ngBookIf is also an attribute we need to indicate that we're expecting to receive
it as an input.
The job of this directive should be to add the directive template contents when the
condition is true and remove it when it's false.
So when the condition is true, we will use a view container. The view container is
used to attach one or more views to the directive.
We will use the view container to either:
• create a new view with our directive template embedded or
• clear the view container contents.
Before we do that, we need to inject the ViewContainerRef and the TemplateRef.
They will be injected with the directive's view container and template.
Here's the code we'll need:
code/advanced-components/src/app/templates/ng-book-if/ng-book-if.directive.ts
11 export class NgBookIfDirective {
12 constructor(private viewContainer: ViewContainerRef,
13 private template: TemplateRef<any>) {}
Now that we have references to both the view container and the template, we will
use a TS property setter construct and also specify that this is an input using
the Input() decorator:
Advanced Components 541
code/advanced-components/src/app/templates/ng-book-if/ng-book-if.directive.ts
15 @Input() set ngBookIf(condition) {
16 if (condition) {
17 this.viewContainer.createEmbeddedView(this.template);
18 } else {
19 this.viewContainer.clear();
20 }
21 }
22 }
This method will be called every time we set a value on the ngBookIf property
of our class. That is, this method will be called anytime the condition in ng-
BookIf="condition" changes.
Now we use the view container's createEmbeddedView method to attach the directive's
template if the condition is true, or the clear method to remove everything
from the view container.
Using ngBookIf
In order to use our directive, we can write the following demo component:
code/advanced-components/src/app/templates/ng-book-if/ng-book-if-demo.component.ts
1 import { Component } from '@angular/core';
2
3 @Component({
4 selector: 'app-ng-book-if',
5 templateUrl: './ng-book-if-demo.component.html',
6 })
7 export class NgBookIfDemoComponent {
8 display: boolean;
9
10 constructor() {
11 this.display = true;
12 }
13
14 toggle() {
15 this.display = !this.display;
16 }
17 }
and template:
Advanced Components 542
code/advanced-components/src/app/templates/ng-book-if/ng-book-if-demo.component.html
1 <button class="ui primary button" (click)="toggle()">
2 Toggle
3 </button>
4
5 <div *ngBookIf="display">
6 The message is displayed
7 </div>
When we run the application, we can see that the directive works as expected: when
we click the Toggle button the message This message is displayed is toggled on and
off the page.
Rewriting ngFor - NgBookFor
Now let's write a simplified version of the ngFor directive that Angular provides to
handle repetition of templates for a given collection.
NgBookFor template deconstruction
This directive will be used with the *NgBookFor="let var of collection" notation.
Like we did for the previous directive, we need to declare the selector as being
[NgBookFor]. However the input parameter, in this case, won't be NgBookFor only.
If we look back at how Angular converts the *sth="let var in collection"
notation, we can see that the final form of the element is the equivalent of:
1 <template sth [sthOf]="collection" let-var="$implicit">
2 <!-- ... -->
3 </template>
As we can see, the attribute that's being passed isn't sth but sthOf
instead. That's where our directive receives the collection we're iterating on.
In the template that is generated, we're going to have a local view variable #var, that
will receive the value from the $implicit local variable. That's the name of the local
variable that Angular uses when "de-sugaring" the syntax into a template.
Advanced Components 543
NgBookFor @Directive
Time to write the directive.
code/advanced-components/src/app/templates/ng-book-for/ng-book-for.directive.ts
1 import {
2 Directive,
3 IterableDiffer,
4 IterableDiffers,
5 ViewRef,
6 ViewContainerRef,
7 TemplateRef,
8 ChangeDetectorRef,
9 DoCheck,
10 Input
11 } from '@angular/core';
12
13 @Directive({
14 selector: '[ngBookFor]'
15 })
16 export class NgBookForDirective implements DoCheck {
17 private items: any;
18 private differ: IterableDiffer<any>;
19 private views: Map<any, ViewRef> = new Map<
20 any,
21 ViewRef
22 >();
23
24 constructor(
25 private viewContainer: ViewContainerRef,
26 private template: TemplateRef<any>,
27 private differs: IterableDiffers
28 ) {}
We are declaring some properties for our class:
• items holds the collection we're iterating on
• differ is an IterableDiffer (which we learned about in the Lifecycle Hooks
section above) that will be used for change detection purposes
• views is a Map that will link a given item on the collection with the view that
contains it
Advanced Components 544
The constructor will receive the viewContainer, the template and an IterableDiffers
instance (we discussed each of these things earlier in this chapter above).
Now, the next thing that's being injected is a change detector. We will have a deep
dive in change detection in the next section. For now, let's say that this is the class
that Angular creates to trigger the detection when properties of our directive change.
The next step is to write code that will trigger when we set the ngBookForOf input:
code/advanced-components/src/app/templates/ng-book-for/ng-book-for.directive.ts
31 set ngBookForOf(items) {
32 this.items = items;
33 if (this.items && !this.differ) {
34 this.differ = this.differs.find(items).create();
35 }
36 }
When we set this attribute, we're keeping the collection on the directive's items
property and if the collection is valid and we don't have a differ yet, we create one.
To do that, we're creating an instance of IterableDiffer that reuses the directive's
change detector (the one we injected in the constructor).
Now it's time to write the code that will react to a change on the collection. For
this, we're going to use the DoCheck lifecycle hook by implementing the ngDoCheck
method as follows:
code/advanced-components/src/app/templates/ng-book-for/ng-book-for.directive.ts
38 ngDoCheck(): void {
39 if (this.differ) {
40 const changes = this.differ.diff(this.items);
41 if (changes) {
42 changes.forEachAddedItem(change => {
43 const view = this.viewContainer.createEmbeddedView(
44 this.template,
45 { $implicit: change.item }
46 );
47 this.views.set(change.item, view);
48 });
49 changes.forEachRemovedItem(change => {
50 const view = this.views.get(change.item);
51 const idx = this.viewContainer.indexOf(view);
Advanced Components 545
52 this.viewContainer.remove(idx);
53 this.views.delete(change.item);
54 });
55 }
56 }
57 }
Let's break this down a bit. 1st thing we do in this method is make sure we already
instantiated the differ. If not, we do nothing.
Next, we ask the differ what changed. If there are changes, we 1st iterate through the
items that were added using changes.forEachAddedItem. This method will receive a
CollectionChangeRecord object for every element that was added.
Then for each element, we create a new embedded view using the view container's
createEmbeddedView method.
1 let view = this.viewContainer.createEmbeddedView(this.template, {'$implicit': change.item\
2 });
The second argument to createEmbeddedView is the view context. In this case, we're
setting the $implicit local variable to change.item. This will allow us to reference
the variable we declared back on the *NgBookFor="let var of collection" as var
on that view. That is, the var in let var is the $implicit variable. We use $implicit
because we don't know what name the user will assign to it when we're writing this
component.
The final thing we need to do is to connect the item with the collection to its view.
The reason behind this is that, if an item gets removed from the collection, we need
to get rid of the correct view, as we do next.
Now for each item that was removed from the collection, we use the item-to-view
map we keep to find the view. Then we ask the view container for the index of that
view. We need that because the view container's remove method needs an index.
Finally, we also remove the view from the item-to-view map.
Trying out our directive
To test our new directive, let's write the following component:
Advanced Components 546
code/advanced-components/src/app/templates/ng-book-for/ng-book-for-demo.component.ts
1 import { Component, OnInit } from '@angular/core';
2
3 @Component({
4 selector: 'app-ng-book-for-demo',
5 templateUrl: './ng-book-for-demo.component.html'
6 })
7 export class NgBookForDemoComponent implements OnInit {
8 people: any[];
9
10 constructor() { }
11
12 ngOnInit() {
13 this.people = [
14 {name: 'Joe', age: 10},
15 {name: 'Patrick', age: 21},
16 {name: 'Melissa', age: 12},
17 {name: 'Kate', age: 19}
18 ];
19 }
20
21 remove(p) {
22 const idx: number = this.people.indexOf(p);
23 this.people.splice(idx, 1);
24 return false;
25 }
26
27 add(name, age) {
28 this.people.push({name: name.value, age: age.value});
29 name.value = '';
30 age.value = '';
31 }
32 }
and template:
Advanced Components 547
code/advanced-components/src/app/templates/ng-book-for/ng-book-for-demo.component.html
1 <ul>
2 <li *ngBookFor="let p of people">
3 {{ p.name }} is {{ p.age }}
4 <a href (click)="remove(p)">Remove</a>
5 </li>
6 </ul>
7
8 <div class="ui form">
9 <div class="fields">
10 <div class="field">
11 <label>Name</label>
12 <input type="text" #name placeholder="Name">
13 </div>
14 <div class="field">
15 <label>Age</label>
16 <input type="text" #age placeholder="Age">
17 </div>
18 </div>
19 </div>
20 <div class="ui submit button"
21 (click)="add(name, age)">
22 Add
23 </div>
We're using our directive to iterate through a list of people:
code/advanced-components/src/app/templates/ng-book-for/ng-book-for-demo.component.html
1 <ul>
2 <li *ngBookFor="let p of people">
3 {{ p.name }} is {{ p.age }}
4 <a href (click)="remove(p)">Remove</a>
5 </li>
6 </ul>
When we click Remove we remove the item from the collection, triggering the
change detection.
We also provide a form that allows adding items to the collection:
Advanced Components 548
code/advanced-components/src/app/templates/ng-book-for/ng-book-for-demo.component.html
8 <div class="ui form">
9 <div class="fields">
10 <div class="field">
11 <label>Name</label>
12 <input type="text" #name placeholder="Name">
13 </div>
14 <div class="field">
15 <label>Age</label>
16 <input type="text" #age placeholder="Age">
17 </div>
18 </div>
19 </div>
20 <div class="ui submit button"
21 (click)="add(name, age)">
22 Add
23 </div>
Change Detection
As a user interacts with our app, data (state) changes and our app needs to respond
accordingly.
One of the big problems any modern JS framework needs to solve is how to
figure out when changes have happened and re-render components accordingly.
In order to make the view react to changes to components state, Angular uses change
detection.
What are the things that can trigger changes in a component's state? The most
obvious thing is user interaction. Np. if we have a component:
Advanced Components 549
1 @Component({
2 selector: 'my-component',
3 template: `
4 Name: {{name}}
5 <button (click)="changeName()">Change!</button>
6 `
7 })
8 class MyComponent {
9 name: string;
10 constructor() {
11 this.name = 'Felipe';
12 }
13
14 changeName() {
15 this.name = 'Nate';
16 }
17 }
We can see that when the user clicks on the Change! button, the component's name
property will change.
Another source of change could be, Np. a HTTP request:
1 @Component({
2 selector: 'my-component',
3 template: `
4 Name: {{name}}
5 `
6 })
7 class MyComponent {
8 name: string;
9 constructor(private http: HttpClient) {
10 this.http.get('/names/1')
11 .map(res => res.json())
12 .subscribe(data => this.name = data.name);
13 }
14 }
And finally, we could have a timer that would trigger the change:
Advanced Components 550
1 @Component({
2 selector: 'my-component',
3 template: `
4 Name: {{name}}
5 `
6 })
7 class MyComponent {
8 name: string;
9 constructor() {
10 setTimeout(() => this.name = 'Felipe', 2000);
11 }
12 }
But how does Angular become aware of these changes?
The 1st thing to know is that each component gets a change detector.
Like we've seen before, a typical application will have a number of components that
will interact with each other, creating a dependency tree like below:
Advanced Components 551
Component tree
For each component on our tree, a change detector is created and so we end up with
a tree of change detectors:
Advanced Components 552
Change detector tree
When one of the components change, no matter where it is in the tree, a change
detection pass is triggered for the whole tree. This happens because Angular scans
for changes from the top component node, all the way to the bottom leaves of the
tree.
Advanced Components 553
Default change detection
In our diagram above, the component in blue changed, but as we can see, it triggered
checks for the whole component tree. Objects that were checked are indicated in red
(note that the component itself was also checked).
It is natural to think that this check may be a very expensive operation. However,
due to a number of optimizations (that make Angular code eligible for further
optimization by the JS engine), it's actually surprisingly fast.
Customizing Change Detection
There are times that the built-in or default change detection mechanism may be
overkill. One example is if you're using immutable objects or if your application
Advanced Components 554
architecture relies on observables. In these cases, Angular provides mechanisms for
configuring the change detection system so that you get very fast performance.
The 1st way to change the change detector behavior is by telling a component that
it should only be checked if one of its input values change.
To recap, an input value is an attribute your component receives from the outside
world. Np. in this code:
1 class Person {
2 constructor(public name: string, public age: string) {}
3 }
4
5 @Component({
6 selector: 'mycomp',
7 template: `
8 <div>
9 <span class="name">{{ person.name }}</span>
10 is {{ person.age }} years old.
11 </div>
12 `
13 })
14 class MyComp {
15 @Input() person: Person;
16 }
We have person as an input attribute. Now, if we want to make this component
change only when its input attribute changes, we just need to change the change
detection strategy, by setting its changeDetection attribute to ChangeDetection-
Strategy.OnPush.
By the way, if you're curious, the default value for changeDetection is
ChangeDetectionStrategy.Default.
Let's write a small experiment with two components. The 1st one will use the default
change detection behavior and the other will use the OnPush strategy:
Advanced Components 555
code/advanced-components/src/app/change-detection/on-push-demo/profile.model.ts
1 /**
2 * User Profile object, stores the 1st and
3 * last name as well as a function that gives the time
4 **/
5 export class Profile {
6 constructor(public first: string, public last: string) {}
7
8 lastChanged() {
9 return new Date();
10 }
11 }
So we start with some imports and we declare a Profile class that will be used
as the input in both of our components. Notice that we also created a method
called lastChange() on the Profile class. It will help us determine when the change
detection is triggered. When a given component is marked as needing to be checked,
this method will be called, since it's present on the template. So this method will
reliably indicate the last time the component was checked for changes.
Next, we declare the DefaultChangeDetectionComponent that will use the default
change detection strategy:
code/advanced-components/src/app/change-detection/on-push-demo/default-changedetection.
component.ts
1 import {
2 Component,
3 Input
4 } from '@angular/core';
5 import { Profile } from './profile.model';
6
7 @Component({
8 selector: 'app-default-change-detection',
9 templateUrl: './default-change-detection.component.html'
10 })
11 export class DefaultChangeDetectionComponent {
12 @Input() profile: Profile;
13 }
and template:
Advanced Components 556
code/advanced-components/src/app/change-detection/on-push-demo/default-changedetection.
component.html
1 <h4 class="ui horizontal divider header">
2 Default Strategy
3 </h4>
4
5 <form class="ui form">
6 <div class="field">
7 <label>First Name</label>
8 <input
9 type="text"
10 [(ngModel)]="profile.first"
11 name="first"
12 placeholder="First Name">
13 </div>
14 <div class="field">
15 <label>Last Name</label>
16 <input
17 type="text"
18 [(ngModel)]="profile.last"
19 name="last"
20 placeholder="Last Name">
21 </div>
22 </form>
23
24 <h5><em>Updates if either changes (e.g. more often)</em></h5>
25 <div>
26 {{profile.lastChanged() | date:'medium'}}
27 </div>
And a second component using OnPush strategy:
Advanced Components 557
code/advanced-components/src/app/change-detection/on-push-demo/on-push-changedetection.
component.ts
1 import {
2 Component,
3 Input,
4 ChangeDetectionStrategy
5 } from '@angular/core';
6 import { Profile } from './profile.model';
7
8 @Component({
9 selector: 'app-on-push-change-detection',
10 changeDetection: ChangeDetectionStrategy.OnPush,
11 templateUrl: './on-push-change-detection.component.html'
12 })
13 export class OnPushChangeDetectionComponent {
14 @Input() profile: Profile;
15 }
As we can see, both components use the same template. The only thing that is
different is the header.
Finally, let's add the component that will render both components side by side:
code/advanced-components/src/app/change-detection/on-push-demo/on-pushdemo.
component.ts
1 import { Component } from '@angular/core';
2 import { Profile } from './profile.model';
3
4 @Component({
5 selector: 'app-on-push-demo',
6 template: `
7 <div class="ui page grid">
8 <div class="two column row">
9 <div class="column area">
10 <app-default-change-detection
11 [profile]="profile1">
12 </app-default-change-detection>
13 </div>
14 <div class="column area">
15 <app-on-push-change-detection
16 [profile]="profile2">
17 </app-on-push-change-detection>
18 </div>
Advanced Components 558
19 </div>
20 </div>
21 `
22 })
23 export class OnPushDemoComponent {
24 profile1: Profile = new Profile('Felipe', 'Coury');
25 profile2: Profile = new Profile('Nate', 'Murray');
26 }
When we run this application, we should see both components rendered like below:
Default vs. OnPush strategies
When we change sth on the component on the left, with the default strategy,
we notice that the timestamp for the component on the right doesn't change:
Advanced Components 559
OnPush changed, default got checked
To understand why this happened, let's check this new tree of components:
Advanced Components 560
Tree of components
Angular checks for changes from the top to the bottom, so it queried 1st OnPushDemoComponent,
then DefaultChangeDetectionComponent and finally OnPushChangeDetectionComponent.
When it inferred that OnPushChangeDetectionComponent changed,
it updates all the components of the tree, from top to bottom, making the Default-
ChangeDetectionComponent to be rendered again.
Now when we change the value of the component on the right:
Advanced Components 561
Default changed, OnPush didn't get checked
So now the change detection engine kicked in, the DefaultChangeDetectionComponent
component was checked but OnPushChangeDetectionComponent wasn't. This
happened because when we set the OnPush strategy for this component, it made the
change detection kick in for this component only when one of its input attributes
change. Changing other components of the tree doesn't trigger this component's
change detector.
Zones
Under the hood, Angular uses a library called Zones to automatically detect changes
and trigger the change detection mechanism. Zones will automatically tell Angular
that sth changed under the most common scenarios:
• when a DOM Event occurs (like click, change, etc.)
• when an HTTP request is resolved
• when a Timer is triggered (setTimeout or setInterval)
Advanced Components 562
However, there are scenarios where Zones won't be able to automatically identify
that sth changed. That's another scenario where the OnPush strategy can be
very useful.
A few examples of things that are out of the Zones control, would be:
• using a third party library that runs asynchronously
• immutable data
• Observables
these are perfect candidates for using OnPush along with a technique to manually
hint Angular that sth changed.
Observables and OnPush
Let's write a component that receives an Observable as a parameter. Every time we
receive a value from this observable, we will increment a counter that is a property
of the component.
If we were using the regular change detection strategy, any time we incremented the
counter, we would get change detection triggered by Angular. However, we will have
this component use the OnPush strategy and, instead of letting the change detector
kick in for each increment, we'll only kick it when the number is a multiple of 5 or
when the observable completes.
In order to do that, let's write our component:
code/advanced-components/src/app/change-detection/observables-demo/observable-changedetection.
component.ts
1 import {
2 Component,
3 OnInit,
4 Input,
5 ChangeDetectionStrategy,
6 ChangeDetectorRef
7 } from '@angular/core';
8 import { Observable } from 'rxjs/Rx';
9
10 @Component({
11 selector: 'app-observable-change-detection',
Advanced Components 563
12 changeDetection: ChangeDetectionStrategy.OnPush,
13 template: `
14 <div>
15 <div>Total items: {{counter}}</div>
16 </div>
17 `
18 })
19 export class ObservableChangeDetectionComponent implements OnInit {
20 @Input() items: Observable<number>;
21 counter = 0;
22
23 constructor(private changeDetector: ChangeDetectorRef) {
24 }
25
26 ngOnInit() {
27 this.items.subscribe((v) => {
28 console.log('got value', v);
29 this.counter++;
30 if (this.counter % 5 === 0) {
31 this.changeDetector.markForCheck();
32 }
33 },
34 null,
35 () => {
36 this.changeDetector.markForCheck();
37 });
38 }
39 }
Let's break down the code a bit so we can make sure we understand. 1st, we're
declaring the component to take items as the input attribute and to use the OnPush
detection strategy:
Advanced Components 564
code/advanced-components/src/app/change-detection/observables-demo/observable-changedetection.
component.ts
10 @Component({
11 selector: 'app-observable-change-detection',
12 changeDetection: ChangeDetectionStrategy.OnPush,
13 template: `
14 <div>
15 <div>Total items: {{counter}}</div>
16 </div>
17 `
18 })
Next, we're storing our input attribute on the items property of the component class,
and setting another property, called counter, to 0.
code/advanced-components/src/app/change-detection/observables-demo/observable-changedetection.
component.ts
19 export class ObservableChangeDetectionComponent implements OnInit {
20 @Input() items: Observable<number>;
21 counter = 0;
Then we use the constructor to get hold of the component's change detector:
code/advanced-components/src/app/change-detection/observables-demo/observable-changedetection.
component.ts
23 constructor(private changeDetector: ChangeDetectorRef) {
24 }
Then, during the component initialization, on the ngOnInit hook:
Advanced Components 565
code/advanced-components/src/app/change-detection/observables-demo/observable-changedetection.
component.ts
26 ngOnInit() {
27 this.items.subscribe((v) => {
28 console.log('got value', v);
29 this.counter++;
30 if (this.counter % 5 === 0) {
31 this.changeDetector.markForCheck();
32 }
33 },
34 null,
35 () => {
36 this.changeDetector.markForCheck();
37 });
38 }
We're subscribing to the Observable. The subscribe method takes three callbacks as
arguments: onNext, onError and onCompleted.
Our onNext callback will print out the value we got, then increment the counter.
Finally, if the current counter value is a multiple of 5, we call the change detector's
markForCheck method. That's the method we use whenever we want to tell Angular
that a change has been made, so the change detector should kick in.
Then for the onError callback, we're using null, indicating we don't want to handle
this scenario.
Finally, for the onComplete callback, we're also triggering the change detector, so the
final counter can be displayed.
Now, on to the application component code, that will create the subscriber:
Advanced Components 566
code/advanced-components/src/app/change-detection/observables-demo/observablesdemo.
component.ts
1 import { Component, OnInit } from '@angular/core';
2 import { Observable } from 'rxjs/Rx';
3
4 @Component({
5 selector: 'app-observables-demo',
6 template: `
7 <app-observable-change-detection
8 [items]="itemObservable">
9 </app-observable-change-detection>
10 `
11 })
12 export class ObservablesDemoComponent implements OnInit {
13 itemObservable: Observable<number>;
14
15 constructor() { }
16
17 ngOnInit() {
18 this.itemObservable = Observable.timer(100, 100).take(101);
19 }
20
21 }
The important line here is the following:
1 this.itemObservable = Observable.timer(100, 100).take(101);
This line creates the Observable we're passing to the component on the items
input attribute. We're passing two parameters to the timer method: the 1st is the
number of milliseconds to wait before producing the 1st value and the second is
the milliseconds to wait between values. So this observable will generate sequential
values every 100 values forever.
Since we don't want the observable to run forever, we use the take method, to take
only the 1st 101 values.
When we run this code, we'll see that the counter will only be updated for each
5 values obtained from the observer and also when the observable completes,
generating a final value of 101:
Advanced Components 567
Manually triggering change detection
Summary
Angular provides us with many tools we can use for writing advanced components.
Using the techniques in this chapter you will be able to write nearly any component
functionality you wish.
Testing
After spending hours, days, months on a web app you're finally ready to release it to
the world. Plenty of hard work and time has been poured into it and now it's time for
it to pay off… and then boom: a blocking bug shows up that prevents anyone from
signing up.
Test driven?
Testing can help reveal bugs before they appear, instill confidence in your web
application and makes it easy to onboard new developers into the application. There
is little doubt about the power of testing amongst the world of software development.
However, there is debate about how to go about it.
Is it better to write the tests 1st and then write the implementation to make those
tests pass or would it be better to validate that code that we've already written
is correct? It's pretty odd to think that this is a source of contention across the
development community, but there is a debate that can get pretty heated as to which
is the right way to handle testing.
In our experience, particularly when coming from a prototype-heavy background,
we focus on building test-able code. Although your experience may differ, we have
found that while we are prototyping applications, testing individual pieces of code
that are likely to change can double or triple the amount of work it takes to keep them
up. In contrast, we focus on building our applications in small components, keeping
large amounts of functionality broken into several methods which allows us to test
the functionality of a part of the larger picture. This is what we mean when we say
testable code.
An alternative methodology to prototyping (and then testing after) is called
"Red-Green-Refactor". The idea is that you write your tests 1st and they
fail (red) because you haven't written any code yet. Only after you have
failing tests do you go on to write your implementation code until it all
passes (green).
Testing 569
Of course, the decision of what to test is up to you and your team, however we'll
focus on how to test your applications in this chapter.
End-to-end vs. Unit Testing
There are two major ways to test your applications: end-to-end testing or unit testing.
If you take a top-down approach on testing you write tests that see the application
as a "black box" and you interact with the application like a user would and evaluate
if the app seems to work from the "outside". This top-down technique of testing is
called End to End testing.
In the Angular world, the tool that is mostly used is called Protractor¹³³.
Protractor is a tool that opens a browser and interacts with the application,
collecting results, to check whether the testing expectations were met.
The second testing approach commonly used is to isolate each part of the application
and test it in isolation. This form of testing is called Unit Testing.
In Unit Testing we write tests that provide a given input to a given aspect of that unit
and evaluate the output to make sure it matches our expectations.
In this chapter we're going to be covering how to unit test your Angular apps.
Testing Tools
In order to test our apps, we'll use two tools: Jasmine and Karma.
Jasmine
Jasmine¹³⁴ is a behavior-driven development framework for testing JS code.
Using Jasmine, you can set expectations about what your code should do when
invoked.
¹³³https://angular.github.io/protractor/#/
¹³⁴http://jasmine.github.io/2.4/introduction.html
Testing 570
Np. let's assume we have a sum function on a Calculator object. We want
to make sure that adding 1 and 1 results in 2. We could express that test (also called
a _spec), by writing the following code:
describe('Calculator', () ) { it('sums 1 and 1 to 2', () ) { var calc = new Calculator();
expect(calc.sum(1, 1)).toEqual(2); }); });
One of the nice things about Jasmine is how readable the tests are. You can see here
that we expect the calc.sub operation to equal 2.
We organize our tests with describe blocks and it blocks.
Normally we use describe for each logical unit we're testing and inside that we use
one it for each expectation you want to assert. However, this isn't a hard and fast
rule. You'll often see an it block contain several expectations.
On the Calculator example above we have a very simple object. For that reason, we
used one describe block for the whole class and one it block for each method.
This is not the case most of the times. Np. methods that produce different
outcomes depending on the input will probably have more than one it block
associated. On those cases, it's perfectly fine to have nested describes: one for the
object and one for each method and then different assertions inside individual it
blocks.
We'll be looking at a lot of describe and it blocks throughout this chapter, so don't
worry if it isn't clear when to use one vs. the other. We'll be showing lots of examples.
For more information about Jasmine and all its syntax, check out the Jasmine
documentation page¹³⁵.
Karma
With Jasmine we can describe our tests and their expectations. Now, in order to
actually run the tests we need to have a browser environment.
That's where Karma comes in. Karma allows us to run JS code within a
browser like Chrome or Firefox, or on a headless browser (or a browser that doesn't
expose a user interface) like PhantomJS.
¹³⁵http://jasmine.github.io/2.4/introduction.html
Testing 571
Writing Unit Tests
Our main focus on this section will be to understand how we write unit tests against
different parts of our Angular apps.
We're going to learn to test Services, Components, HTTP requests and more. Along
the way we're also going to see a couple of different techniques to make our code
more testable.
Angular Unit testing framework
Angular provides its own set of classes that build upon the Jasmine framework to
help writing unit testing for the framework.
The main testing framework can be found on the @angular/core/testing package.
(Although, for testing components we'll use the @angular/compiler/testing package
and @angular/platform-browser/testing for some other helpers. But more on
that later.)
If this is your 1st time testing Angular I want to prepare you for sth:
When you write tests for Angular, there is a bit of setup.
Np. when we have dependencies to inject, we often manually
configure them. When we want to test a component, we have to use testinghelpers
to initialize them. And when we want to test routing, there are quite
a few dependencies we need to structure.
If it feels like there is a lot of setup, don't worry: you'll get the hang of it
and find that the setup doesn't change that much from project to project.
Besides, we'll walk you through each step in this chapter.
As always, you can find all of the sample code for this chapter in the
code download. Looking over the code directly in your favorite editor can
provide a good overview of the details we cover in this chapter. We'd
encourage you to keep the code open as you go through this chapter.
Testing 572
Setting Up Testing
Earlier in the Routing Chapter we created an application for searching for music. In
this chapter, let's write tests for that application.
Karma requires a configuration in order to run. So the 1st thing we need to do to
setup Karma is to create a karma.conf.js file.
Let's karma.conf.js file on the root path of our project, like so:
Since we're using Angular CLI, this karma.conf.js file is already created
for us! However, if your project does not use Angular CLI, you may need
to setup Karma on your own.
code/routes/music/karma.conf.js
1 // Karma configuration file, see link for more information
2 // https://karma-runner.github.io/1.0/config/configuration-file.html
3
4 module.exports = function(config) {
5 let configuration = {
6 basePath: '',
7 frameworks: ['jasmine', '@angular-devkit/build-angular'],
8 plugins: [
9 require('karma-jasmine'),
10 require('karma-chrome-launcher'),
11 require('karma-jasmine-html-reporter'),
12 require('karma-coverage-istanbul-reporter'),
13 require('@angular-devkit/build-angular/plugins/karma')
14 ],
15 client: {
16 clearContext: false // leave Jasmine Spec Runner output visible in browser
17 },
18 coverageIstanbulReporter: {
19 dir: require('path').join(__dirname, '../coverage'),
20 reports: ['html', 'lcovonly'],
21 fixWebpackSourcePaths: true
22 },
23 reporters: ['progress', 'kjhtml'],
24 port: 9876,
25 colors: true,
26 logLevel: config.LOG_INFO,
Testing 573
27 autoWatch: true,
28 browsers: ['Chrome'],
29 singleRun: false
30 };
31
32 if (process.env.TRAVIS) {
33 configuration.customLaunchers = {
34 Chrome_travis_ci: {
35 base: 'Chrome',
36 flags: ['--no-sandbox']
37 }
38 };
39 configuration.browsers = ['Chrome_travis_ci'];
40 }
41
42 config.set(configuration);
43 };
Don't worry too much about this file's contents right now, just keep in mind a few
things about it:
• sets PhantomJS as the target testing browser;
• uses Jasmine karma framework for testing;
• uses a WebPack bundle called test.bundle.js that basically wraps all our
testing and app code;
The next step is to create a new test folder to hold our test files.
mkdir test
Testing Services and HTTP
Services in Angular start out their life as plain classes. In one sense, this makes our
services easy to test because we can sometimes test them directly without using
Angular.
With Karma configuration done, let's start testing the SpotifyService class. If we
remember, this service works by interacting with the Spotify API to retrieve album,
track and artist information.
Testing 574
Inside the test folder, let's create a service subfolder where all our service tests will
go. Finally, let's create our 1st test file inside it, called spotify.service.spec.ts.
Now we can start putting this test file together. The 1st thing we need to do is import
the test helpers from the @angular/core/testing package:
code/routes/music/src/app/spotify.service.spec.ts
1 import { inject, fakeAsync, tick, TestBed } from "@angular/core/testing";
Next, we'll import a couple more classes:
code/routes/music/src/app/spotify.service.spec.ts
2 import {
3 HttpTestingController,
4 HttpClientTestingModule
5 } from "@angular/common/http/testing";
6 import {
7 HttpClient,
8 HttpBackend,
9 HttpRequest,
10 HttpResponse,
11 HttpHandler
12 } from "@angular/common/http";
Since our service uses HTTP requests, we'll import the HttpTestingController
class from @angular/common/http/testing package. This class will help us set
expectations and verify HTTP requests.
The last thing we need to import is the class we're testing:
code/routes/music/src/app/spotify.service.spec.ts
14 import { SpotifyService } from "./spotify.service";
HTTP Considerations
We could start writing our tests right now, but during each test execution we would
be calling out and hitting the Spotify server. This is far from ideal for two reasons:
Testing 575
1. HTTP requests are relatively slow and as our test suite grows, we'd notice it
takes longer and longer to run all of the tests.
2. Spotify's API has a quota and if our whole team is running the tests, we might
use up our API call resources needlessly
3. If we are offline or if Spotify is down or inaccessible our tests would start
breaking, even though our code might technically be correct
This is a good hint when writing unit tests: isolate everything that you don't control
before testing.
In our case, this piece is the Spotify service. The solution is that we will replace the
HTTP request with sth that would behave like it, but will not hit the real
Spotify server.
Doing this in the testing world is called mocking a dependency. They are sometimes
also called stubbing a dependency.
You can read more about the difference between Mocks and Stubs in this
article Mocks are not Stubs¹³⁶
Let's pretend we're writing code that depends on a given Car class.
This class has a bunch of methods: you can start a car instance, stop it, park it and
getSpeed of that car.
Let's see how we could use stubs and mocks to write tests that depend on this class.
Stubs
Stubs are objects we create on the fly, with a subset of the behaviors our dependency
has.
Let's write a test that just interacts with the start method of the class.
You could create a stub of that Car class on-the-fly and inject that into the class
you're testing:
¹³⁶http://martinfowler.com/articles/mocksArentStubs.html
Testing 576
describe("Speedtrap", function() {
it("tickets a car at more than 60mph", function() {
var stubCar = {
getSpeed: function() {
return 61;
}
};
var speedTrap = new SpeedTrap(stubCar);
speedTrap.ticketCount = 0;
speedTrap.checkSpeed();
expect(speedTrap.ticketCount).toEqual(1);
});
});
This would be a typical case for using a stub and we'd probably only use it locally to
that test.
Mocks
Mocks in our case will be a more complete representation of objects, that overrides
parts or all of the behavior of the dependency. Mocks can and most of the time will
be reused by more than one test across our suite.
They will also be used sometimes to assert that given methods were called the way
they were supposed to be called.
One example of a mock version of our Car class would be:
class MockCar {
startCallCount: number = 0;
start() {
this.startCallCount++;
}
}
And it would be used to write another test like this:
Testing 577
describe("CarRemote", function() {
it("starts the car when the start key is held", function() {
var car = new MockCar();
var remote = new CarRemote();
remote.holdButton("start");
expect(car.startCallCount).toEqual(1);
});
});
The biggest difference between a mock and a stub is that:
• a stub provides a subset of functionality with "manual" behavior overrides
whereas
• a mock generally sets expectations and verifies that certain methods were called
HttpClient HttpTestingController
Now that we have this background in mind, let's go back to writing our service test
code.
Interacting with the live Spotify service every time we run our tests is a poor idea
but thankfully Angular provides us with a way to create fake HTTP calls with
HttpTestingController.
This class can be injected into a HttpClient instance and gives us control of how
we want the HTTP interaction to act. We can interfere and assert in a variety of
different ways: we can manually set a response, simulate an HTTP error and add
expectations, like asserting the URL being requested matches what we want, if the
provided request parameters are correct and a lot more.
So the idea here is that we're going to provide our code with a "fake" HttpClient
library. This "fake" library will appear to our code to be the real HttpClient library:
all of the methods will match, it will return responses and so on. However, we're not
actually going to make the requests.
In fact, beyond not making the requests, our HttpTestingController will actually
allow us to setup expectations and watch for behaviors we expect.
Testing 578
TestBed.configureTestingModule and Providers
When we test our Angular apps we need to make sure we configure the top-level
NgModule that we will use for this test. When we do this, we can configure providers,
declare components and import other modules: just like you would when using
NgModules generally.
Sometimes when testing Angular code, we manually setup injections. This is good
because it gives us more control over what we're actually testing.
So in the case of testing HttpClient requests, we don't want to inject the "real"
HttpClient class, but instead we want to inject sth that looks like HttpClient,
but really intercepts the requests and returns the responses we configure.
To do that, we create a version of the HttpClient class that uses HttpTestingController
internally.
To do this, we use the TestBed.configureTestingModule in the beforeEach hook.
This hook takes a callback function that will be called before each test is run, giving
us a great opportunity to configure alternative class implementations.
code/routes/music/src/app/spotify.service.spec.ts
16 describe("SpotifyService", () => {
17 beforeEach(() => {
18 TestBed.configureTestingModule({
19 imports: [HttpClientTestingModule],
20 providers: [SpotifyService]
21 });
22 });
Notice that TestBed.configureTestingModule accepts an array of providers in the
providers key to be used by the test injector.
Testing getTrack
Now, when writing tests for the service, we want to verify that we're calling the
correct URL.
If you haven't looked at the Routing chapter music example in a while, you
can find the code for this example here
Testing 579
Let's write a test for the getTrack method:
code/routes/music/src/app/spotify.service.ts
42 getTrack(id: string): Observable<any> {
43 return this.query(`/tracks/${id}`);
44 }
If you remember how that method works, it uses the query method, that builds the
URL based on the parameters it receives:
code/routes/music/src/app/spotify.service.ts
18 query(URL: string, params?: Array<string>): Observable<any> {
19 let queryURL = `${SpotifyService.BASE_URL}${URL}`;
20 if (params) {
21 queryURL = `${queryURL}?${params.join("&")}`;
22 }
23 const apiKey = environment.spotifyApiKey;
24 const headers = new HttpHeaders({
25 Authorization: `Bearer ${apiKey}`
26 });
27 const options = {
28 headers: headers
29 };
30
31 return this.http.request("GET", queryURL, options);
32 }
Since we're passing /tracks/${id} we assume that when calling getTrack('TRACK_-
ID') the expected URL will be https://api.spotify.com/v1/tracks/TRACK_ID.
Here is how we write the test for this:
Testing 580
describe("getTrack", () => {
it("retrieves using the track ID", inject(
[SpotifyService, HttpTestingController],
fakeAsync((spotifyService, mockBackend) => {
var res;
mockBackend.connections.subscribe(c => {
expect(c.request.url).toBe(
"https://api.spotify.com/v1/tracks/TRACK_ID"
);
let response = new ResponseOptions({ body: '{"name": "felipe"}' });
c.mockRespond(new Response(response));
});
spotifyService.getTrack("TRACK_ID").subscribe(_res => {
res = _res;
});
tick();
expect(res.name).toBe("felipe");
})
));
});
This seems like a lot to grasp at 1st, so let's break it down a bit:
Every time we write tests with dependencies, we need to ask Angular injector to
provide us with the instances of those classes. To do that we use:
inject([Class1, /* ..., */ ClassN], (instance1, /* ..., */ instanceN) => {
// ... testing code ...
});
When you are testing code that returns either a Promise or an RxJS Observable,
you can use fakeAsync helper to test that code as if it were synchronous. This way
Promises are fulfilled and Observables are notified immediately after you call tick().
So in this code:
Testing 581
inject(
[SpotifyService, HttpTestingController],
fakeAsync((spotifyService, mockBackend) => {
// ... testing code ...
})
);
We're getting two variables: spotifyService and mockBackend. The 1st one has a
concrete instance of the SpotifyService and the second is an instance HttpTesting-
Controller class. Notice that the arguments to the inner function (spotifyService,
mockBackend) are injections of the classes specified in the 1st argument array of the
inject function (SpotifyService and HttpTestingController).
We're also running inside fakeAsync which means that async code will be run
synchronously when tick() is called.
Now that we've setup the injections and context for our test, we can start writing our
"actual" test. We start by declaring a res variable that will eventually get the HTTP
call response. Next we subscribe to mockBackend.connections:
var res;
mockBackend.connections.subscribe(c => { ... });
Here we're saying that whenever a new connection comes in to mockBackend we
want to be notified (e.g. call this function).
We want to verify that the SpotifyService is calling out to the correct URL
given the track id TRACK_ID. So what we do is specify an expectation that the
URL is as we would expect. We can get the URL from the connection c via
c.request.url. So we setup an expectation that c.request.url should be the string
'https://api.spotify.com/v1/tracks/TRACK_ID':
expect(c.request.url).toBe("https://api.spotify.com/v1/tracks/TRACK_ID");
When our test is run, if the request URL doesn't match, then the test will fail.
Now that we've received our request and verified that it is correct, we need to craft
a response. We do this by creating a new ResponseOptions instance. Here we specify
that it will return the JSON string: {"name": "felipe"} as the body of the response.
Testing 582
let response = new ResponseOptions({ body: '{"name": "felipe"}' });
Finally, we tell the connection to replace the response with a Response object that
wraps the ResponseOptions instance we created:
c.mockRespond(new Response(response));
An interesting thing to note here is that your callback function in subscribe
can be as sophisticated as you wish it to be. You could have conditional logic
based on the URL, query parameters, or anything you can read from the
request object etc.
This allows us to write tests for nearly every possible scenario our code
might encounter.
We have now everything setup to call the getTrack method with TRACK_ID as a
parameter and tracking the response in our res variable:
spotifyService.getTrack("TRACK_ID").subscribe(_res => {
res = _res;
});
If we ended our test here, we would be waiting for the HTTP call to be made and
the response to be fulfilled before the callback function would be triggered. It would
also happen on a different execution path and we'd have to orchestrate our code to
sync things up. Thankfully using fakeAsync takes that problem away. All we need
to do is call tick() and, like magic, our async code will be executed:
tick();
We now perform one final check just to make sure our response we setup is the one
we received:
expect(res.name).toBe("felipe");
If you think about it, the code for all the methods of this service are very similar. So
let's extract the snippet we use to setup the URL expectation into a function called
expectURL:
Testing 583
code/routes/music/src/app/spotify.service.spec.ts
25 function expectURL(backend: HttpTestingController, url: string) {
26 const testRequest = backend.expectOne(url);
27 testRequest.flush({ name: "felipe" });
28 return testRequest;
29 }
Following the same lines, it should be very simple to create similar tests for getArtist
and getAlbum methods:
code/routes/music/src/app/spotify.service.spec.ts
49 describe("getArtist", () => {
50 it("retrieves using the artist ID", inject(
51 [SpotifyService, HttpTestingController],
52 fakeAsync((svc, backend) => {
53 let res;
54 svc.getArtist("ARTIST_ID").subscribe(_res => {
55 res = _res;
56 });
57 expectURL(backend, "https://api.spotify.com/v1/artists/ARTIST_ID");
58 tick();
59 expect(res.name).toBe("felipe");
60 })
61 ));
62 });
63
64 describe("getAlbum", () => {
65 it("retrieves using the album ID", inject(
66 [SpotifyService, HttpTestingController],
67 fakeAsync((svc, backend) => {
68 let res;
69 svc.getAlbum("ALBUM_ID").subscribe(_res => {
70 res = _res;
71 });
72 expectURL(backend, "https://api.spotify.com/v1/albums/ALBUM_ID");
73 tick();
74 expect(res.name).toBe("felipe");
75 })
76 ));
77 });
Testing 584
Now searchTrack is slightly different: instead of calling query, this method uses the
search method:
code/routes/music/src/app/spotify.service.ts
38 searchTrack(query: string): Observable<any> {
39 return this.search(query, "track");
40 }
And then search calls query with /search as the 1st argument and an Array
containing q=<query> and type=track as the second argument:
code/routes/music/src/app/spotify.service.ts
34 search(query: string, type: string): Observable<any> {
35 return this.query(`/search`, [`q=${query}`, `type=${type}`]);
36 }
Finally, query will transform the parameters into a URL path with a QueryString. So
now, the URL we expect to call ends with /search?q=<query>&type=track.
Let's now write the test for searchTrack that takes into consideration what we
learned above:
code/routes/music/src/app/spotify.service.spec.ts
79 describe("searchTrack", () => {
80 it("searches type and term", inject(
81 [SpotifyService, HttpTestingController],
82 fakeAsync((svc, backend) => {
83 let res;
84 svc.searchTrack("TERM").subscribe(_res => {
85 res = _res;
86 });
87 expectURL(
88 backend,
89 "https://api.spotify.com/v1/search?q=TERM&type=track"
90 );
91 tick();
92 expect(res.name).toBe("felipe");
93 })
94 ));
95 });
Testing 585
The test ended up also being very similar to the ones we wrote so far. Let's review
what this test does:
• it hooks into the HTTP lifecycle, by adding a callback when a new HTTP
connection is initiated
• it sets an expectation for the URL we expect the connection to use including
the query type and the search term
• it calls the method we're testing, searchTrack
• it then tells Angular to complete all the pending async calls
• it finally asserts that we have the expected response
In essence, when testing services our goals should be:
1. Isolate all the dependencies by using stubs or mocks
2. In case of async calls, use fakeAsync and tick to make sure they are fulfilled
3. Call the service method you're testing
4. Assert that the returning value from the method matches what we expect
Now let's move on to the classes that usually consume the services: components.
Testing Routing to Components
When testing components, we can either:
1. write tests that will interact with the component from the outside, passing
attributes in and checking how the markup is affected or
2. test individual component methods and their output.
Those test strategies are known as black box and white box testing, respectively.
During this section, we'll see a mix of both.
We'll begin by writing tests for the ArtistComponent class, which is one of the simpler
components we have. This initial set of tests will test the component's internals, so
it falls into the white box category of testing.
Before we jump into it, let's remember what ArtistComponent does:
The 1st thing we do on the class constructor is retrieve the id from the routeParams
collection:
Testing 586
code/routes/music/src/app/artist/artist.component.ts
22 constructor(private route: ActivatedRoute, private spotify: SpotifyService,
23 private location: Location) {
24 route.params.subscribe(params => { this.id = params['id']; });
25 }
And with that we have our 1st obstacle. How can we retrieve the ID of a route
without an available running router?
Creating a Router for Testing
Remember that when we write tests in Angular we manually configure many of the
classes that are injected. Routing (and testing components) has a daunting number of
dependencies that we need to inject. That said, once it's configured, it isn't sth
we change very much and it's very easy to use.
When we write tests it's often convenient to use beforeEach with TestBed.configureTestingModule
to set the dependencies that can be injected. In the case of testing our ArtistComponent
we're going to create a custom function that will create and configure our
router for testing:
code/routes/music/src/app/artist/artist.component.spec.ts
21 describe('ArtistComponent', () => {
22 beforeEach(async(() => {
23 configureMusicTests();
24 }));
We define configureMusicTests in the helper file MusicTestHelpers.ts. Let's look
at that now.
Here's the implementation of configureMusicTests. Don't worry, we'll explain each
part:
Testing 587
code/routes/music/src/app/test/test.module.ts
68 export function configureMusicTests() {
69 const mockSpotifyService: MockSpotifyService = new MockSpotifyService();
70
71 TestBed.configureTestingModule({
72 imports: [
73 { // TODO RouterTestingModule.withRoutes coming soon
74 ngModule: RouterTestingModule,
75 providers: [provideRoutes(routerConfig)]
76 },
77 TestModule
78 ],
79 providers: [
80 mockSpotifyService.getProviders(),
81 {
82 provide: ActivatedRoute,
83 useFactory: (r: Router) => r.routerState.root, deps: [ Router ]
84 }
85 ]
86 });
87 }
We start by creating an instance of MockSpotifyService that we will use to mock
the real implementation of SpotifyService.
Next we use a class called TestBed and call configureTestingModule. TestBed is a
helper library that ships with Angular to help make testing easier.
In this case, TestBed.configureTestingModule is used to configure the NgModule
used for testing. You can see that we provide an NgModule configuration as the
argument which has:
• imports and
• providers
In our imports we're importing
• The RouterTestingModule and configuring it with our routerConfig - this
configures the routes for testing
Testing 588
• The TestModule - which is the NgModule which declares all of the components
we will test (see MusicTestHelpers.ts for the full details)
In providers
• We provide the MockSpotifyService (via mockSpotifyService.getProviders())
• and the ActivatedRoute
Let's take a closer look at these starting with the Router.
Router
One thing we haven't talked about yet is what routes we want to use when testing.
There are many different ways of doing this. 1st we'll look at what we're doing
here:
code/routes/music/src/app/test/test.module.ts
32 @Component({
33 selector: 'blank-cmp',
34 template: ``
35 })
36 export class BlankCmp {
37 }
38
39 @Component({
40 selector: 'root-cmp',
41 template: `<router-outlet></router-outlet>`
42 })
43 export class RootCmp {
44 }
45
46 export const routerConfig: Routes = [
47 { path: '', component: BlankCmp },
48 { path: 'search', component: SearchComponent },
49 { path: 'artists/:id', component: ArtistComponent },
50 { path: 'tracks/:id', component: TrackComponent },
51 { path: 'albums/:id', component: AlbumComponent }
52 ];
Testing 589
Here instead of redirecting (like we do in the real router config) for the empty URL,
we're just using BlankCmp.
Of course, if you want to use the same RouterConfig as in your top-level app then
all you need to do is export it somewhere and import it here.
If you have a more complex scenario where you need to test lots of different
route configurations, you could even accept a parameter to the musicTestProviders
function where you use a new router configuration each time.
There are many possibilities here and you'll need to pick whichever fits best for your
team. This configuration works for cases where your routes are relatively static and
one configuration works for all of the tests.
Now that we have all of the dependencies, we create the new Router and call
r.initialNavigation() on it.
ActivatedRoute
The ActivatedRoute service keeps track of the "current route". It requires the Router
itself as a dependency so we put it in deps and inject it.
MockSpotifyService
Earlier we tested our SpotifyService by mocking out the HTTP library that backed
it. Instead here, we're going to mock out the whole service itself. Let's look at how
we can mock this out, or any, service.
Mocking dependencies
If you look inside music/test you'll find a mocks/spotify.ts file. Let's take a look:
Testing 590
code/routes/music/src/app/test/spotify.service.mock.ts
1 import {SpyObject} from './test.helpers';
2 import {SpotifyService} from '../spotify.service';
3
4 export class MockSpotifyService extends SpyObject {
5 getAlbumSpy;
6 getArtistSpy;
7 getTrackSpy;
8 searchTrackSpy;
9 mockObservable;
10 fakeResponse;
Here we're declaring the MockSpotifyService class, which will be a mocked version
of the real SpotifyService. These instance variables will act as spies.
Spies
A spy is a specific type of mock object that gives us two benefits:
1. we can simulate return values and
2. count how many times the method was called and with which parameters.
In order to use spies with Angular, we're using the internal SpyObject class (it's used
by Angular to test itself).
You can either declare a class by creating a new SpyObject on the fly or you can
make your mock class inherit from SpyObject, like we're doing in our code.
The great thing inheriting or using this class gives us is the spy method. The spy
method lets us override a method and force a return value (as well as watch and
ensure the method was called). We use spy on our class constructor:
Testing 591
code/routes/music/src/app/test/spotify.service.mock.ts
12 constructor() {
13 super(SpotifyService);
14
15 this.fakeResponse = null;
16 this.getAlbumSpy = this.spy('getAlbum').and.returnValue(this);
17 this.getArtistSpy = this.spy('getArtist').and.returnValue(this);
18 this.getTrackSpy = this.spy('getTrack').and.returnValue(this);
19 this.searchTrackSpy = this.spy('searchTrack').and.returnValue(this);
20 }
The 1st line of the constructor call's the SpyObject constructor, passing the concrete
class we're mocking. Calling super(...) is optional, but when you do the mock class
it will inherit all the concrete class methods, so you can override just the pieces you're
testing.
If you're curious about how SpyObject is implemented you
can check it on the angular/angular repository, on the file
/modules/angular2/src/testing/testing_internal.ts¹³⁷
After calling super, we're initializing the fakeResponse field, that we'll use later to
null.
Next we declare spies that will replace the concrete class methods. Having a reference
to them will be helpful to set expectations and simulate responses while writing our
tests.
When we use the SpotifyService within the ArtistComponent, the real getArtist
method returns an Observable and the method we're calling from our components
is the subscribe method:
¹³⁷https://github.com/angular/angular/blob/b0cebdba6b65c1e9e7eb5bf801ea42dc7c4a7f25/modules/angular2/src/
testing/testing_internal.ts#L205
Testing 592
code/routes/music/src/app/artist/artist.component.ts
27 ngOnInit(): void {
28 this.spotify
29 .getArtist(this.id)
30 .subscribe((res: any) => this.renderArtist(res));
31 }
However, in our mock service, we're going to do sth tricky: instead of returning
an observable from getArtist, we're returning this, the MockSpotifyService
itself. That means the return value of this.spotify.getArtist(this.id) above will
be the MockSpotifyService.
There's one problem with doing this though: our ArtistComponent was expecting to
call subscribe on an Observable. To account for this, we're going to define subscribe
on our MockSpotifyService:
code/routes/music/src/app/test/spotify.service.mock.ts
22 subscribe(callback) {
23 callback(this.fakeResponse);
24 }
Now when subscribe is called on our mock, we're immediately calling the callback,
making the async call happen synchronously.
The other thing you'll notice is that we're calling the callback function with
this.fakeResponse. This leads us to the next method:
code/routes/music/src/app/test/spotify.service.mock.ts
26 setResponse(json: any): void {
27 this.fakeResponse = json;
28 }
This method doesn't replace anything on the concrete service, but is instead a helper
method to allow the test code to set a given response (that would come from the
service on the concrete class) and with that simulate different responses.
Testing 593
code/routes/music/src/app/test/spotify.service.mock.ts
30 getProviders(): Array<any> {
31 return [{ provide: SpotifyService, useValue: this }];
32 }
This last method is a helper method to be used in TestBed.configureTestingModule
providers like we'll see later when we get back to writing component tests.
Here's what our MockSpotifyService looks like altogether:
code/routes/music/src/app/test/spotify.service.mock.ts
1 import {SpyObject} from './test.helpers';
2 import {SpotifyService} from '../spotify.service';
3
4 export class MockSpotifyService extends SpyObject {
5 getAlbumSpy;
6 getArtistSpy;
7 getTrackSpy;
8 searchTrackSpy;
9 mockObservable;
10 fakeResponse;
11
12 constructor() {
13 super(SpotifyService);
14
15 this.fakeResponse = null;
16 this.getAlbumSpy = this.spy('getAlbum').and.returnValue(this);
17 this.getArtistSpy = this.spy('getArtist').and.returnValue(this);
18 this.getTrackSpy = this.spy('getTrack').and.returnValue(this);
19 this.searchTrackSpy = this.spy('searchTrack').and.returnValue(this);
20 }
21
22 subscribe(callback) {
23 callback(this.fakeResponse);
24 }
25
26 setResponse(json: any): void {
27 this.fakeResponse = json;
28 }
29
30 getProviders(): Array<any> {
31 return [{ provide: SpotifyService, useValue: this }];
Testing 594
32 }
33 }
Back to Testing Code
Now that we have all our dependencies under control, it is easier to write our tests.
Let's write our test for our ArtistComponent.
As usual, we start with imports:
code/routes/music/src/app/artist/artist.component.spec.ts
1 import {
2 async,
3 ComponentFixture,
4 TestBed,
5 inject,
6 fakeAsync,
7 } from '@angular/core/testing';
8 import { Router } from '@angular/router';
9 import { Location } from '@angular/common';
10 import {
11 advance,
12 createRoot,
13 RootCmp,
14 configureMusicTests
15 } from '../test/test.module';
16
17 import { MockSpotifyService } from '../test/spotify.service.mock';
18 import { SpotifyService } from '../spotify.service';
19 import { ArtistComponent } from './artist.component';
Next, before we can start to describe our tests configureMusicTests to ensure we
can access our musicTestProviders in each test:
Testing 595
code/routes/music/src/app/artist/artist.component.spec.ts
21 describe('ArtistComponent', () => {
22 beforeEach(async(() => {
23 configureMusicTests();
24 }));
Next, we'll write a test for everything that happens during the initialization of the
component. 1st, let's take a refresh look at what happens on initialization of our
ArtistComponent:
code/routes/music/src/app/artist/artist.component.ts
18 export class ArtistComponent implements OnInit {
19 id: string;
20 artist: Object;
21
22 constructor(private route: ActivatedRoute, private spotify: SpotifyService,
23 private location: Location) {
24 route.params.subscribe(params => { this.id = params['id']; });
25 }
26
27 ngOnInit(): void {
28 this.spotify
29 .getArtist(this.id)
30 .subscribe((res: any) => this.renderArtist(res));
31 }
Remember that during the creation of the component, we use route.params to
retrieve the current route id param and store it on the id attribute of the class.
When the component is initialized ngOnInit is triggered by Angular (because we
declared that this component implements OnInit. We then use the SpotifyService
to retrieve the artist for the received id and we subscribe to the returned observable.
When the artist is finally retrieved, we call renderArtist, passing the artist data.
An important idea here is that we used dependency injection to get the SpotifyService,
but remember, we created a MockSpotifyService!
So in order to test this behavior, let's:
1. Use our router to navigate to the ArtistComponent, which will initialize the
component
Testing 596
2. Check our MockSpotifyService and ensure that the ArtistComponent did,
indeed, try to get the artist with the appropriate id.
Here's the code for our test:
code/routes/music/src/app/artist/artist.component.spec.ts
26 describe('initialization', () => {
27 it('retrieves the artist', fakeAsync(
28 inject([Router, SpotifyService],
29 (router: Router,
30 mockSpotifyService: MockSpotifyService) => {
31 const fixture = createRoot(router, RootCmp);
32
33 router.navigateByUrl('/artists/2');
34 advance(fixture);
35
36 expect(mockSpotifyService.getArtistSpy).toHaveBeenCalledWith('2');
37 })));
38 });
Let's take it step by step.
fakeAsync and advance
We start by wrapping the test in fakeAsync. Without getting too bogged down in
the details, by using fakeAsync we're able to have more control over when change
detection and asynchronous operations occur. A consequence of this is that we need
to explicitly tell our components that they need to detect changes after we make
changes in our tests.
Normally you don't need to worry about this when writing your apps, as zones tend
to do the right thing, but during tests we manipulate the change detection process
more carefully.
If you skip a few lines down you'll notice that we're using a function called advance
that comes from our MusicTestHelpers. Let's take a look at that function:
Testing 597
code/routes/music/src/app/test/test.module.ts
54 export function advance(fixture: ComponentFixture<any>): void {
55 tick();
56 fixture.detectChanges();
57 }
So we see here that advance does two things:
1. It tells the component to detect changes and
2. Calls tick()
When we use fakeAsync, timers are actually synchronous and we use tick() to
simulate the asynchronous passage of time.
Practically speaking, in our tests we'll call advance whenever we want Angular to
"work it's magic". So Np. whenever we navigate to a new route, update a
form element, make an HTTP request etc. we'll call advance to give Angular a chance
to do it's thing.
inject
In our test we need some dependencies. We use inject to get them. The inject
function takes two arguments:
1. An array of tokens to inject
2. A function into which to provide the injections
And what classes will inject use? The providers we defined in TestBed.configureTestingModule
providers.
Notice that we're injecting:
1. Router
2. SpotifyService
Testing 598
The Router that will be injected is the Router we configured in musicTestProviders
above.
For SpotifyService, notice that we're requesting injection of the token Spotify-
Service, but we're receiving a MockSpotifyService. A little tricky, but hopefully it
makes sense given what we've talked about so far.
Testing ArtistComponent's Initialization
Let's review the contents of our actual test:
code/routes/music/src/app/artist/artist.component.spec.ts
31 const fixture = createRoot(router, RootCmp);
32
33 router.navigateByUrl('/artists/2');
34 advance(fixture);
35
36 expect(mockSpotifyService.getArtistSpy).toHaveBeenCalledWith('2');
We start by creating an instance of our RootCmp by using createRoot. Let's look at
the createRoot helper function:
code/routes/music/src/app/test/test.module.ts
59 export function createRoot(router: Router,
60 componentType: any): ComponentFixture<any> {
61 const f = TestBed.createComponent(componentType);
62 advance(f);
63 (<any>router).initialNavigation();
64 advance(f);
65 return f;
66 }
Notice here that when we call createRoot we
1. Create an instance of the root component
2. advance it
3. Tell the router to setup it's initialNavigation
Testing 599
4. advance again
5. return the new root component.
This is sth we'll do a lot when we want to test a component that depends on
routing, so it's handy to have this helper function around.
Notice that we're using the TestBed library again to call TestBed.createComponent.
This function creates a component of the appropriate type.
RootCmp is an empty component that we created in MusicTestHelpers.
You definitely don't need to create an empty component for your root
component, but I like to do it this way because it lets us test our child
component (ArtistComponent) more-or-less in isolation. That is, we don't
have to worry about the effects of the parent app component.
That said, maybe you want to make sure that the child component operates
correctly in context. In that case instead of using RootCmp you'd probably
want to use your app's normal parent component.
Next we use router to navigate to the url /artists/2 and advance. When we
navigate to that URL, ArtistComponent should be initialized, so we assert that the
getArtist method of the SpotifyService was called with the proper value.
Testing ArtistComponent Methods
Recall that the ArtistComponent has an href which calls the back() function.
code/routes/music/src/app/artist/artist.component.ts
33 back(): void {
34 this.location.back();
35 }
Let's test that when the back method is called, the router will redirect the user back
to the previous location.
The current location state is controlled by the Location service. When we need to
send the user back to the previous location, we use the Location's back method.
Here is how we test the back method:
Testing 600
code/routes/music/src/app/artist/artist.component.spec.ts
40 describe('back', () => {
41 it('returns to the previous location', fakeAsync(
42 inject([Router, Location],
43 (router: Router, location: Location) => {
44 const fixture = createRoot(router, RootCmp);
45 expect(location.path()).toEqual('/');
46
47 router.navigateByUrl('/artists/2');
48 advance(fixture);
49 expect(location.path()).toEqual('/artists/2');
50
51 const artist = fixture.debugElement.children[1].componentInstance;
52 artist.back();
53 advance(fixture);
54
55 expect(location.path()).toEqual('/');
56 })));
57 });
The initial structure is similar: we inject our dependencies and create a new
component.
We have a new expectation - we assert that the location.path() is equal to what
we expect it to be.
We also have another new idea: we're accessing the methods on the ArtistComponent
itself. We get a reference to our ArtistComponent instance through the line
fixture.debugElement.children[1].componentInstance.
Now that we have the instance of the component, we're able to call methods on it
directly, like back().
After we call back() we advance and then verify that the location.path() is what
we expected it to be.
Testing ArtistComponent DOM Template Values
The last thing we need to test on ArtistComponent is the template that renders the
artist.
Testing 601
code/routes/music/src/app/artist/artist.component.html
1 <div *ngIf="artist">
2 <h1>{{ artist.name }}</h1>
3
4 <p>
5 <img src="{{ artist.images[0].url }}">
6 </p>
7
8 <p><a href (click)="back()">Back</a></p>
9 </div>
Remember that the instance variable artist is set by the result of the SpotifyService
getArtist call. Since we're mocking the SpotifyService with MockSpotifyService,
the data we should have in our template should be whatever the mockSpotifyService
returns. Let's look at how we do this:
code/routes/music/src/app/artist/artist.component.spec.ts
59 describe('renderArtist', () => {
60 it('renders album info', fakeAsync(
61 inject([Router, SpotifyService],
62 (router: Router,
63 mockSpotifyService: MockSpotifyService) => {
64 const fixture = createRoot(router, RootCmp);
65
66 const artist = {name: 'ARTIST NAME', images: [{url: 'IMAGE_1'}]};
67 mockSpotifyService.setResponse(artist);
68
69 router.navigateByUrl('/artists/2');
70 advance(fixture);
71
72 const compiled = fixture.debugElement.nativeElement;
73
74 expect(compiled.querySelector('h1').innerHTML).toContain('ARTIST NAME');
75 expect(compiled.querySelector('img').src).toContain('IMAGE_1');
76 })));
77 });
The 1st thing that's new here is that we're manually setting the response of the
mockSpotifyService with setResponse.
Testing 602
The artist variable is a fixture that represents what we get from the Spotify API
when we call the artists endpoint at GET https://api.spotify.com/v1/artists/{id}.
Here's what the real JSON looks like:
Postman - Spotify Get Artist Endpoint
However, for this test we need only the name and images properties.
When we call the setResponse method, that response will be used for the next call
we make to any of the service methods. In this case, we want the method getArtist
to return this response.
Next we navigate with the router and advance. Now that the view is rendered, we
Testing 603
can use the DOM representation of the component's view to check if the artist was
properly rendered.
We do that by getting the nativeElement property of the DebugElement with the line
fixture.debugElement.nativeElement.
In our assertions, we expect to see H1 tag containing the artist's name, in our case
the string ARTIST NAME (because of our artist fixture above).
To check those conditions, we use the NativeElement's querySelector method. This
method will return the 1st element that matches the provided CSS selector.
For the H1 we check that the text is indeed ARTIST NAME and for the image, we check
its src property is IMAGE 1.
With this, we are done testing the ArtistComponent class.
Testing Forms
To write form tests, let's use the DemoFormWithEventsComponent component we
created back in the Forms chapter. This example is a good candidate because it uses
a few features of Angular's forms:
• it uses a FormBuilder
• has validations
• handles events
As a reminder, here's the full code for that class:
Testing 604
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.ts
1 import { Component, OnInit } from '@angular/core';
2 import {
3 FormBuilder,
4 FormGroup,
5 Validators,
6 AbstractControl
7 } from '@angular/forms';
8
9 @Component({
10 selector: 'app-demo-form-with-events',
11 templateUrl: './demo-form-with-events.component.html',
12 styles: []
13 })
14 export class DemoFormWithEventsComponent implements OnInit {
15 myForm: FormGroup;
16 sku: AbstractControl;
17
18 ngOnInit() {
19 }
20
21 constructor(fb: FormBuilder) {
22 this.myForm = fb.group({
23 'sku': ['', Validators.required]
24 });
25
26 this.sku = this.myForm.controls['sku'];
27
28 this.sku.valueChanges.subscribe(
29 (value: string) => {
30 console.log('sku changed to:', value);
31 }
32 );
33
34 this.myForm.valueChanges.subscribe(
35 (form: any) => {
36 console.log('form changed to:', form);
37 }
38 );
39
40 }
41
42 onSubmit(form: any): void {
43 console.log('you submitted value:', form.sku);
Testing 605
44 }
45
46 }
And the template:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.html
1 <div class="ui raised segment">
2 <h2 class="ui header">Demo Form: with events</h2>
3 <form [formGroup]="myForm"
4 (ngSubmit)="onSubmit(myForm.value)"
5 class="ui form">
6
7 <div class="field"
8 [class.error]="!sku.valid && sku.touched">
9 <label for="skuInput">SKU</label>
10 <input type="text"
11 class="form-control"
12 id="skuInput"
13 placeholder="SKU"
14 [formControl]="sku">
15 <div *ngIf="!sku.valid"
16 class="ui error message">SKU is invalid</div>
17 <div *ngIf="sku.hasError('required')"
18 class="ui error message">SKU is required</div>
19 </div>
20
21 <div *ngIf="!myForm.valid"
22 class="ui error message">Form is invalid</div>
23
24 <button type="submit" class="ui button">Submit</button>
25 </form>
26 </div>
Just to recap, this code will have the following behavior:
• when no value is present for the SKU field, two validation error will be
displayed: SKU is invalid and SKU is required
• when the value of the SKU field changes, we are logging a message to the
console
Testing 606
• when the form changes, we are also logging to the console
• when the form is submitted, we log yet another final message to the console
It seems that one obvious external dependency we have is the console. As we learned
before, we need to somehow mock all external dependencies.
Creating a ConsoleSpy
This time, instead of using a SpyObject to create a mock, let's do sth simpler,
since all we're using from the console is the log method.
We will replace the original console instance, that is held on the window.console
object and replace by an object we control: a ConsoleSpy.
code/forms/src/app/utils.ts
14 export class ConsoleSpy {
15 public logs: string[] = [];
16 log(...args) {
17 this.logs.push(args.join(' '));
18 }
19 warn(...args) {
20 this.log(...args);
21 }
22 }
The ConsoleSpy is an object that will take whatever is logged, naively convert it to
a string and store it in an internal list of things that were logged.
Testing 607
To accept a variable number of arguments on our version of the
console.log method, we are using ES6 and TS's Rest parameters
¹³⁸.
This operator, represented by an ellipsis, like ...theArgs as our function
argument. In a nutshell using it indicates that we're going to capture all the
remaining arguments from that point on. If we had sth like (a, b,
...theArgs) and called func(1, 2, 3, 4, 5), a would be 1, b would be 2
and theArgs would have [3, 4, 5].
You can play with it yourself if you have a recent version of Node.js¹³⁹
installed:
$ node –harmony > var test = (a, b, …theArgs) ) console.
log('a=',a,'b=',b,'theArgs=',theArgs); undefined > test(1,2,3,4,5); a=
1 b= 2 theArgs= [ 3, 4, 5 ]
So instead of writing it to the console itself, we'll be storing them on an array. If the
code under test calls console.log three times:
console.log("First message", "is", 123);
console.log("Second message");
console.log("Third message");
We expect the _logs field to have an array of ['First message is 123', 'Second
message', 'Third message'].
Installing the ConsoleSpy
To use our spy in our test we start by declaring two variables: originalConsole will
keep a reference to the original console instance and fakeConsole that will hold the
mocked version of the console. We also declare a few variables that will be helpful
in testing our input and form elements.
¹³⁸https://developer.mozilla.org/en/docs/Web/JS/Reference/Functions/rest_parameters
¹³⁹https://nodejs.org/en/
Testing 608
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
20 describe('DemoFormWithEventsComponent', () => {
21 let component: DemoFormWithEventsComponent;
22 let fixture: ComponentFixture<DemoFormWithEventsComponent>;
23
24 let originalConsole, fakeConsole;
25 let el, input, form;
And then we can install the fake console and specify our providers:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
27 beforeEach(async(() => {
28 // replace the real window.console with our spy
29 fakeConsole = new ConsoleSpy();
30 originalConsole = window.console;
31 (<any>window).console = fakeConsole;
32
33 TestBed.configureTestingModule({
34 imports: [ FormsModule, ReactiveFormsModule ],
35 declarations: [ DemoFormWithEventsComponent ]
36 })
37 .compileComponents();
38 }));
Back to the testing code, the next thing we need to do is replace the real console
instance with ours, saving the original instance.
Finally, on the afterAll method, we restore the original console instance to make
sure it doesn't leak into other tests.
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
49 // restores the real console
50 afterAll(() => (<any>window).console = originalConsole);
Configuring the Testing Module
Notice that in the beforeEach we call TestBed.configureTestingModule - remember
that configureTestingModule sets up the root NgModule for our tests.
Testing 609
In this case we're importing the two forms modules and declaring the DemoFormWith-
Events component.
Now that we have control of the console, let's begin testing our form.
Testing The Form
Now we need to test the validation errors and the events of the form.
The 1st thing we need to do is to get the references to the SKU input field and to
the form elements:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
43 it('validates and triggers events', fakeAsync( () => {
44 fixture = TestBed.createComponent(DemoFormWithEventsComponent);
45 component = fixture.componentInstance;
46 el = fixture.debugElement.nativeElement;
47 input = fixture.debugElement.query(By.css('input')).nativeElement;
48 form = fixture.debugElement.query(By.css('form')).nativeElement;
49 fixture.detectChanges();
The last line tells Angular to commit all the pending changes, similar to what we
did in the routing section above. Next, we will set the SKU input value to the empty
string:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
51 input.value = '';
52 dispatchEvent(input, 'input');
53 fixture.detectChanges();
54 tick();
Here we use dispatchEvent to notify Angular that the input element changed, and
then we trigger the change detection a second time. Finally we use tick() to make
sure all asynchronous code triggered up to this point gets executed.
The reason we are using fakeAsync and tick on this test, is to assure the form events
are triggered. If we used async and inject instead, we would finish the code before
the events were triggered.
Testing 610
Now that we have changed the input value, let's make sure the validation is working.
We ask the component element (using the el variable) for all child elements that are
error messages and then making sure we have both error messages displayed:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
57 let msgs = el.querySelectorAll('.ui.error.message');
58 expect(msgs[0].innerHTML).toContain('SKU is invalid');
59 expect(msgs[1].innerHTML).toContain('SKU is required');
Next, we will do sth similar, but this time we set a value to the SKU field:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
62 input.value = 'XYZ';
63 dispatchEvent(input, 'input');
64 fixture.detectChanges();
65 tick();
And make sure all the error messages are gone:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
67 msgs = el.querySelectorAll('.ui.error.message');
68 expect(msgs.length).toEqual(0);
Finally, we will trigger the submit event of the form:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
70 fixture.detectChanges();
71 dispatchEvent(form, 'submit');
72 tick();
And finally we make sure the event was kicked by checking that the message we log
to the console when the form is submitted is there:
Testing 611
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.1.spec.ts
74 // checks for the form submitted message
75 expect(fakeConsole.logs).toContain('you submitted value: XYZ');
We could continue and add new verifications for the other two events our form
triggers: the SKU change and the form change events. However, our test is growing
quite long.
When we run our tests, we see it passes:
DemoFormWithEvents test output
This test works, but stylistically we have some code smells:
• a really long it condition (more than 5-10 lines)
• more than one or two expects per it condition
• the word and on the test description
Refactoring Our Form Test
Let's fix that by 1st extracting the code that creates the component and gets the
component element and also the elements for the input and for the form:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
41 fixture = TestBed.createComponent(DemoFormWithEventsComponent);
The createComponent code is pretty straightforward: Creates the component with
TestBed.createComponent, retrieves all the elements we need and calls detectChanges.
Now the 1st thing we want to test is that given an empty SKU field, we should see
two error messages:
Testing 612
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
52 it('displays errors with no sku', fakeAsync( () => {
53 input.value = '';
54 dispatchEvent(input, 'input');
55 fixture.detectChanges();
56
57 // no value on sku field, all error messages are displayed
58 const msgs = el.querySelectorAll('.ui.error.message');
59 expect(msgs[0].innerHTML).toContain('SKU is invalid');
60 expect(msgs[1].innerHTML).toContain('SKU is required');
61 }));
See how much cleaner this is? Our test is focused and tests only one thing. Great job!
This new structure makes adding the second test easy. This time we want to test that,
once we add a value to the SKU field, the error messages are gone:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
63 it('displays no errors when sku has a value', fakeAsync( () => {
64 input.value = 'XYZ';
65 dispatchEvent(input, 'input');
66 fixture.detectChanges();
67
68 const msgs = el.querySelectorAll('.ui.error.message');
69 expect(msgs.length).toEqual(0);
70 }));
One thing you may have noticed is that so far, our tests are not using fakeAsync, but
async plus inject instead.
That's another bonus of this refactoring: we will only use fakeAsync and tick()
when we want to check if sth was added to the console, because that's all our
form's event handlers do.
The next test will do exactly that - when the SKU value changes, we should have a
message logged to the console:
Testing 613
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
72 it('handles sku value changes', fakeAsync( () => {
73 input.value = 'XYZ';
74 dispatchEvent(input, 'input');
75 tick();
76
77 expect(fakeConsole.logs).toContain('sku changed to: XYZ');
78 }));
We can write similar code for both the form change…
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
80 it('handles form changes', fakeAsync(() => {
81 input.value = 'XYZ';
82 dispatchEvent(input, 'input');
83 tick();
84
85 expect(fakeConsole.logs).toContain('form changed to: [object Object]');
86 }));
… and the form submission events:
code/forms/src/app/demo-form-with-events/demo-form-with-events.component.spec.ts
88 it('handles form submission', fakeAsync((tcb) => {
89 input.value = 'ABC';
90 dispatchEvent(input, 'input');
91 tick();
92
93 fixture.detectChanges();
94 dispatchEvent(form, 'submit');
95 tick();
96
97 expect(fakeConsole.logs).toContain('you submitted value: ABC');
98 }));
When we run the tests now, we get a much nicer output:
Testing 614
DemoFormWithEvents test output after refactoring
Another great benefit from this refactor can be seen when sth goes wrong.
Let's go back to the component code and change the message when the form gets
submitted, in order to force one of our tests to fail:
onSubmit(form: any): void {
console.log('you have submitted the value:', form.sku);
}
If we ran the previous version of the test, here's what would happen:
DemoFormWithEvents error output before refactoring
It's not immediately obvious what failed. We have to read the error code to realize
it was the submission message that failed. We also can't be sure if that was the only
thing that broke on the component code, since we may have other test conditions
after the one that failed that never had a chance to be executed.
Now, compare that to the error we get from our refactored code:
Testing 615
DemoFormWithEvents error output after refactoring
This version makes it pretty obvious that the only thing that failed was the form
submission event.
Testing HTTP requests
We could test the HTTP interaction in our apps using the same strategy as we used
so far: write a mock version of the HttpClient or HttpClient class, since it is an
external dependency.
But since the vast majority of single page apps written using frameworks like Angular
use HTTP interaction to talk to APIs, the Angular testing library already provides a
built in alternative: HttpTestingController.
Let's dive a little deeper now and see some more testing scenarios and also some
good practices. In order to do this, let's write tests for the examples from the HTTP
chapter.
First, let's see how we test different HTTP methods, like POST or DELETE and how
to test the correct HTTP headers are being sent.
Back on the HTTP chapter, we created this example that covered how to do those
things using HttpClient.
Testing a POST
The 1st test we'll write is to make sure we're doing a proper POST request on the
makePost method:
Testing 616
code/http/src/app/more-http-requests/more-http-requests.component.ts
20 makePost(): void {
21 this.loading = true;
22 this.http
23 .post(
24 'https://jsonplaceholder.typicode.com/posts',
25 JSON.stringify({
26 body: 'bar',
27 title: 'foo',
28 userId: 1
29 })
30 )
31 .subscribe(data => {
32 this.data = data;
33 this.loading = false;
34 });
35 }
When writing our test for this method, our goal is to test two things:
1. the request method (POST) is correct and that
2. the URL we're hitting is also correct.
Here's how we turn that into a test:
First, we'll need to setup our tests to use the HttpClientTestingModule and HttpTestingController:
code/src/app/more-http-requests/more-http-requests.component.spec.ts
1 import {
2 async,
3 inject,
4 ComponentFixture,
5 TestBed
6 } from '@angular/core/testing';
7
8 import { HttpClient, HttpRequest, HttpHeaders } from '@angular/common/http';
9 import {
10 HttpTestingController,
11 HttpClientTestingModule
Testing 617
12 } from '@angular/common/http/testing';
13
14 import { MoreHttpRequestsComponent } from './more-http-requests.component';
15
16 describe('MoreHttpRequestsComponent', () => {
17 let component: MoreHttpRequestsComponent;
18 let fixture: ComponentFixture<MoreHttpRequestsComponent>;
19 let httpMock: HttpTestingController;
20
21 beforeEach(
22 async(() => {
23 TestBed.configureTestingModule({
24 declarations: [MoreHttpRequestsComponent],
25 imports: [HttpClientTestingModule]
26 });
27 })
28 );
29
30 beforeEach(
31 async(
32 inject([HttpTestingController], _httpMock => {
33 fixture = TestBed.createComponent(MoreHttpRequestsComponent);
34 component = fixture.componentInstance;
35 fixture.detectChanges();
36 httpMock = _httpMock;
37 })
38 )
39 );
40
41 afterEach(
42 inject([HttpTestingController], (httpMock: HttpTestingController) => {
43 httpMock.verify();
44 })
45 );
Above, we configure our testing module to import the HttpClientTestingModule.
Then we inject HttpTestingController and store it as a variable in httpMock.
Now we're ready to write our test:
Testing 618
code/src/app/more-http-requests/more-http-requests.component.spec.ts
47 it(
48 'performs a POST',
49 async(() => {
50 component.makePost();
51
52 const req = httpMock.expectOne(
53 'https://jsonplaceholder.typicode.com/posts'
54 );
55 expect(req.request.method).toEqual('POST');
56 req.flush({ response: 'OK' });
57 expect(component.data).toEqual({ response: 'OK' });
58
59 httpMock.verify();
60 })
61 );
We start by call the makePost() function directly on the component. This might look
odd because we don't typically call functions directly on our components. But what
we're trying to do here is cause the HTTP request to be made, that way we can test
expectations on it.
Next we use the instance variable httpMock and expect that one request was made
to jsonplaceholder by using the expectOne function.
The line req.flush will send a "mock" response to that HTTP request and then we
expect that the component.data matches that response.
Lastly, we call httpMock.verify() to finalize any remaining expectations.
Now that we understand how this works, adding a second test for DELETE method
is straightforward.
Testing DELETE
Here's how the makeDelete method is implemented:
Testing 619
code/http/src/app/more-http-requests/more-http-requests.component.ts
37 makeDelete(): void {
38 this.loading = true;
39 this.http
40 .delete('https://jsonplaceholder.typicode.com/posts/1')
41 .subscribe(data => {
42 this.data = data;
43 this.loading = false;
44 });
45 }
And this is the code we use to test it:
src/app/more-http-requests/more-http-requests.component.spec.ts
63 it(
64 'performs a DELETE',
65 async(() => {
66 component.makeDelete();
67
68 const req = httpMock.expectOne(
69 'https://jsonplaceholder.typicode.com/posts/1'
70 );
71
72 expect(req.request.method).toEqual('DELETE');
73 req.flush({ response: 'OK' });
74 expect(component.data).toEqual({ response: 'OK' });
75
76 httpMock.verify();
77 })
78 );
Everything here is the same, except for the URL that changes a bit and the HTTP
method, which is now RequestMethod.Delete.
Testing HTTP Headers
The last method we have to test on this class is makeHeaders:
Testing 620
code/http/src/app/more-http-requests/more-http-requests.component.ts
47 makeHeaders(): void {
48 const headers: HttpHeaders = new HttpHeaders({
49 'X-API-TOKEN': 'ng-book'
50 });
51
52 const req = new HttpRequest(
53 'GET',
54 'https://jsonplaceholder.typicode.com/posts/1',
55 {
56 headers: headers
57 }
58 );
59
60 this.http.request(req).subscribe(data => {
61 this.data = data['body'];
62 });
63 }
In this case, what our test should focus on is making sure the header X-API-TOKEN is
being properly set to ng-book:
src/app/more-http-requests/more-http-requests.component.spec.ts
80 it(
81 'sends correct headers',
82 async(() => {
83 component.makeHeaders();
84
85 const req = httpMock.expectOne(
86 req =>
87 req.headers.has('X-API-TOKEN') &&
88 req.headers.get('X-API-TOKEN') == 'ng-book'
89 );
90
91 req.flush({ response: 'OK' });
92 expect(component.data).toEqual({ response: 'OK' });
93
94 httpMock.verify();
95 })
96 );
Testing 621
The req.headers attribute returns the headers and we're using two methods to
perform two different assertions:
• the has method to check whether a given header was set, ignoring it's value
• the get method, that returns the value that was set
If having the header set is sufficient, use has. Otherwise, if you need to inspect the
set value, use get.
Now let's move to a more complex example.
Testing YouTubeSearchService
Back in the HTTP chapter we also built a YouTube video search. The HTTP
interaction for that example takes place on a service called YouTubeSearchService:
code/http/src/app/you-tube-search/you-tube-search.service.ts
26 /**
27 * YouTubeService connects to the YouTube API
28 * See: * https://developers.google.com/youtube/v3/docs/search/list
29 */
30 @Injectable()
31 export class YouTubeSearchService {
32 constructor(
33 private http: HttpClient,
34 @Inject(YOUTUBE_API_KEY) private apiKey: string,
35 @Inject(YOUTUBE_API_URL) private apiUrl: string
36 ) {}
37
38 search(query: string): Observable<SearchResult[]> {
39 const params: string = [
40 `q=${query}`,
41 `key=${this.apiKey}`,
42 `part=snippet`,
43 `type=video`,
44 `maxResults=10`
45 ].join('&');
46 const queryUrl = `${this.apiUrl}?${params}`;
47 return this.http.get(queryUrl).map(response => {
48 return <any>response['items'].map(item => {
Testing 622
49 // console.log("raw item", item); // uncomment if you want to debug
50 return new SearchResult({
51 id: item.id.videoId,
52 title: item.snippet.title,
53 description: item.snippet.description,
54 thumbnailUrl: item.snippet.thumbnails.high.url
55 });
56 });
57 });
58 }
59 }
It uses the YouTube API to search for videos and parse the results into a SearchResult
instance:
code/http/src/app/you-tube-search/search-result.model.ts
5 export class SearchResult {
6 id: string;
7 title: string;
8 description: string;
9 thumbnailUrl: string;
10 videoUrl: string;
11
12 constructor(obj?: any) {
13 this.id = obj && obj.id || null;
14 this.title = obj && obj.title || null;
15 this.description = obj && obj.description || null;
16 this.thumbnailUrl = obj && obj.thumbnailUrl || null;
17 this.videoUrl = obj && obj.videoUrl ||
18 `https://www.youtube.com/watch?v=${this.id}`;
19 }
20 }
The important aspects of this service we need to test are that:
• given a JSON response, the service is able to parse the video id, title, description
and thumbnail
• the URL we are requesting uses the provided search term
• the URL starts with what is set on the YOUTUBE_API_URL constant
• the API key used matches the YOUTUBE_API_KEY constant
With that in mind, let's start writing our test:
Testing 623
code/http/src/app/you-tube-search/you-tube-search.component.before.spec.ts
25 describe('YouTubeSearchComponent (before)', () => {
26 let component: YouTubeSearchComponent;
27 let fixture: ComponentFixture<YouTubeSearchComponent>;
28
29 beforeEach(
30 async(() => {
31 TestBed.configureTestingModule({
32 declarations: [
33 YouTubeSearchComponent,
34 SearchResultComponent,
35 SearchBoxComponent
36 ],
37 imports: [HttpClientTestingModule],
38 providers: [
39 YouTubeSearchService,
40 { provide: YOUTUBE_API_KEY, useValue: 'YOUTUBE_API_KEY' },
41 { provide: YOUTUBE_API_URL, useValue: 'YOUTUBE_API_URL' }
42 ]
43 });
44 })
45 );
As we did for every test we wrote on this chapter, we start by declaring how we want
to setup our dependencies: we're using the real YouTubeSearchService instance, but
setting fake values for YOUTUBE_API_KEY and YOUTUBE_API_URL constants. We're also
importing the HttpClientTestingModule.
Now, let's begin to write our 1st test case:
code/http/src/app/you-tube-search/you-tube-search.component.before.spec.ts
53 describe('search', () => {
54 it(
55 'parses YouTube response',
56 inject(
57 [YouTubeSearchService, HttpTestingController],
58 fakeAsync((service, httpMock) => {
59 let res;
60
61 service.search('hey').subscribe(_res => {
62 res = _res;
63 });
Testing 624
64
65 const req = httpMock.expectOne({ method: 'GET' });
66 req.flush({
67 items: [
68 {
69 id: { videoId: 'VIDEO_ID' },
70 snippet: {
71 title: 'TITLE',
72 description: 'DESCRIPTION',
73 thumbnails: {
74 high: { url: 'THUMBNAIL_URL' }
75 }
76 }
77 }
78 ]
79 });
80
81 tick();
82
83 const video = res[0];
84 expect(video.id).toEqual('VIDEO_ID');
85 expect(video.title).toEqual('TITLE');
86 expect(video.description).toEqual('DESCRIPTION');
87 expect(video.thumbnailUrl).toEqual('THUMBNAIL_URL');
88
89 httpMock.verify();
90 })
91 )
92 );
93 });
Here we're calling the method we're testing: search. We're calling it with the term
hey and capturing the response on the res variable.
Here we are telling HttpClient to return a fake response that will match the relevant
fields what we expect the YouTube API to respond when we call the real URL. We
do that by using the req.flush method of the connection.
Testing 625
code/http/src/app/you-tube-search/you-tube-search.component.before.spec.ts
66 req.flush({
67 items: [
68 {
69 id: { videoId: 'VIDEO_ID' },
70 snippet: {
71 title: 'TITLE',
72 description: 'DESCRIPTION',
73 thumbnails: {
74 high: { url: 'THUMBNAIL_URL' }
75 }
76 }
77 }
78 ]
79 });
If you noticed before, we're using fakeAsync that requires us to manually sync
asynchronous code by calling tick(). When we do that here, we expect that the
search finished executing and our res variable to have a value.
Now is the time to evaluate that value:
code/http/src/app/you-tube-search/you-tube-search.component.before.spec.ts
83 const video = res[0];
84 expect(video.id).toEqual('VIDEO_ID');
85 expect(video.title).toEqual('TITLE');
86 expect(video.description).toEqual('DESCRIPTION');
87 expect(video.thumbnailUrl).toEqual('THUMBNAIL_URL');
We are getting the 1st element from the list of responses. We know it's a SearchResult,
so we're now checking that each attribute was set correctly, based on our
provided response: the id, title, description and thumbnail URL should all match.
With this, we completed our 1st goal when writing this test. However, didn't we
just say that having a huge it method and having too many expects are testing code
smells?
We did, so before we continue let's refactor this code to make isolated assertions
easier.
Add the following helper function inside our describe('search', ...):
Testing 626
code/http/src/app/you-tube-search/you-tube-search.component.spec.ts
81 function search(term: string, response: any, callback) {
82 return inject(
83 [YouTubeSearchService, HttpTestingController],
84 fakeAsync((service, httpMock) => {
85 let res;
86
87 // search
88 service.search(term).subscribe(_res => {
89 res = _res;
90 });
91
92 const req = httpMock.expectOne({ method: 'GET' });
93 req.flush(response);
94 tick();
95
96 callback(req.request, res);
97 })
98 );
99 }
Let's see what this function does: it uses inject and fakeAsync to perform the same
thing we were doing before, but in a configurable way. We take a search term, a
response and a callback function. We use those parameters to call the search method
with the search term, set the fake response and call the callback function after the
request is finished, providing the request and the response objects.
This way, all our test need to do is call the function and check one of the objects.
Let's break the test we had before into four tests, each testing one specific aspect of
the response:
Testing 627
code/http/src/app/you-tube-search/you-tube-search.component.spec.ts
101 it(
102 'parses YouTube video id',
103 search('hey', defaultResponse, (req, res) => {
104 const video = res[0];
105 expect(video.id).toEqual('VIDEO_ID');
106 })
107 );
108
109 it(
110 'parses YouTube video title',
111 search('hey', defaultResponse, (req, res) => {
112 const video = res[0];
113 expect(video.title).toEqual('TITLE');
114 })
115 );
116
117 it(
118 'parses YouTube video description',
119 search('hey', defaultResponse, (req, res) => {
120 const video = res[0];
121 expect(video.description).toEqual('DESCRIPTION');
122 })
123 );
124
125 it(
126 'parses YouTube video thumbnail',
127 search('hey', defaultResponse, (req, res) => {
128 const video = res[0];
129 expect(video.description).toEqual('DESCRIPTION');
130 })
131 );
Doesn't it look good? Small, focused tests that test only one thing. Great!
Now it should be really easy to add tests for the remaining goals we had:
Testing 628
code/http/src/app/you-tube-search/you-tube-search.component.spec.ts
133 it(
134 'sends the query',
135 search('term', defaultResponse, (req, res) => {
136 expect(req.url).toContain('q=term');
137 })
138 );
139
140 it(
141 'sends the API key',
142 search('term', defaultResponse, (req, res) => {
143 expect(req.url).toContain('key=YOUTUBE_API_KEY');
144 })
145 );
146
147 it(
148 'uses the provided YouTube URL',
149 search('term', defaultResponse, (req, res) => {
150 expect(req.url).toMatch(/^YOUTUBE_API_URL\?/);
151 })
152 );
Feel free to add more tests as you see fit. Np. you could add a test for when
you have more than one item on the response, with different attributes. See if you
can find other aspects of the code you'd like to test.
Conclusion
The Angular team has done a great job building testing right into Angular. It's easy
to test all of the aspects of our application: from controllers, to services, forms and
HTTP. Even testing asynchronous code that was a difficult to test is now a breeze.
Converting an AngularJS 1.x App
to Angular
If you've been using Angular for a while, then you probably already have production
AngularJS 1 apps. Angular is great, but there's no way we can drop everything
and rewrite our entire production apps in Angular. What we need is a way to
incrementally upgrade our AngularJS 1 app. Thankfully, Angular has a fantastic way
to do that.
The interoperability of AngularJS 1 (ng1) and Angular (ng2) works really well. In this
chapter, we're going to talk about how to upgrade your ng1 app to ng2 by writing
a hybrid app. A hybrid app is running ng1 and ng2 simultaneously (and we can
exchange data between them).
Peripheral Concepts
When we talk about interoperability between AngularJS 1 and Angular, there's a lot
of peripheral concepts. Np.:
Mapping AngularJS 1 Concepts to Angular: At a high level, ng2 Components are
ng1 directives. We also use Services in both. However, this chapter is about using
both ng1 and ng2, so we're going to assume you have basic knowledge of both. If
you haven't used ng2 much, checkout the chapter on How Angular Works before
reading this chapter.
Preparing ng1 apps for ng2: AngularJS 1.5 provides a new .component method to
make "component-directives". .component is a great way to start preparing your ng1
app for ng2. Furthermore, creating thin controllers (or banning them altogether¹⁴⁰) is
a great way to refactor your ng1 app such that it's easier to integrate with ng2.
Another way to prepare your ng1 app is to reduce or eliminate your use of two-way
data-binding in favor of a one-way data flow. In-part, you'd do this by reducing
¹⁴⁰http://teropa.info/blog/2014/10/24/how-ive-improved-my-angular-apps-by-banning-ng-controller.html
Converting an AngularJS 1.x App to Angular 630
$scope changes that pass data between directives and instead use services to pass
your data around.
These ideas are important and warrant further exploration. However, we're not going
to extensively cover best-practices for pre-upgrade refactoring in this chapter.
Instead, here's what we are going to talk about:
Writing hybrid ng1/ng2 apps: ng2 provides a way to bootstrap your ng1 app and
then write ng2 components and services. You can write ng2 components that will mix
with ng1 components and it "just works". Furthermore, the dependency injection
system supports passing between ng1 and ng2 (both directions), so you can write
services which will run in either ng1 or ng2.
The best part? Change detection runs within Zones, so you don't need to call
$scope.apply or worry much about change-detection at all.
What We're Building
In this chapter, we're going to be converting an app called "Interest" - it's a Pinterestlike
clone. The idea is that you can save a "Pin" which is a link with an image. The
Pins will be shown in a list and you can "fav" (or unfav) a pin.
Converting an AngularJS 1.x App to Angular 631
Our completed Pinterest-like app
You can find the completed code for both the ng1 version and the completed
hybrid version in the sample code download under code/upgrade/ng1 and
code/conversion/hybrid
The hybrid app is written using Angular CLI. In order to run it, change into
the directory and type:
1 npm install
2 npm start
Before we dive in, let's set the stage for interoperability between ng1 and ng2
Converting an AngularJS 1.x App to Angular 632
Mapping AngularJS 1 to Angular
From a high level, the five main parts of AngularJS 1 are:
• Directives
• Controllers
• Scopes
• Services
• Dependency Injection
Angular changes this list significantly. You might have heard that at ngEurope 2014
Igor and Tobias from the Angular core team announced that they were killing off
several "core" ideas in AngularJS 1 (video here¹⁴¹). Specifically, they announced that
Angular was killing off:
• $scope (& two-way binding by default)
• Directive Definition Objects
• Controllers
• angular.module
¹⁴¹https://www.youtube.com/watch?v=gNmWybAyBHI
Converting an AngularJS 1.x App to Angular 633
Igor and Tobias killing off many APIs from 1.x. at ngEurope 2014. Photo Credit: Michael Bromley
(used with permission)
As someone who's built AngularJS 1 apps and is used to thinking in ng1, we might
ask: if we take those things away, what is left? How can you build Angular apps
without Controllers and $scope?
Well, as much as people like to dramatize how different Angular is, it turns out, a
lot of the same ideas are still with us and, in fact, Angular provides just as much
functionality but with a much simpler model.
At a high-level Angular core is made up of:
• Components (think "directives") and
• Services
Of course there's tons of infrastructure required to make those things work. For
Converting an AngularJS 1.x App to Angular 634
instance, you need Dependency Injection to manage your Services. And you need
a strong change detection library to efficiently propagate data changes to your app.
And you need an efficient rendering layer to handle rendering the DOM at the right
time.
Requirements for Interoperability
So given these two different systems, what features do we need for easy interoperability?
• Use Angular Components in AngularJS 1: The 1st thing that comes to mind
is that we need to be able to write new ng2 components, but use them within
our ng1 app.
• Use AngularJS 1 Components in Angular: It's likely that we won't replace a
whole branch of our component-tree with all ng2 components. We want to be
able to re-use any ng1 components we have within a ng2 component.
• Service Sharing: If we have, say, a UserService we want to share that service
between both ng1 and ng2. Services are normally plain JS objects
so, more generally, what we need is an interoperable dependency injection
system.
• Change Detection: If we make changes in one side, we want those changes to
propagate to the other.
Angular provides solutions for all of these situations and we'll cover them in this
chapter.
In this chapter we're going to do the following:
• Describe the ng1 app we'll be converting
• Explain how to setup your hybrid app by using ng2's UpgradeAdapter
• Explain step-by-step how to share components (directives) and services between
ng1 and ng2 by converting the ng1 app to a hybrid app
Converting an AngularJS 1.x App to Angular 635
The AngularJS 1 App
To set the stage, let's go over the AngularJS 1 version of our app.
This chapter assumes some knowledge of AngularJS 1 and ui-router¹⁴². If
you're not comfortable with AngularJS 1 yet, check out ng-book 1¹⁴³.
We won't be diving too deeply into explaining each AngularJS 1 concept.
Instead, we're going to review the structure of the app to prepare for our
upgrade to a ng2/hybrid app.
To run the ng1 app, cd into conversion/ng1 in the code samples, install the
dependencies and run the app.
cd code/upgrade/ng1 # change directories
npm install # install dependencies
npm run go # run the app
If your browser doesn't open automatically, open the url: http://localhost:8080¹⁴⁴.
Note that the AngularJS 1 app in ng1 will run on port 8080 whereas the
hybrid app (discussed below) will run on port 4200.
In this app, you can see that our user is collecting puppets. We can hover over an
item and click the heart to "fav" a pin.
¹⁴²https://github.com/angular-ui/ui-router
¹⁴³http://ng-book.com
¹⁴⁴http://localhost:8080
Converting an AngularJS 1.x App to Angular 636
Red heart indicates a faved pin
We can also go to the /add page and add a new pin. Try submitting the default form.
Handling image uploads is more complex than we want to handle in this
demo. For now, just paste the full URL to an image if you want to try a
different image.
The ng1-app HTML
The index.html in our ng1 app uses a common structure:
Converting an AngularJS 1.x App to Angular 637
code/upgrade/ng1/index.html
1 <!DOCTYPE html>
2 <html ng-app='interestApp'>
3 <head>
4 <meta charset="utf-8">
5 <title>Interest</title>
6 <link rel="stylesheet" href="css/bootstrap.min.css">
7 <link rel="stylesheet" href="css/sf.css">
8 <link rel="stylesheet" href="css/interest.css">
9 </head>
10 <body class="container-fullwidth">
11
12 <div class="page-header">
13 <div class="container">
14 <h1>Interest <small>what you're interested in</small></h1>
15
16 <div class="navLinks">
17 <a ui-sref='home' id="navLinkHome">Home</a>
18 <a ui-sref='add' id="navLinkAdd">Add</a>
19 </div>
20 </div>
21 </div>
22
23 <div id="content">
24 <div ui-view=''></div>
25 </div>
26
27 <script src="js/vendor/lodash.js"></script>
28 <script src="js/vendor/angular.js"></script>
29 <script src="js/vendor/angular-ui-router.js"></script>
30 <script src="js/app.js"></script>
31 </body>
32 </html>
Looking at the code above:
• Notice that we're using ng-app in the html tag to specify that this app uses the
module interestApp.
• We load our JS with script tags at the bottom of the body.
• The template contains a page-header which stores our navigation
• We're using ui-router which means we:
– Use ui-sref for our links (Home and Add) and
– We use ui-view where we want the router to populate our content.
Converting an AngularJS 1.x App to Angular 638
Code Overview
We'll look at each section in code, but 1st, let's briefly describe the moving parts.
In our app, we have two routes:
• / uses the HomeController
• /add uses the AddController
We use a PinsService to hold an array of all of the current pins. HomeController
renders the list of pins and AddController adds a new element to that list.
Our root-level route uses our HomeController to render pins. We have a pin directive
that renders each pin.
The PinsService stores the data in our app, so let's look at the PinsService first.
ng1: PinsService
code/upgrade/ng1/js/app.js
1 angular.module('interestApp', ['ui.router'])
2 .service('PinsService', function($http, $q) {
3 this._pins = null;
4
5 this.pins = function() {
6 var self = this;
7 if(self._pins == null) {
8 // initialize with sample data
9 return $http.get("/js/data/sample-data.json").then(
10 function(response) {
11 self._pins = response.data;
12 return self._pins;
13 })
14 } else {
15 return $q.when(self._pins);
16 }
17 }
18
19 this.addPin = function(newPin) {
20 // adding would normally be an API request so lets mock async
Converting an AngularJS 1.x App to Angular 639
21 return $q.when(
22 this._pins.unshift(newPin)
23 );
24 }
25 })
The PinsService is a .service that stores an array of pins in the property _.pins.
The method .pins returns a promise that resolves to the list of pins. If _.pins is null
(i.e. the 1st time), then we will load sample data from /js/data/sample-data.json.
code/upgrade/ng1/js/data/sample-data.json
1 [
2 {
3 "title": "sock puppets",
4 "description": "from:\nThe FunCraft Book of Puppets\n1976\nISBN: 0-590-11936-2",
5 "user_name": "tofutti break",
6 "avatar_src": "images/avatars/42826303@N00.jpg",
7 "src": "images/pins/106033588_167d811702_o.jpg",
8 "url": "https://www.flickr.com/photos/tofuttibreak/106033588/",
9 "faved": false,
10 "id": "106033588"
11 },
12 {
13 "title": "Puppet play.",
14 "description": "My wife's handmade.",
15 "user_name": "MIKI Yoshihito (´￿ω￿)",
16 "avatar_src": "images/avatars/7940758@N07.jpg",
17 "src": "images/pins/4422575066_7d5c4c41e7_o.jpg",
18 "url": "https://www.flickr.com/photos/mujitra/4422575066/",
19 "faved": false,
20 "id": "4422575066"
21 },
22 {
23 "title": "easy to make puppets - oliver owl (detail)",
24 "description": "from easy to make puppets by joyce luckin (1975)",
25 "user_name": "gilliflower",
26 "avatar_src": "images/avatars/26265986@N00.jpg",
27 "src": "images/pins/6819859061_25d05ef2e1_o.jpg",
28 "url": "https://www.flickr.com/photos/gilliflower/6819859061/",
29 "faved": false,
30 "id": "6819859061"
31 },
Converting an AngularJS 1.x App to Angular 640
Snippet from Sample Data
The method .addPin simply adds the new pin to the array of pins. We use $q.when
here to return a promise, which is likely what would happen if we were doing a real
async call to a server.
ng1: Configuring Routes
We're going to configure our routes with ui-router.
If you're unfamiliar with ui-router you can read the docs here¹⁴⁵.
As we mentioned, we're going to have two routes:
code/upgrade/ng1/js/app.js
26 .config(function($stateProvider, $urlRouterProvider) {
27 $stateProvider
28 .state('home', {
29 templateUrl: '/templates/home.html',
30 controller: 'HomeController as ctrl',
31 url: '/',
32 resolve: {
33 'pins': function(PinsService) {
34 return PinsService.pins();
35 }
36 }
37 })
38 .state('add', {
39 templateUrl: '/templates/add.html',
40 controller: 'AddController as ctrl',
41 url: '/add',
42 resolve: {
43 'pins': function(PinsService) {
44 return PinsService.pins();
45 }
46 }
47 })
¹⁴⁵https://github.com/angular-ui/ui-router/wiki
Converting an AngularJS 1.x App to Angular 641
48
49 $urlRouterProvider.when('', '/') ;
50 })
The 1st route / maps to the HomeController. It has a template, which we'll look at in
a minute. Notice that we also are using the resolve functionality of ui-router. This
says that before we load this route for the user, we want to call PinsService.pins()
and inject the result (the list of pins) into the controller (HomeController).
The /add route as similarly, except that it has a different template and a different
controller.
Let's 1st look at our HomeController.
ng1: HomeController
Our HomeController is straightforward. We save pins, which is injected because of
our resolve, to $scope.pins.
code/upgrade/ng1/js/app.js
60 .controller('HomeController', function(pins) {
61 this.pins = pins;
62 })
ng1: / HomeController template
Our home template is small: we use an ng-repeat to repeat over the pins in
$scope.pins. Then we render each pin with the pin directive.
Converting an AngularJS 1.x App to Angular 642
code/upgrade/ng1/templates/home.html
1 <div class="container">
2 <div class="row">
3 <pin item="pin" ng-repeat="pin in ctrl.pins">
4 </pin>
5 </div>
6 </div>
Let's dive deeper and look at this pin directive.
ng1: pin Directive
The pin directive is restricted to matching an element (E) and has a template.
We can input our pin via the item attribute, as we did in the home.html template.
Our link function, defines a function on the scope called toggleFav which toggles
the pin's faved property.
code/upgrade/ng1/js/app.js
92 })
93 .directive('pin', function() {
94 return {
95 restrict: 'E',
96 templateUrl: '/templates/pin.html',
97 scope: {
98 'pin': "=item"
99 },
100 link: function(scope, elem, attrs) {
101 scope.toggleFav = function() {
102 scope.pin.faved = !scope.pin.faved;
103 }
104 }
105 }
106 })
Converting an AngularJS 1.x App to Angular 643
This directive shouldn't be taken as an example of directive using the
current best-practices. Np. if I was writing this component anew
(in ng1) I would probably use the new .component directive available in
AngularJS 1.5+. At the very least, I'd probably use controllerAs instead of
link here.
But this section is less about how to write ng1 code, as much as how to
work with the ng1 code you already have.
ng1: pin Directive template
The template templates/pin.html renders an individual pin on our page.
code/upgrade/ng1/templates/pin.html
1 <div class="col-sm-6 col-md-4">
2 <div class="thumbnail">
3 <div class="content">
4 <img ng-src="{{pin.src}}" class="img-responsive">
5 <div class="caption">
6 <h3>{{pin.title}}</h3>
7 <p>{{pin.description | truncate:100}}</p>
8 </div>
9 <div class="attribution">
10 <img ng-src="{{pin.avatar_src}}" class="img-circle">
11 <h4>{{pin.user_name}}</h4>
12 </div>
13 </div>
14 <div class="overlay">
15 <div class="controls">
16 <div class="heart">
17 <a ng-click="toggleFav()">
18 <img src="/images/icons/Heart-Empty.png" ng-if="!pin.faved"></img>
19 <img src="/images/icons/Heart-Red.png" ng-if="pin.faved"></img>
20 </a>
21 </div>
22 </div>
23 </div>
24 </div>
25 </div>
The directives we use here are ng1 built-ins:
Converting an AngularJS 1.x App to Angular 644
• We use ng-src to render the img.
• Next we show the pin.title and pin.description.
• We use ng-if to show either the red or empty heart
The most interesting thing here is the ng-click that will call toggleFav. toggleFav
changes the pin.faved property and thus the red or empty heart will be shown
accordingly.
Red vs. Black Heart
Now let's turn our attention to the AddController.
ng1: AddController
Our AddController has a bit more code than the HomeController. We open by
defining the controller and specifying the services it will inject:
code/upgrade/ng1/js/app.js
63 .controller('AddController', function($state, PinsService, $timeout) {
64 var ctrl = this;
65 ctrl.saving = false;
We're using controllerAs syntax in our router and template, which means we set
properties on this instead of on $scope. Scoping this in ES5 JS can be tricky,
so we assign var ctrl = this; which helps disambiguate when we're referencing
the controller in nested functions.
Converting an AngularJS 1.x App to Angular 645
code/upgrade/ng1/js/app.js
67 var makeNewPin = function() {
68 return {
69 "title": "Steampunk Cat",
70 "description": "A cat wearing goggles",
71 "user_name": "me",
72 "avatar_src": "images/avatars/me.jpg",
73 "src": "/images/pins/cat.jpg",
74 "url": "http://cats.com",
75 "faved": false,
76 "id": Math.floor(Math.random() * 10000).toString()
77 }
78 }
79
80 ctrl.newPin = makeNewPin();
We create a function makeNewPin that contains the default structure and data for a
pin.
We also initialize this controller by setting ctrl.newPin to the value of calling this
function.
The last thing we need to do is define the function to submit a new pin:
code/upgrade/ng1/js/app.js
82 ctrl.submitPin = function() {
83 ctrl.saving = true;
84 $timeout(function() {
85 PinsService.addPin(ctrl.newPin).then(function() {
86 ctrl.newPin = makeNewPin();
87 ctrl.saving = false;
88 $state.go('home');
89 });
90 }, 2000);
91 }
92 })
Essentially, this article is calling out to PinService.addPin and creating a new pin.
But there's a few other things going on here.
In a real application, this would almost certainly call back to a server. We're
mimicking that effect by using $timeout. (That is, you could remove the $timeout
Converting an AngularJS 1.x App to Angular 646
function and this would still work. It's just here to deliberately slow down the app
to give us a chance to see the "Saving" indicator.)
We want to give some indication to the user that their pin is saving, so we set the
ctrl.saving = true.
We call PinsService.addPin giving it our ctrl.newPin. addPin returns a promise, so
in our promise function we
1. revert ctrl.newPin to the original value
2. we set ctrl.saving to false, because we're done saving the pin
3. we use the $state service to redirect the user to the homepage where we can
see our new pin
Here's the whole code of the AddController:
code/upgrade/ng1/js/app.js
63 .controller('AddController', function($state, PinsService, $timeout) {
64 var ctrl = this;
65 ctrl.saving = false;
66
67 var makeNewPin = function() {
68 return {
69 "title": "Steampunk Cat",
70 "description": "A cat wearing goggles",
71 "user_name": "me",
72 "avatar_src": "images/avatars/me.jpg",
73 "src": "/images/pins/cat.jpg",
74 "url": "http://cats.com",
75 "faved": false,
76 "id": Math.floor(Math.random() * 10000).toString()
77 }
78 }
79
80 ctrl.newPin = makeNewPin();
81
82 ctrl.submitPin = function() {
83 ctrl.saving = true;
84 $timeout(function() {
85 PinsService.addPin(ctrl.newPin).then(function() {
86 ctrl.newPin = makeNewPin();
87 ctrl.saving = false;
Converting an AngularJS 1.x App to Angular 647
88 $state.go('home');
89 });
90 }, 2000);
91 }
92 })
ng1: AddController template
Our /add route renders the add.html template.
Adding a New Pin Form
The template uses ng-model to bind the input tags to the properties of the newPin on
the controller.
The interesting things here are that:
Converting an AngularJS 1.x App to Angular 648
• We use ng-click on the submit button to call ctrl.submitPin and
• We show a "Saving…" message if ctrl.saving is truthy
code/upgrade/ng1/templates/add.html
1 <div class="container">
2 <div class="row">
3
4 <form class="form-horizontal">
5
6 <div class="form-group">
7 <label for="title"
8 class="col-sm-2 control-label">Title</label>
9 <div class="col-sm-10">
10 <input type="text"
11 class="form-control"
12 id="title"
13 placeholder="Title"
14 ng-model="ctrl.newPin.title">
15 </div>
16 </div>
17
18 <div class="form-group">
19 <label for="description"
20 class="col-sm-2 control-label">Description</label>
21 <div class="col-sm-10">
22 <input type="text"
23 class="form-control"
24 id="description"
25 placeholder="Description"
26 ng-model="ctrl.newPin.description">
27 </div>
28 </div>
29
30 <div class="form-group">
31 <label for="url"
32 class="col-sm-2 control-label">Link URL</label>
33 <div class="col-sm-10">
34 <input type="text"
35 class="form-control"
36 id="url"
37 placeholder="Link URL"
38 ng-model="ctrl.newPin.url">
39 </div>
Converting an AngularJS 1.x App to Angular 649
40 </div>
41
42 <div class="form-group">
43 <label for="url"
44 class="col-sm-2 control-label">Image URL</label>
45 <div class="col-sm-10">
46 <input type="text"
47 class="form-control"
48 id="url"
49 placeholder="Image URL"
50 ng-model="ctrl.newPin.src">
51 </div>
52 </div>
53
54 <div class="form-group">
55 <div class="col-sm-offset-2 col-sm-10">
56 <button type="submit"
57 class="btn btn-default"
58 ng-click="ctrl.submitPin()">Submit</button>
59 </div>
60 </div>
61 <div ng-if="ctrl.saving">
62 Saving...
63 </div>
64 </form>
65
66 </div>
67 </div>
ng1: Summary
There we have it. This app has just the right amount of complexity that we can start
porting it to Angular.
Building A Hybrid
Now we're ready to start putting some Angular in our AngularJS 1 app.
Before we start using Angular in our browser, we're going to need to make some
modifications to our project structure.
Converting an AngularJS 1.x App to Angular 650
You can find the code for this example in code/conversion/hybrid.
To run it, run:
1 npm install
2 npm start
Then open your browser to http://localhost:4200 – note that this is a
different URL than the pure-AngularJS 1 app above.
Hybrid Project Structure
The 1st step to creating a hybrid app is to make sure you have both ng1 and ng2
loaded as dependencies. Everyone's situation is going to be slightly different.
In this example we've vendored the AngularJS 1 libraries (in js/vendor) and we're
loading the Angular libraries from npm.
In your project, you might want to vendor them both, use bower¹⁴⁶, etc. However,
using npm is very convenient for Angular and so we suggest using npm to install
Angular.
One of the 1st challenges we face when making a hybrid app is ensuring our buildprocess
can support both JS and TS files, as well as resolving our
assets, type-definitions and so on.
Here we're using Angular CLI (which is based on Webpack) in order to build this app.
We'll describe the specific steps necessary to get our app running within Angular CLI,
but if you have an existing build process, it might take some additional work to get
it in order.
Dependencies with package.json
You install dependencies with npm using the package.json file. Here's our package.
json for the hybrid example:
¹⁴⁶http://bower.io/
Converting an AngularJS 1.x App to Angular 651
code/upgrade/hybrid/package.json
1 {
2 "name": "hybrid",
3 "version": "0.0.0",
4 "license": "MIT",
5 "scripts": {
6 "ng": "ng",
7 "start": "ng serve --aot=false",
8 "build": "ng build",
9 "test": "ng test",
10 "lint": "ng lint",
11 "e2e": "ng e2e"
12 },
13 "private": true,
14 "dependencies": {
15 "@angular/animations": "9.0.0",
16 "@angular/common": "9.0.0",
17 "@angular/compiler": "9.0.0",
18 "@angular/core": "9.0.0",
19 "@angular/forms": "9.0.0",
20 "@angular/platform-browser": "9.0.0",
21 "@angular/platform-browser-dynamic": "9.0.0",
22 "@angular/router": "9.0.0",
23 "@angular/upgrade": "9.0.0-rc.14",
24 "core-js": "2.6.11",
25 "reflect-metadata": "0.1.13",
26 "rxjs": "6.5.4",
27 "tslib": "1.10.0",
28 "zone.js": "0.10.2"
29 },
30 "devDependencies": {
31 "@angular-devkit/build-angular": "0.900.1",
32 "@angular-devkit/build-optimizer": "0.900.0-rc.10",
33 "@angular/cli": "9.0.1",
34 "@angular/compiler-cli": "9.0.0",
35 "@angular/language-service": "9.0.0",
36 "@types/angular-ui-router": "1.1.40",
37 "@types/jasmine": "3.5.3",
38 "@types/jasminewd2": "2.0.8",
39 "@types/node": "12.12.26",
40 "codelyzer": "5.2.1",
41 "jasmine-core": "3.5.0",
42 "jasmine-spec-reporter": "4.2.1",
43 "karma": "4.3.0",
Converting an AngularJS 1.x App to Angular 652
44 "karma-chrome-launcher": "3.1.0",
45 "karma-cli": "~1.0.1",
46 "karma-coverage-istanbul-reporter": "2.1.1",
47 "karma-jasmine": "2.0.1",
48 "karma-jasmine-html-reporter": "1.5.2",
49 "protractor": "5.4.3",
50 "ts-node": "8.3.0",
51 "tslint": "5.18.0",
52 "TS": "3.7.5"
53 }
54 }
If you're unfamiliar with what one of these packages does, it's a good idea
to find out. rxjs, Np. is the library that provides our observables.
Notice that we've included the @angular/upgrade package. This module contains the
tools necessary for booting a hybrid app.
Compiling our code
We're going to be using TS in this example alongside our JS AngularJS
1 code. To do this, we're going to put all of our "old" JS code in the
folder js/.
We also want to load AngularJS, as well as angular-ui-router and our AngularJS 1
app. Here, to do this we're going to include them in the scripts tag of our .angularcli.
json
Converting an AngularJS 1.x App to Angular 653
1 {
2 "apps": [
3 {
4 // ...
5 "scripts": [
6 "js/vendor/angular.js",
7 "js/vendor/angular-ui-router.js",
8 "js/app.js"
9 ],
10 }
11 ]
12 }
This step may vary depending on your build process. Np. if you
have an existing AngularJS app you may have an existing build process
that builds that app into one or a few files (e.g. using Gulp or another build
system). In that case, if you want to bring that build into your Angular
CLI project, you could have a separate step that would build those files and
import them into "scripts" here.
In the case that you want a more unified workflow, you'll need to run ng
eject and modify the generated Webpack file from there.
That said, building custom Webpack configurations is beyond the scope of
this book.
When we write hybrid ng2 apps the Angular code becomes the entry point. This
makes sense because it's Angular that's providing the backwards compatibility
with AngularJS 1. Let's take a closer look at the bootstrapping process.
Bootstrapping our Hybrid App
Now that we have our project structure in place, let's bootstrap the app.
If you recall, with AngularJS 1 you can bootstrap the app in 1 of two ways:
1. You can use the ng-app directive, such as ng-app='interestApp', in your HTML
or
2. You can use angular.bootstrap in JS
Converting an AngularJS 1.x App to Angular 654
In hybrid apps we use a new bootstrap method that comes from an UpgradeAdapter.
Since we'll be bootstrapping the app in code, make sure you remove the ng-app
from your index.html.
Here's what a minimal bootstrapping of our code would look like:
// code/upgrade/hybrid/src/app/app.module.ts
import {
NgModule,
forwardRef
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { BrowserModule } from '@angular/platform-browser';
import { UpgradeAdapter } from '@angular/upgrade';
declare var angular: any;
/*
* Create our upgradeAdapter
*/
const upgradeAdapter: UpgradeAdapter = new UpgradeAdapter(
forwardRef(() => MyAppModule)); // <-- notice forward reference
// ...
// upgrade and downgrade components in here
// ...
/*
* Create our app's entry NgModule
*/
@NgModule({
declarations: [ MyNg2Component, ... ],
imports: [
CommonModule,
BrowserModule
],
providers: [ MyNg2Services, ... ]
})
class MyAppModule { }
/*
* Bootstrap the App
*/
upgradeAdapter.bootstrap(document.body, ['interestApp']);
Converting an AngularJS 1.x App to Angular 655
We start by importing the UpgradeAdapter and then we create an instance of it:
upgradeAdapter.
However, the constructor of UpgradeAdapter requires an NgModule that we'll be using
for our Angular up - but we haven't defined it yet! To get around this we use the
forwardRef function which allows us to take a 'forward reference' to our NgModule
which we declare below.
When we define our NgModule MyAppModule (or specifically in this app it will be
InterestAppModule), we define it like we would any other Angular NgModule: we
put in our declarations, imports, providers, etc.
Lastly, we tell the upgradeAdapter to bootstrap our app on the element document.
body and we specify the module name of our AngularJS 1 app.
This will bootstrap our AngularJS 1 app within our Angular app! Now we can start
replacing pieces with Angular.
What We'll Upgrade
Let's discuss what we're going to port to ng2 in this example and what will stay in
ng1.
Converting an AngularJS 1.x App to Angular 656
The Homepage
Homepage ng1 and ng2 Components
The 1st thing to notice is that we're going to continue to manage routing with
ng1. Of course, Angular has its own routing, which you can read about in our
routing chapter. But if you're building a hybrid app, you probably have lots of routes
configured with AngularJS 1 and so in this example we'll continue to use ui-router
for the routing.
On the homepage, we're going to nest a ng2 component within an ng1 directive. In
this case, we're going to convert the "pin controls" to a ng2 component. That is, our
ng1 pin directive, will call out to the ng2 pin-controls component and pin-controls
will render the fav heart.
It's a small example that shows a powerful idea: how to seamlessly exchange data
between ng versions.
Converting an AngularJS 1.x App to Angular 657
The About Page
About Page ng1 and ng2 Components
We're going to use ng1 for the router and header on the about page as well. However
on the about page, we're going to replace the whole form with a ng2 component:
AddPinComponent.
If you recall, the form will add a new pin to the PinsService and so in this example
we're going to need to somehow make the (ng1) PinsService accessible to the (ng2)
AddPinComponent.
Also, remember that when a new pin is added, the app should be redirected to the
homepage. However, to change routes we need to use the ui-router $state service
(ng1) in the AddPinComponent (ng2). So we also need to make sure the $state service
can be used in AddPinComponent as well.
Converting an AngularJS 1.x App to Angular 658
Services
So far we've talked about two ng1 services that will be upgraded to ng2:
• PinsService and
• $state
We also want to explore "downgrading" a ng2 service to be used by ng1. For this,
later on in the chapter, we'll create an AnalyticsService in TS/ng2 that we
share with ng1.
Taking Inventory
So to recap we're going to "cross-expose" the following:
• Downgrade the ng2 PinControlsComponent to ng1 (for the fav buttons)
• Downgrade the ng2 AddPinComponent to ng1 (for the add pin page)
• Downgrade the ng2 AnalyticsService to ng1 (for recording events)
• Upgrade the ng1 PinsService to ng2 (for adding new pins)
• Upgrade the ng1 $state service to ng2 (for controlling routes)
A Minor Detour: Typing Files
One of the great things about TS is the compile-time typing. However, if
you're building a hybrid app, I suspect that you've got a lot of untyped JS
code that you're going to be integrating into this project.
When you try to use your JS code from TS you may get compiler
errors because the compiler doesn't know the structure of your JS objects.
You could try casting everything to <any> but that is ugly and error prone.
The better solution is to, instead, provide your TS compiler with custom type
decorators. Then the compiler will be able to enforce the types of your JS
code.
Np. remember how in our ng1 app we created a pin object in makeNewPin?
Converting an AngularJS 1.x App to Angular 659
code/upgrade/ng1/js/app.js
67 var makeNewPin = function() {
68 return {
69 "title": "Steampunk Cat",
70 "description": "A cat wearing goggles",
71 "user_name": "me",
72 "avatar_src": "images/avatars/me.jpg",
73 "src": "/images/pins/cat.jpg",
74 "url": "http://cats.com",
75 "faved": false,
76 "id": Math.floor(Math.random() * 10000).toString()
77 }
78 }
79
80 ctrl.newPin = makeNewPin();
It would be nice if we could tell the compiler about the structure of these objects and
not resort to using any everywhere.
Furthermore, we're going to be using the ui-router $state service in Angular /
TS and we need to tell the compiler what functions are available there, too.
So while providing TS custom type definitions is a TS (and not an
Angular-specific) chore, it's a chore we need to do nonetheless. And it's sth
that many people haven't done yet because TS is, at time of publishing,
relatively new.
So in this section I want to walk through how you deal with custom typings in
TS.
If you're already familiar with how to create and use TS type
definition files, you can safely skim this section.
Typing Files
In TS we can describe the structure of our code by writing typing definition
files. Typing definition files generally end in the extension .d.ts.
Converting an AngularJS 1.x App to Angular 660
Generally, when you write TS code, you don't need to write a .d.ts because
your TS code itself contains types. We write .d.ts files when we have some
external JS code that we want to add typing to after the fact.
Np. in describing our pin object, we could write an interface for it like so:
code/upgrade/hybrid/src/js/app.d.ts
1 interface Pin {
2 title: string;
3 description: string;
4 user_name: string;
5 avatar_src: string;
6 src: string;
7 url: string;
8 faved: boolean;
9 id: string;
10 }
Notice that we're not declaring a class and we're not creating an instance. Instead,
we're defining the shape (types) of an interface.
In order to use.d.ts files, you need to tell the TS compiler where they are.
The easiest way to do this is by adding a reference to typings.d.ts. For instance in
typings.d.ts we'll add this:
1 /// <reference path="./js/app.d.ts"/>
We'll write app.d.ts in a little bit. 1st, let's explore a tool that exists to help us with
third-party TS definition files: typings.
Third-party libraries with @types
TS allows for loading third-party types via NPM.
We're going to use angular-ui-router with our app, so let's install the typings for
angular-ui-router. To get this setup, all we have to do is install the @types/angularui-
router package.
Converting an AngularJS 1.x App to Angular 661
1 npm install @types/angular-ui-router --save
Now, by default, TS will read types from the node_modules/@types/ directory.
We'll look at how we uses these types in our code in a moment.
Custom Typing Files
Being able to use third-party typing files is great, but there are going to be situations
where typing files don't already exist: especially in the case of our own code.
Generally, when we write custom typing files we co-locate the file alongside its
respective JS code. So let's create the file js/app.d.ts:
code/upgrade/hybrid/src/js/app.d.ts
1 interface Pin {
2 title: string;
3 description: string;
4 user_name: string;
5 avatar_src: string;
6 src: string;
7 url: string;
8 faved: boolean;
9 id: string;
10 }
11
12 interface PinsService {
13 pins(): Promise<Pin[]>;
14 addPin(pin: Pin): Promise<any>;
15 }
Here we're making an "ambient declaration" and the idea is that we're defining a
variable that didn't originate from a TS file. In this case, we're defining two
interfaces:
1. Pin
2. PinsService
The Pin interface describes the keys and value-types of a pin object.
The PinsService interface describes the types of our two methods on our PinsService.
Converting an AngularJS 1.x App to Angular 662
• pins() returns a Promise of an array of Pins
• addPin() takes a Pin as an argument and returns a Promise
Learn More about Writing Type Definition Files
If you'd like to learn more about writing .d.ts files, checkout these helpful
links:
• TS Handbook: Working with other JS Libraries¹⁴⁷
• TS Handbook: Writing definition files¹⁴⁸
• Quick tip: TS declare keyword¹⁴⁹
Now that we have this file setup, TS will know about the Pin and PinsService
types in our code.
Writing ng2 PinControlsComponent
Now that we have the typings figured out, let's turn our attention back to the hybrid
app.
The 1st thing we're going to do is write the ng2 PinControlsComponent. This will
be an ng2 component nested within an ng1 directive. The PinControlsComponent
displays the fav hearts and toggles fav'ing a pin.
Next, let's write our component:
¹⁴⁷http://www.TSlang.org/Handbook#modules-working-with-other-JS-libraries
¹⁴⁸https://github.com/Microsoft/TS-Handbook/blob/master/pages/Writing%20Definition%20Files.md
¹⁴⁹http://blogs.microsoft.co.il/gilf/2013/07/22/quick-tip-TS-declare-keyword/
Converting an AngularJS 1.x App to Angular 663
code/upgrade/hybrid/src/app/pin-controls/pin-controls.component.ts
1 import {
2 Component,
3 Input,
4 Output,
5 EventEmitter
6 } from '@angular/core';
7
8 @Component({
9 selector: 'pin-controls',
10 templateUrl: './pin-controls.component.html',
11 styleUrls: ['./pin-controls.component.css']
12 })
13 export class PinControlsComponent {
14 @Input() pin: Pin;
15 @Output() faved: EventEmitter<Pin> = new EventEmitter<Pin>();
16
17 toggleFav(): void {
18 this.faved.emit(this.pin);
19 }
20 }
Notice here that we'll match the element pin-controls.
Our template looks very similar to the ng1 version except we're using the ng2
template syntax for (click) and *ngIf.
Now the component definition class:
code/upgrade/hybrid/src/app/pin-controls/pin-controls.component.html
1 <div class="controls">
2 <div class="heart">
3 <a (click)="toggleFav()">
4 <img src="/assets/images/icons/Heart-Empty.png" *ngIf="!pin.faved" />
5 <img src="/assets/images/icons/Heart-Red.png" *ngIf="pin.faved" />
6 </a>
7 </div>
8 </div>
Notice that instead of specifying inputs and outputs in the @Component decorator,
in this case we're annotating the properties on the class directly with the @Input
Converting an AngularJS 1.x App to Angular 664
and @Output decorators. This is a convenient way to us to provide typings to these
properties.
This component will take an input of pin, which is the Pin object we're controlling.
This component specifies an output of faved. This is a little bit different than how
we did it in the ng1 app. If you look at toggleFav all we're doing is emitting (on the
EventEmitter) the current pin.
The idea here is that we've already implemented how to change the faved state in
ng1 and we may not want to re-implement that functionality ng2 (you may want to,
it just depends on your team conventions).
Using ng2 PinControlsComponent
Now that we have an ng2 pin-controls component, we can now use it in a
AngularJS 1 template. Here's what our pin.html template looks like now:
code/upgrade/hybrid/src/assets/templates/pin.html
1 <div class="col-sm-6 col-md-4">
2 <div class="thumbnail">
3 <div class="content">
4 <img ng-src="{{pin.src}}" class="img-responsive">
5 <div class="caption">
6 <h3>{{pin.title}}</h3>
7 <p>{{pin.description | truncate:100}}</p>
8 </div>
9 <div class="attribution">
10 <img ng-src="{{pin.avatar_src}}" class="img-circle">
11 <h4>{{pin.user_name}}</h4>
12 </div>
13 </div>
14 <div class="overlay">
15 <pin-controls [pin]="pin"
16 (faved)="toggleFav($event)"></pin-controls>
17 </div>
18 </div>
19 </div>
This template is for an ng1 directive and we can use ng1 directives such as ng-src.
However, notice the line where we use our ng2 pin-controls component:
Converting an AngularJS 1.x App to Angular 665
<pin-controls [pin]="pin"
(faved)="toggleFav($event)"></pin-controls>
What's interesting here is that we're using the ng2 input bracket syntax [pin] and
the ng2 output parentheses syntax (faved).
In a hybrid app when you use ng2 directives in ng1, you still use the ng2 syntax.
With our input [pin] we're passing the pin which comes from the scope of the ng1
directive.
With our output (faved) we're calling the toggleFav function on the scope of
the ng1 directive. Notice what we did here: we didn't modify the pin.faved state
within the ng2 directive (although, we could have). Instead, we asked the ng2
PinControlsComponent to simply emit the pin when toggleFav is called there. (If
this is confusing, take a second look at toggleFav of PinControlsComponent.)
Again, the reason we do this is because we're showing how you can keep your
existing functionality (scope.toggleFav) in ng1, but start porting over components
to ng2. In this case, the ng1 pin directive listens for the faved event on the ng2
PinControlsComponent.
If you refresh your page now, you'll notice that it doesn't work. That's because there's
one more thing we need to do: downgrade PinControlsComponent to ng1.
Downgrading ng2 PinControlsComponent to ng1
The final step to using our components across ng2/ng1 borders is to use our
UpgradeAdapter to downgrade our components (or upgrade, as we'll see in a bit).
We perform this downgrade in our app.module.ts file
First we need to import the necessary libraries and declare the angular variable:
Converting an AngularJS 1.x App to Angular 666
code/upgrade/hybrid/src/app/app.module.ts
1 import {
2 NgModule,
3 forwardRef
4 } from '@angular/core';
5 import { UpgradeAdapter } from '@angular/upgrade';
6 import { BrowserModule } from '@angular/platform-browser';
7
8 import { FormsModule } from '@angular/forms';
9 import { HttpClientModule } from "@angular/common/http";
10
11 import { AppComponent } from './app.component';
12 import { AddPinComponent } from './add-pin/add-pin.component';
13 import { PinControlsComponent } from './pin-controls/pin-controls.component';
14 import { AnalyticsService } from './analytics.service';
15
16 declare var angular: any;
Then we create a .directive in (almost) the normal ng1 way:
code/upgrade/hybrid/src/app/app.module.ts
16 declare var angular: any;
17
18 /*
19 * Create our upgradeAdapter
20 */
21 export const upgradeAdapter: UpgradeAdapter = new UpgradeAdapter(
22 forwardRef(() => AppModule));
23
24 /*
25 * Expose our ng2 content to ng1
26 */
27 angular.module('interestApp')
28 .directive('pinControls',
29 upgradeAdapter.downgradeNg2Component(PinControlsComponent))
Remember that our ng1 app calls angular.module('interestApp', []). That is, our
ng1 app has already registered the interestApp module with angular.
Now we want to look up that module by calling angular.module('interestApp')
and then add directives to it, just like we do in ng1 normally.
Converting an AngularJS 1.x App to Angular 667
angular.module getter and setter syntax
If you recall, when we pass an array as the second argument
to angular.module, we are creating a module. That is,
angular.module('foo', []) will create the module foo. Informally,
we call this the "setter" syntax.
Similarly, if we omit the array we are getting a module (that is assumed
to already exist). That is, angular.module('foo') will get the module foo.
We call this the "getter" syntax.
In this example, if you forget this distinction and call
angular.module('interestApp', []) in app.ts (ng2) then you will
accidentally overwrite your existing interestApp module and your app
won't work. Careful!
We're calling .directive and creating a directive called 'pinControls'. This is standard
ng1 practice. For the second argument, the directive definition object (DDO), we
don't create the DDO manually. Instead, we call upgradeAdapter.downgradeNg2Component.
downgradeNg2Component will convert our PinControlsComponent into an ng1-compatible
directive. Pretty neat.
Now if you try refreshing, you'll notice that our faving works just like before, only
now we're using ng2 embedded in ng1!
Faving works like a charm
Converting an AngularJS 1.x App to Angular 668
Adding Pins with ng2
The next thing we want to do is upgrade the add pins page with an ng2 component.
Adding a New Pin Form
If you recall, this page does three things:
1. Present a form to the user for describing the pin
2. Use the PinsService to add the new pin to the list of pins
3. Redirect the user to the homepage
Let's think through how we're going to do these things from ng2.
Angular provides a robust forms library. So there's no complication here. We're going
to write a straight ng2 form.
Converting an AngularJS 1.x App to Angular 669
However the PinsService comes from ng1. Often we have many existing services in
ng1 and we don't have time to upgrade them all. So for this example, we're going to
keep PinsService as an ng1 object and inject it into ng2.
Similarly, we're using ui-router in ng1 for our routing. To change pages in ui-router
we have to use the $state service, which is an ng1 service.
So what we're going to do is upgrade the PinsService and the $state service from
ng1 to ng2. And this couldn't be any easier.
Upgrading ng1 PinsService and $state to ng2
To upgrade ng1 services we call upgradeAdapter.upgradeNg1Provider:
code/upgrade/hybrid/src/app/app.module.ts
37 /*
38 * Expose our ng1 content to ng2
39 */
40 upgradeAdapter.upgradeNg1Provider('PinsService');
41 upgradeAdapter.upgradeNg1Provider('$state');
And that's it. Now we can @Inject our ng1 services into ng2 components like so:
// angular.ui.IStateService is available because we've
// installed @types/angular-ui-router in our package.json
type IStateService = angular.ui.IStateService;
class AddPinComponent {
constructor(@Inject('PinsService') public pinsService: PinsService,
@Inject('$state') public uiState: IStateService) {
}
// ...
// now you can use this.pinsService
// or this.uiState
// ...
}
In this constructor, there's a few things to look at:
The @Inject decorator, says that we want the next variable to be assigned the value of
what the injection will resolve to. In the 1st case, that would be our ng1 PinsService.
Converting an AngularJS 1.x App to Angular 670
In TS, in a constructor when you use the public keyword, it is a shorthand
for assigning that variable to this. That is, here when we say public pinsService
what we're saying is, 1. declare a property pinsService on instances of this class and
2. assign the constructor argument pinsService to this.pinsService.
The result is that we can access this.pinsService throughout our class.
Lastly we define the type of both services we're injecting: PinsService and IState-
Service.
PinsService comes from the app.d.ts we defined previously:
code/upgrade/hybrid/src/js/app.d.ts
12 interface PinsService {
13 pins(): Promise<Pin[]>;
14 addPin(pin: Pin): Promise<any>;
15 }
And IStateService comes from the typings for ui-router, which we installed with
typings.
By telling TS the types of these services we can enjoy type-checking as we
write our code.
Let's write the rest of our AddPinComponent.
Writing ng2 AddPinComponent
We start by importing the types we need:
Converting an AngularJS 1.x App to Angular 671
code/upgrade/hybrid/src/app/add-pin/add-pin.component.ts
1 declare var angular: any;
2 import {
3 Component,
4 Inject
5 } from '@angular/core';
6 // angular.ui.IStateService is available because we've
7 // installed @types/angular-ui-router in our package.json
8 type IStateService = angular.ui.IStateService;
Again, notice that we're importing our custom types Pin and PinsService. And we're
also importing IStateService from angular-ui-router.
AddPinComponent @Component
Our @Component is straightforward:
code/upgrade/hybrid/src/app/add-pin/add-pin.component.ts
10 @Component({
11 selector: 'add-pin',
12 templateUrl: './add-pin.component.html',
13 styleUrls: ['./add-pin.component.css']
14 })
AddPinComponent template
We're loading our template using a templateUrl. In that template, we setup our form
much like the ng1 form, only we're using ng2 form directives.
We're not going to describe ngModel / ngSubmit deeply here. If you'd like to
know more about how Angular forms work, checkout the forms chapter,
where we describe forms in depth.
Converting an AngularJS 1.x App to Angular 672
code/upgrade/hybrid/src/app/add-pin/add-pin.component.html
1 <div class="container">
2 <div class="row">
3
4 <form (ngSubmit)="onSubmit()"
5 class="form-horizontal">
6
7 <div class="form-group">
8 <label for="title"
9 class="col-sm-2 control-label">Title</label>
10 <div class="col-sm-10">
11 <input type="text"
12 class="form-control"
13 id="title"
14 name="title"
15 placeholder="Title"
16 [(ngModel)]="newPin.title">
17 </div>
We're using two directives here: ngSubmit and ngModel.
We use (ngSubmit) on the form to call the onSubmit function when the form is
submitted. (We'll define onSubmit on the AddPinComponent controller below.)
We use [(ngModel)] to bind the value of the title input tag to the value of
newPin.title on the controller.
Here's the full listing of the template:
code/upgrade/hybrid/src/app/add-pin/add-pin.component.html
1 <div class="container">
2 <div class="row">
3
4 <form (ngSubmit)="onSubmit()"
5 class="form-horizontal">
6
7 <div class="form-group">
8 <label for="title"
9 class="col-sm-2 control-label">Title</label>
10 <div class="col-sm-10">
11 <input type="text"
12 class="form-control"
Converting an AngularJS 1.x App to Angular 673
13 id="title"
14 name="title"
15 placeholder="Title"
16 [(ngModel)]="newPin.title">
17 </div>
18 </div>
19
20 <div class="form-group">
21 <label for="description"
22 class="col-sm-2 control-label">Description</label>
23 <div class="col-sm-10">
24 <input type="text"
25 class="form-control"
26 id="description"
27 name="description"
28 placeholder="Description"
29 [(ngModel)]="newPin.description">
30 </div>
31 </div>
32
33 <div class="form-group">
34 <label for="url"
35 class="col-sm-2 control-label">Link URL</label>
36 <div class="col-sm-10">
37 <input type="text"
38 class="form-control"
39 id="url"
40 name="url"
41 placeholder="Link URL"
42 [(ngModel)]="newPin.url">
43 </div>
44 </div>
45
46 <div class="form-group">
47 <label for="url"
48 class="col-sm-2 control-label">Image URL</label>
49 <div class="col-sm-10">
50 <input type="text"
51 class="form-control"
52 id="url"
53 name="url"
54 placeholder="Image URL"
55 [(ngModel)]="newPin.src">
56 </div>
Converting an AngularJS 1.x App to Angular 674
57 </div>
58
59 <div class="form-group">
60 <div class="col-sm-offset-2 col-sm-10">
61 <button type="submit"
62 class="btn btn-default"
63 >Submit</button>
64 </div>
65 </div>
66 <div *ngIf="saving">
67 Saving...
68 </div>
69 </form>
AddPinComponent Controller
Now we can define AddPinComponent. We start by setting up two instance variables:
code/upgrade/hybrid/src/app/add-pin/add-pin.component.ts
15 export class AddPinComponent {
16 saving = false;
17 newPin: Pin;
We use saving to indicate to the user that the save is in progress and we use newPin
to store the Pin we're working with.
code/upgrade/hybrid/src/app/add-pin/add-pin.component.ts
19 constructor(@Inject('PinsService') private pinsService: PinsService,
20 @Inject('$state') private uiState: IStateService) {
21 this.newPin = this.makeNewPin();
22 }
In our constructor we Inject the services, as we discussed above. We also set
this.newPin to the value of makeNewPin, which we'll define now:
Converting an AngularJS 1.x App to Angular 675
code/upgrade/hybrid/src/app/add-pin/add-pin.component.ts
24 makeNewPin(): Pin {
25 return {
26 title: 'Steampunk Cat',
27 description: 'A cat wearing goggles',
28 user_name: 'me',
29 avatar_src: '/assets/images/avatars/me.jpg',
30 src: '/assets/images/pins/cat.jpg',
31 url: 'http://cats.com',
32 faved: false,
33 id: Math.floor(Math.random() * 10000).toString()
34 };
35 }
This looks a lot like how we defined it in ng1, only now we have the benefit of it
being typed.
When the form is submitted, we call onSubmit. Let's define that:
code/upgrade/hybrid/src/app/add-pin/add-pin.component.ts
37 onSubmit(): void {
38 this.saving = true;
39 console.log('submitted', this.newPin);
40 setTimeout(() => {
41 this.pinsService.addPin(this.newPin).then(() => {
42 this.newPin = this.makeNewPin();
43 this.saving = false;
44 this.uiState.go('home');
45 });
46 }, 2000);
47 }
Again, we're using a timeout to simulate the effect of what would happen if we had
to call out to a server to save this pin. Here, we're using setTimeout. Compare that
to how we defined this function in ng1:
Converting an AngularJS 1.x App to Angular 676
code/upgrade/ng1/js/app.js
82 ctrl.submitPin = function() {
83 ctrl.saving = true;
84 $timeout(function() {
85 PinsService.addPin(ctrl.newPin).then(function() {
86 ctrl.newPin = makeNewPin();
87 ctrl.saving = false;
88 $state.go('home');
89 });
90 }, 2000);
91 }
Notice that in ng1 we had to use the $timeout service. Why is that? Because ng1 is
based around the digest loop. If you use setTimeout in ng1, then when the callback
function is called, it's "outside" of angular and so your changes aren't propagated
unless sth kicks off a digest loop (e.g. using $scope.apply).
However in ng2, we can use setTimeout directly because change detection in ng2
uses Zones and is therefore, more or less automatic. We don't need to worry about
the digest loop in the same way, which is really nice.
In onSubmit we're calling out to the PinsService by:
this.pinsService.addPin(this.newPin).then(() => {
// ...
});
Again, the PinsService is accessible via this.pinsService because of how we
defined the constructor. The compiler doesn't complain because we said that addPin
takes a Pin as the 1st argument in our app.d.ts:
code/upgrade/hybrid/src/js/app.d.ts
13 pins(): Promise<Pin[]>;
14 addPin(pin: Pin): Promise<any>;
15 }
And we defined this.newPin to be a Pin.
Converting an AngularJS 1.x App to Angular 677
After addPin resolves, we reset the pin using makeNewPin and set this.saving =
false.
To go back to the homepage, we use the ui-router $state service, which we stored
as this.uiState. So we can change states by calling this.uiState.go('home').
Using AddPinComponent
Now let's use the AddPinComponent.
Downgrade ng2 AddPinComponent
To use AddPinComponent we need to downgrade it:
code/upgrade/hybrid/src/app/app.module.ts
27 angular.module('interestApp')
28 .directive('pinControls',
29 upgradeAdapter.downgradeNg2Component(PinControlsComponent))
30 .directive('addPin',
31 upgradeAdapter.downgradeNg2Component(AddPinComponent));
This will create the addPin directive in ng1, which will match the tag <add-pin>.
Routing to add-pin
In order to use our new AddPinComponent page, we need to place it somewhere within
our ng1 app. What we're going to do is take the add state in our router and just set
the <add-pin> directive to be the template:
Converting an AngularJS 1.x App to Angular 678
code/upgrade/hybrid/src/js/app.js
39 .state('add', {
40 template: "<add-pin></add-pin>",
41 url: '/add',
42 resolve: {
43 'pins': function(PinsService) {
44 return PinsService.pins();
45 }
46 }
47 })
Exposing an ng2 service to ng1
So far we've downgraded ng2 components to be used in ng2 and upgraded ng1
services to be used in ng2. But as our application start converting over to ng2, we'll
probably start writing services in TS/ng2 that we'll want to expose to our
ng1 code.
Let's create a simple service in ng2: an "analytics" service that will record events.
The idea is that we have an AnalyticsService in our app that we use to recordEvents.
In reality, we're just going to console.log the event and store it in an array.
But it gives us a chance to focus on what's important: describing how we share a ng2
service with ng1.
Writing the AnalyticsService
Let's take a look at the AnalyticsService implementation:
Converting an AngularJS 1.x App to Angular 679
code/upgrade/hybrid/src/app/analytics.service.ts
1 import { Injectable } from '@angular/core';
2
3 /**
4 * Analytics Service records metrics about what the user is doing
5 */
6 @Injectable()
7 export class AnalyticsService {
8 events: string[] = [];
9
10 public recordEvent(event: string): void {
11 console.log(`Event: ${event}`);
12 this.events.push(event);
13 }
14 }
There are two things to note here: 1. recordEvent and 2. being Injectable
recordEvent is straightforward: we take an event: string, log it and store it in
events. In your application you would probably send the event to an external service
like Google Analytics or Mixpanel.
To make this service injectable, we do two things: 1. Annotate the class with
@Injectable and 2. bind the token AnalyticsService to this class.
The @Injectable decorator really means that other dependencies can be
injected into this service, but it's recommended to add it to all services,
even those that don't have dependencies. Read more about @Injectable in
the chapter on dependency injection
Now Angular will manage a singleton of this service and we will be able to inject it
where we need it.
Downgrade ng2 AnalyticsService to ng1
Before we can use the AnalyticsService in ng1, we need to downgrade it.
The process of downgrading an ng2 service to ng1 is similar to the process of
downgrading a directive, but there is one extra step: we need to make sure AnayticsService
is in the list of providers for our NgModule:
Converting an AngularJS 1.x App to Angular 680
code/upgrade/hybrid/src/app/app.module.ts
43 @NgModule({
44 declarations: [
45 AppComponent,
46 AddPinComponent,
47 PinControlsComponent
48 ],
49 imports: [
50 BrowserModule,
51 FormsModule,
52 HttpClientModule
53 ],
54 providers: [
55 AnalyticsService
56 ]
57 })
58 export class AppModule { }
Then we can use downgradeNg2Provider:
code/upgrade/hybrid/src/app/app.module.ts
33 angular.module('interestApp')
34 .factory('AnalyticsService',
35 upgradeAdapter.downgradeNg2Provider(AnalyticsService));
We call angular.module('interestApp') to get our ng1 module and then call
.factory like we would in ng1. To downgrade the service, we call
upgradeAdapter.downgradeNg2Provider(AnalyticsService), which wraps our AnalyticsService
in a function that adapts it to an ng1 factory.
Using AnalyticsService in ng1
Now we can inject our ng2 AnalyticsService into ng1. Let's say we want to record
whenever the HomeController is visited. We could record this event like so:
Converting an AngularJS 1.x App to Angular 681
code/upgrade/hybrid/src/js/app.js
60 .controller('HomeController', function(pins, AnalyticsService) {
61 AnalyticsService.recordEvent('HomeControllerVisited');
62 this.pins = pins;
63 })
Here we inject AnalyticsService as if it was a normal ng1 service we call recordEvent.
Fantastic!
We can use this service anywhere we would use injection in ng1. Np. we
can also inject the AnalyticsService into our ng1 pin directive:
code/upgrade/hybrid/src/js/app.js
64 .directive('pin', function(AnalyticsService) {
65 return {
66 restrict: 'E',
67 templateUrl: '/assets/templates/pin.html',
68 scope: {
69 'pin': "=item"
70 },
71 link: function(scope, elem, attrs) {
72 scope.toggleFav = function() {
73 AnalyticsService.recordEvent('PinFaved');
74 scope.pin.faved = !scope.pin.faved;
75 }
76 }
77 }
78 })
Summary
Now you have all the tools you need to start upgrading your ng1 app to a hybrid
ng1/ng2 app. The interoperability between ng1 and ng2 works very well and we owe
a lot to the Angular team for making this so easy.
Being able to exchange directives and services between ng1 and ng2 make it super
easy to start upgrading your apps. We can't always upgrade our apps to ng2
overnight, but the UpgradeAdapter lets us start using ng2 - without having to throw
our old code away.
Converting an AngularJS 1.x App to Angular 682
References
If you're looking to learn more about hybrid Angular apps, here are a few resources:
• The Official Angular Upgrade Guide¹⁵⁰
• The Angular2 Upgrade Spec Test¹⁵¹
• The Angular2 Source for DowngradeNg2ComponentAdapter¹⁵²
¹⁵⁰https://angular.io/docs/ts/latest/guide/upgrade.html
¹⁵¹https://github.com/angular/angular/blob/master/modules/angular2/test/upgrade/upgrade_spec.ts
¹⁵²https://github.com/angular/angular/blob/master/modules/angular2/src/upgrade/downgrade_ng2_adapter.ts
NativeScript: Mobile
Applications for the Angular
Developer
In this chapter, we're going to walk through how to build your first
NativeScript app. NativeScript is a huge topic that could warrant it's own
book.
Here we're going to explain NativeScript for the Angular Developer.
By the end of this chapter you'll understand the differences between
NativeScript and a 'regular' Angular web-app and have the foundation
to be creating your own native apps using NativeScript and Angular.
Being that Angular was designed to be unspecific to any particular deployment
platform, you can take much of your web application code and reuse it beyond just
the web.
It is the norm for businesses to have not only a fully functional web application, but
a mobile application to compliment it as well. A few years back, companies would
need to spend countless dollars to fund a team of iOS and Android developers to
accomplish the same task of creating a mobile application.
With Angular, mobile development becomes not only cheaper, but more maintainable
and efficient.
What is NativeScript?
NativeScript is a cross platform mobile development framework that leverages
technologies you already know: JS, CSS and of course, Angular.
NativeScript: Mobile Applications for the Angular Developer 684
NativeScript Showcase
With NativeScript, developers can build native iOS and Android applications using
a single shared code base.
Where NativeScript Differs from Other Popular
Frameworks
NativeScript isn't the 1st or only framework to make it easy to develop Android
and iOS applications using a single code base. Mobile development frameworks can
be separated into two: hybrid mobile and native mobile.
Hybrid Mobile Applications
Hybrid mobile frameworks are those such as Ionic Framework¹⁵³, PhoneGap¹⁵⁴,
Apache Cordova¹⁵⁵ and Onsen UI¹⁵⁶. These are frameworks that allow you to develop
¹⁵³https://ionicframework.com/
¹⁵⁴http://phonegap.com/
¹⁵⁵https://cordova.apache.org/
¹⁵⁶https://onsen.io/
NativeScript: Mobile Applications for the Angular Developer 685
mobile applications using web technologies, but render these mobile applications in
what's called a web view. A web view is essentially a web browser and it allows you
to use HTML with full DOM support for all your component rendering.
The conveniences of a web view is not without limitation. The number one flaw in
using a web view to render mobile applications comes down to performance. Not all
mobile devices are treated as equal even if they have the same version of Android or
iOS. There are thousands of different mobile handsets in existence all with varying
hardware and processing power, not to mention all the custom flavors of Android.
Because of this diversity, the consistency in web view performance is very poor,
leaving some people with an amazing user experience and some with hardly useable
applications.
Native Mobile Applications
Native mobile applications built with frameworks such as NativeScript¹⁵⁷, React
Native¹⁵⁸ and Xamarin¹⁵⁹ do not render in a web view. These are applications that
use the native UI components that Google and Apple made available to developers
and as a result don't suffer from performance instability.
So how does one choose between the available native mobile frameworks? The simple
answer is to choose between each of their underlying development technologies.
React Native uses ReactJS, a common JS framework for web developers,
and Xamarin uses C#, a common development language for .NET developers.
NativeScript of course uses Angular.
As an Angular developer, it makes sense to go the NativeScript route because we'll
get fantastic native performance while keeping our familiar Angular development
experience.
What are the System and Development Requirements
for NativeScript?
NativeScript doesn't have any system requirements beyond what you'd need when
developing Objective-C based iOS applications or Java based Android applications.
¹⁵⁷https://www.nativescript.org/
¹⁵⁸https://facebook.github.io/react-native/
¹⁵⁹https://www.xamarin.com/
NativeScript: Mobile Applications for the Angular Developer 686
Np. let's say you wanted to build and deploy an Android application
developed with NativeScript. You would need at least the following:
• Windows, Linux, or Mac
• Java Development Kit (JDK) 8+
• 4GB of hard drive space
• 4GB of RAM
The above system and software requirements are what's necessary for installing and
using the Android SDK.
If you wanted to build and deploy and iOS application with NativeScript, the
requirements are a bit different:
• Mac
• Xcode 7+
• 5GB of hard drive space
• 4GB of RAM
Notice the main difference here is that a Mac is required. While you can develop
Android and iOS applications with NativeScript, you cannot actually build and
deploy iOS applications unless you're using a Mac. This is a limitation that exists
because of Apple.
From a development perspective, NativeScript uses the Node Package Manager
(NPM) a tool that is part of Node.js and sth you probably already have
installed as an Angular developer. With NPM, the NativeScript CLI can be installed
using the following command:
1 npm install -g nativescript
NativeScript: Mobile Applications for the Angular Developer 687
Installing NativeScript
A list of available commands can be found by running tns --help or tns help if you
wish to view them in a web browser rather than the Command Prompt or Terminal.
For more information on installing NativeScript for Mac, Windows and Linux, visit
the NativeScript installation documentation¹⁶⁰.
There are a significant number of tools to be installed to do native app
development. Once everything is installed properly, NativeScript development
is relatively painless, but make sure you visit the URL above if you
run into any trouble getting the NativeScript build tools installed.
With the NativeScript CLI, native mobile applications can be developed with Angular.
¹⁶⁰https://docs.nativescript.org/start/quick-setup.html
NativeScript: Mobile Applications for the Angular Developer 688
Creating your 1st Mobile Application with
NativeScript and Angular
To be successful in developing NativeScript applications with Angular, you should
already have the NativeScript CLI tool installed and either Xcode or the Android
SDK installed, or both.
The goal here is to become familiar with the mobile application creation process
and some of the UX and UI differences between an Angular web application and an
Angular NativeScript application.
Using the Command Prompt (Windows) or Terminal (Mac and Linux), execute the
following:
1 tns create NgProject --ng
The above command will create a project directory, NgProject, wherever your
command line's active directory is located. The --ng flag indicates that we want
to create an Angular with TS project. It is necessary to use the --ng flag
because NativeScript doesn't require Angular to build mobile applications. It is an
option, one that we're going to take full advantage of.
Adding Build Platforms for Cross Platform Deployment
While a project has been created and can be actively developed, there are no build
platforms such as Android or iOS enabled for building and deployment.
To build for a specific platform, it must 1st be added. Using the NativeScript CLI,
execute the following:
1 tns platform add [platform]
Just swap out [platform] with either android or ios depending on which you wish
to add, remembering that iOS requires a Mac with Xcode installed.
NativeScript: Mobile Applications for the Angular Developer 689
Building and Testing for Android and iOS
When the application is ready for testing or deployment to the app stores, we can
make use of a few NativeScript CLI commands. Before deployment, you'll probably
want to test the application on your device or emulator. Using the command line,
execute the following to emulate the application:
1 tns emulate [platform]
Swapping [platform] with android or ios will launch the application in the specified
emulator. To test the application on a device, swap out emulate with the word run
while your device is connected to your development machine.
1 tns run [platform]
The emulation process can often take a bit of time because a lot of recompilation
happens in the process. To make development more efficient, the NativeScript
CLI offers live-reload functionality called live-sync. We can utilize this feature by
executing the following command in our terminal:
1 tns livesync [platform] --emulator --watch
After swapping [platform] with either android or ios, changes made to TS,
CSS, or HTML files will be automatically deployed to the Android or iOS simulator,
much faster than if you were to strictly emulate the application.
When it comes to deploying our app to the app store, we can use the following
command:
1 tns build [platform]
After replacing [platform] with the appropriate platform, the binaries and build
packages will be created.
NativeScript: Mobile Applications for the Angular Developer 690
Installing JS, Android and iOS Plugins and
Packages
Like with any Angular web application, there are external components available to
make the development process easier. This applies to NativeScript applications as
well.
Most JS packages will work in a NativeScript application as long as there isn't
a dependency on the DOM. As previously mentioned, NativeScript being a native
framework, doesn't use a web view and has no concept of a DOM. JS libraries
can be included via NPM, for example:
1 npm install jssha --save
The above would install the JS hashing library, jsSHA, to your Angular
NativeScript project.
There are native plugins available strictly for NativeScript as well. These are typically
plugins that make use of native device features or interface with Android or iOS
directly in some fashion.
Take, Np. the NativeScript SQLite plugin:
1 tns plugin add nativescript-sqlite
The above command will install SQLite functionality for both Android and iOS.
Understanding the Web to NativeScript UI
and UX Differences
As a web developer you're probably very familiar with HTML and common design
practices for building attractive, responsive and overall great web applications. With
NativeScript we're using Angular and CSS, but we're not using HTML. Instead we
are using XML which won't have the same markup tags that you'd find in HTML.
So how do you take your UI and UX skills to mobile?
NativeScript: Mobile Applications for the Angular Developer 691
There are a few things that need to be taken into consideration when designing
your mobile application. You need to worry about the screen layout and the screen
components.
Planning the NativeScript Page Layout
When designing a web application, common layout components include <div> tags
and <table> tags. Generally if you want a grid of rows and columns you'd use a
table and if you wanted a stack of components you'd use a div because it acted as a
container.
In NativeScript, you don't have the <div> and <table> tags, but you have sth
similar. Instead you have the <StackLayout> and <GridLayout> tags.
So let's compare web and NativeScript.
Let's say we wanted to contain a bunch of HTML components on a website. You
might do sth like the following:
1 <div>
2 <span>Nic Raboy was here</span>
3 <span>https://www.thepolyglotdeveloper.com</span>
4 </div>
To accomplish the same in a NativeScript application, you'd do the following:
1 <StackLayout>
2 <Label text="Nic Raboy was here"></Label>
3 <Label text="https://www.thepolyglotdeveloper.com"></Label>
4 </StackLayout>
In both the web and NativeScript scenarios you can nest the <div> and <StackLayout>
tags as appropriate to create more component groupings.
The use of grids in NativeScript and on the web are a bit different in structure, but
the same in concept. Take the following HTML:
NativeScript: Mobile Applications for the Angular Developer 692
1 <table>
2 <tr>
3 <td>Nic</td>
4 <td>Raboy</td>
5 </tr>
6 <tr>
7 <td>Burke</td>
8 <td>Holland</td>
9 </tr>
10 </table>
In NativeScript, instead of defining rows and columns with <tr> and <td> tags
sth a little different happens:
1 <GridLayout rows="auto, auto" columns="*, *">
2 <Label text="Nic" row="0" col="0"></Label>
3 <Label text="Raboy" row="0" col="1"></Label>
4 <Label text="Burke" row="1" col="0"></Label>
5 <Label text="Holland" row="1" col="1"></Label>
6 </GridLayout>
In the above <GridLayout> we define that we want two rows that take the height of
their child components and two columns that stretch evenly to fill the screen.
But what about a flexbox, commonly found on the web?
When building websites, there is the opportunity to set <div> tags, or any other
container, to have a CSS property of display: flex. This allows websites to behave
appropriately for different screen sizes. Nearly the same can be used in NativeScript
using the <FlexboxLayout> as a container, which is nearly the same as the web's
implementation.
Adding UI Components to the Page
When it comes to NativeScript there are many UI components available, each
accomplishing sth different. For example we already saw how to display static
text on the screen through the use of the <Label> component, but what other options
are available?
NativeScript: Mobile Applications for the Angular Developer 693
There are too many components to name, but some of the common components
include buttons, images, lists and inputs. These are all components that are common
to what you'd find in a web application as well.
To add a button to our application, we'd add the following to one of our layouts:
1 <Button text="Submit Me" (tap)="myFunc()"></Button>
Notice the use of the (tap) attribute. This is not specific to the UI component, but
more a mixture of Angular and NativeScript. In a web application these events are
better known as (click) events, however, they both accomplish the same.
To include an image, local or remote, within an application, we can use the <Image>
tag like so (similar to the <img /> tag on the web):
1 <Image src="https://placehold.it/350x150"></Image>
Many mobile applications, like web applications, collect data from users. This data
is collected through forms composed of text input fields. To accept text input in a
NativeScript application, make use of the <TextField> tag like the following:
1 <TextField
2 text="First Name"
3 [(ngModel)]="firstname"></TextField>
The [(ngModel)] attribute seen above is identical to that which is found in an
Angular web application. It allows the binding of data between the UI and the
TS paired to it.
It is often necessary to list large amounts of data within a mobile application. This
data is presented in what is called a <ListView>. These lists are populated from arrays
of strings or objects that are defined within the application TS.
NativeScript: Mobile Applications for the Angular Developer 694
1 <ListView [items]="people">
2 <Template let-person="item">
3 <Label [text]="person.firstname"></Label>
4 </Template>
5 </ListView>
The above snippet will create a list from an array of objects called people. Each object
in the array will be called person and the firstname of each person will be displayed
in a list row.
Again, there are many other components available, some not heard of in the land of
web development. However, they are all similar by design.
Just like with web components, NativeScript UI components don't look attractive in
their vanilla state. They need to be themed and styled with some artistic flair.
Styling Components with CSS
There are a few options available when it comes to giving a NativeScript application
a boost in the attractiveness department, just as there is in web design.
NativeScript allows UI components to be styled with a CSS subset. To be clear, most
web CSS will work in NativeScript, but not everything. To change the font color of
a <Label> component, the following is an option:
1 .title {
2 color: #cc0000;
3 }
The class name can then be applied to the UI component in the same fashion as with
HTML.
Creating a custom stylesheet isn't the only solution when it comes to making
a NativeScript application more attractive. When building a website, there are
frameworks such as Bootstrap that were designed to make life easier. We can
translate this same concept with NativeScript.
There is what is called NativeScript Theme, which is a package of CSS styles designed
to be easily added to any application.
Take the following action bar with button example:
NativeScript: Mobile Applications for the Angular Developer 695
1 <ActionBar title="NgBook"></ActionBar>
2 <StackLayout>
3 <Button text="Default UI"></Button>
4 </StackLayout>
The above code would generate a native, but very plain looking action bar with a
very plain looking button. On Android and iOS, it would look like the following:
NativeScript Basic CSS
This simple UI can be significantly improved by using NativeScript Theme. For
example, take the minor revisions to the code snippet found below:
1 <ActionBar title="NgBook" class="action-bar"></ActionBar>
2 <StackLayout>
3 <Button text="Themed UI" class="btn btn-primary"></Button>
4 </StackLayout>
A few class names were applied to the components giving them a much more pleasant
look and feel as demonstrated in the image below:
NativeScript Theme CSS
The naming conventions for the theme classes have a similar naming convention to
those found in the popular web frameworks.
NativeScript: Mobile Applications for the Angular Developer 696
Developing a Geolocation Based Photo
Application
Taking what we know about Angular, web development and the NativeScript
mobile framework, we can apply it towards creating a native and functional mobile
application for both iOS and Android.
Much of what comes next will be a review of the Angular skills you already have,
but in a mobile example. The example application will use geolocation and the Flickr
API to show images that were captured near you.
NativeScript Photos Near Me
The application will have two pages that act as a master-detail interface meaning the
first page will list data and the second page will show more information about the
data selected from the 1st page.
The completed project can be found in the sample code under
code/nativescript/photos-near-me.
NativeScript: Mobile Applications for the Angular Developer 697
Creating a Fresh NativeScript Project
To get the most out of this demo, it would be good to start with a new project. As a
review to what was mentioned previously, a project can be created by executing the
following:
1 tns create GeoPhotoProject --ng
2 cd GeoPhotoProject
3 tns platform add android
4 tns platform add ios
The above commands will create an Angular NativeScript project called GeoPhotoProject
with the Android and iOS build platforms. To be able to build iOS
applications we must be using a Mac with Xcode installed.
The default project template will be a single page application, so we'll have to add
more pages and configure the Angular Router.
Creating a Multiple Page Master-Detail Interface
The default project template uses the project's app/app.component.html file as the
default page. This file will still be valuable in this project, but we're going to create
two new pages.
Let's create a few of the new components we'll use by executing the following
commands to create necessary files and directories:
1 mkdir -p app/components/image-component
2 mkdir -p app/components/imagesList-component
3 touch app/components/image-component/image.component.ts
4 touch app/components/image-component/image.component.html
5 touch app/components/imagesList-component/imagesList.component.ts
6 touch app/components/imagesList-component/imagesList.component.html
We can also create these directories manually in our Explorer window, if the mkdir
or touch commands are not available in our command-line (or if we just feel more
comfortable in the UI).
NativeScript: Mobile Applications for the Angular Developer 698
The 1st page in our application flow will be the imagesList.component page to
display all the list of photos.
Let's open the project's app/components/imagesList-component/imagesList-component.
ts file and include the following basic class code:
1 import { Component, NgZone } from "@angular/core";
2 import { Router } from "@angular/router";
3
4 @Component({
5 selector: "ImagesListComponent",
6 templateUrl: "components/imagesList-component/imagesList.component.html"
7 })
8 export class ImagesListComponent {
9
10 public constructor(private zone: NgZone, private router: Router) { }
11
12 }
In the above code the ImagesListComponent class is being defined and various
Angular components are being imported and injected into the constructor method
in the usual method.
The UI that goes with the ImagesListComponent class is found in the app/components/
imageList-component/imagesList-component.html file. For now, let's
update the file to contain following HTML markup:
1 <ActionBar title="Photos" class="action-bar"></ActionBar>
2 <StackLayout>
3 </StackLayout>
Before we add useful functionality to the 1st page of our application, let's lay the
foundation to the second page and link them together.
Open the project's app/components/image-component/image-component.ts file
and include the following TS code:
NativeScript: Mobile Applications for the Angular Developer 699
1 import { Component, OnInit } from "@angular/core";
2 import { ActivatedRoute } from "@angular/router";
3
4 @Component({
5 templateUrl: "components/image-component/image.component.html"
6 })
7 export class ImageComponent implements OnInit {
8
9 public constructor(private activatedRoute: ActivatedRoute) { }
10
11 public ngOnInit() { }
12
13 }
In the above code the ImageComponent class is created and various Angular components
are imported and injected in the constructor method. The core difference
here, as of now, is the ngOnInit method which is going to be used to load data after
the page loads.
The UI that goes with the TS code is found in the app/components/imagecomponent/
image-component.html file and it will contain, for now, the following
HTML markup:
1 <ActionBar></ActionBar>
2 <StackLayout>
3 </StackLayout>
With the pages available, they need to be brought together for Angular routing. This
requires two things to happen. 1st, the routes need to be defined and second they
need to be included in the project's @NgModule block.
Let's create an app/app.routing.ts file in our project and include the following
routing configuration code:
NativeScript: Mobile Applications for the Angular Developer 700
code/nativescript/photos-near-me/app/app.routing.ts
1 import { ImagesListComponent } from "./components/imagesList-component/imagesList.compone\
2 nt";
3 import { ImageComponent } from "./components/image-component/image.component";
4
5 export const routes = [
6 { path: "", component: ImagesListComponent },
7 { path: "image-component/:photo_id", component: ImageComponent },
8 ];
9
10 export const navigatableComponents = [
11 ImagesListComponent,
12 ImageComponent
13 ];
In the above code, both the ImagesListComponent and ImageComponent classes were
imported. The routes define how to navigate to each of the classes and what data
can be passed. The ImagesListComponent has an empty path which represents the
default, or 1st page that loads when the application starts. The ImageComponent has
a path with one URL parameter which represent a piece of data that can be passed
from the ImagesListComponent page to the ImageComponent page.
Without getting too far ahead of ourselves, the photo_id represents the photo we
wish to load in the second page. This is a piece to the Flickr API.
The app/app.routing.ts file needs to be imported and added to the project's @Ng-
Module block. In our project's app/app.module.ts file and include the following
TS code:
1 import { NativeScriptModule } from "nativescript-angular/platform";
2 import { NgModule } from "@angular/core";
3 import { NativeScriptFormsModule } from "nativescript-angular/forms";
4 import { NativeScriptHttpModule } from "nativescript-angular/http";
5 import { NativeScriptRouterModule } from "nativescript-angular/router";
6 import { registerElement } from "nativescript-angular/element-registry";
7
8 import { AppComponent } from "./app.component";
9 import { routes, navigatableComponents } from "./app.routing";
10
11 @NgModule({
12 imports: [
NativeScript: Mobile Applications for the Angular Developer 701
13 NativeScriptModule,
14 NativeScriptFormsModule,
15 NativeScriptHttpModule,
16 NativeScriptRouterModule,
17 NativeScriptRouterModule.forRoot(routes)
18 ],
19 declarations: [
20 AppComponent,
21 ...navigatableComponents,
22 ],
23 bootstrap: [AppComponent],
24 providers: []
25 })
26 export class AppModule {}
There is more setup in this file than what you'll find in the default. To save us some
time we're importing the NativeScriptFormsModule, NativeScriptHttpModule, and
NativeScriptRouterModule along with the routes and navigatableComponents variables
that were defined in the previous file.
Each module is added to the imports array of the @NgModule block and the two page
classes found in the navigatableComponents variable are added to the declarations
array.
Even though the application doesn't do much at the moment, it is linked together
and ready to go. Adding UI components and functionality will be explored later on.
Finally, we'll need to add a place for our pages to render via our routes. In our main
app component in app/app.component.html, let's add the <page-router-outlet/>
markup to tell Angular where to render our subroutes. Since we don't have any
common views between views, can replace all of the content with this markup:
1 <page-router-outlet></page-router-outlet>
Creating a Flickr Service for Obtaining Photos and Data
Flickr will be a critical part of this application. Instead of calling the Flickr API
directly in each of the pages we wish to use it, the better approach would be to
create an Angular service, also known as a provider.
NativeScript: Mobile Applications for the Angular Developer 702
In a Flickr provider we can add logic to query for photos based on latitude and
longitude information as well as get information about particular photos.
Before designing this provider it is a good idea to create a global configuration file
for the application. This will prevent hard coded URL values, amongst other things,
in the application.
Let's create a app/config.ts file and include the following:
1 export const Config = {
2 Flickr: {
3 CLIENT_ID: "FLICKR_CLIENT_ID_HERE",
4 API_URL: "https://api.flickr.com/services/rest/?"
5 }
6 };
Before using the Flickr API, an account needs to be created to obtain a client id. We'll
head to https://www.flickr.com/services/api/¹⁶¹ and create an account.
¹⁶¹https://www.flickr.com/services/api/
NativeScript: Mobile Applications for the Angular Developer 703
Flickr will create a client_id that will be unique to our application. The value of the
FLICKR_CLIENT_ID_HERE in our app/config.ts file.
With the configuration file created, we need to define a data model for the Flickr
responses. While not absolutely necessary, it does create a more maintainable
TS application.
Let's create the app/models directory, if it does not already exist:
1 mkdir app/models
Create an app/models/getInfoResponse.ts file and include the following TS
code:
NativeScript: Mobile Applications for the Angular Developer 704
code/nativescript/photos-near-me/app/models/getInfoResponse.ts
1 interface Owner {
2 username: string;
3 realname: string;
4 }
5
6 export class GetInfoResponse {
7 owner: Owner;
8 farm: number;
9 server: number;
10 secret: string;
11 id: number;
12 url: string;
13 }
The above represents the data that is returned from the Flickr flickr.photos.getInfo
RESTful endpoint. The data makes it possible to obtain an image file along with
holding information about that image file.
The second model we need is for Flickr search data. Create an app/models/photosSearchResponse.
ts file with the following TS code:
code/nativescript/photos-near-me/app/models/photosSearchResponse.ts
1 export class PhotosSearchResponse {
2 id: string;
3 owner: string;
4 secret: string;
5 server: number;
6 title: string;
7 latitude: string;
8 longitude: string;
9 datetaken: string;
10 url_t: string;
11 url_m: string;
12 url_q: string;
13 url_n: string;
14 distance: string;
15
16 constructor() {
17 this.url_n = " ";
18 }
19 }
NativeScript: Mobile Applications for the Angular Developer 705
The above model holds useful information such as the photo id, the owner, and
geolocation information all useful when discovering images and displaying them
on the second page of the application.
With the data models created, we can now create the Flickr service. Let's create a file
at app/services/flickr.service.ts in the project.
1 mkdir app/services
2 touch app/services/flickr.service.ts
We'll start with this foundation, in the flickr.service.ts file:
1 import { Component, Injectable } from "@angular/core";
2 import { Http, Response } from "@angular/http";
3 import { Observable } from "rxjs/Rx";
4 import { Config } from "../app.config";
5 import { PhotosSearchResponse } from "../models/photosSearchResponse";
6 import { GetInfoResponse } from "../models/getInfoResponse";
7 import "rxjs/add/operator/map";
8
9 @Injectable()
10 export class FlickrService {
11
12 public constructor(private http: Http) { }
13
14 public photosSearch(lat: number, lon: number): Observable<PhotosSearchResponse[]> { }
15
16 public getPhotoInfo(photoId: number): Observable<GetInfoResponse> { }
17
18 }
Both the photosSearch and getPhotoInfo functions return observables which are
streams of data obtained by HTTP requests to the Flicker API.
The photosSearch function will take a latitude and longitude and apply it towards
Flickr's API like follows:
NativeScript: Mobile Applications for the Angular Developer 706
code/nativescript/photos-near-me/app/services/flickr.service.ts
14 public photosSearch(lat: number, lon: number): Observable<PhotosSearchResponse[]> {
15 let url = `${Config.Flickr.API_URL}method=flickr.photos.search&api_key=${Config.F\
16 lickr.CLIENT_ID}&content_type=1&lat=${lat}&lon=${lon}&extras=url_q,geo&format=json&nojson\
17 callback=1`;
18
19 return this.http.get(url)
20 .map(response => response.json().photos.photo)
21 .catch(error => Observable.throw(error));
22 }
An HTTP request is made per the Flickr API documentation. Using RxJS, the response
of the request is transformed using the map operator to be of type PhotosSearchResponse.
If there is an error in the response, it will be caught through the normal http
promise error chain. Just like normal Angular, our HTTP request won't execute until
the observable is subscribed.
The getPhotoInfo method will take a photo id, probably from the result returned in
the previous photosSearch function:
code/nativescript/photos-near-me/app/services/flickr.service.ts
22 public getPhotoInfo(photoId: number): Observable<GetInfoResponse> {
23 let url = `${Config.Flickr.API_URL}method=flickr.photos.getInfo&api_key=${Config.\
24 Flickr.CLIENT_ID}&photo_id=${photoId}&format=json&nojsoncallback=1`;
25
26 return this.http.get(url)
27 .map(response => response.json().photo)
28 .catch(error => Observable.throw(error));
29 }
Like with the photosSearch function, the getPhotoInfo function makes a HTTP
request against the Flickr API and parse the response using RxJS.
Before the Flickr provider can be used throughout the application, it must be added
to the @NgModule block similarly to how the application pages were added.
Inside the project's app/app.module.ts file, we need to import the Flickr service must
be imported and then add it to the providers array in the @NgModule block:
NativeScript: Mobile Applications for the Angular Developer 707
1 import { FlickrService } from "./services/flickr.service";
2
3 @NgModule({
4 // ...
5 providers: [FlickrService]
6 })
7 ...
The Flickr provider can now be used in the various pages of the application.
Creating a Service for Calculating Device Location and
Distance
Up until now, all the TS has been general to Angular and with nothing to do
with NativeScript. This geolocation application will have dependence on the location
of the Android or iOS device so NativeScript must be used to natively interface with
the GPS components.
Because GPS will be used throughout the application, it is a good idea to create an
Angular provider for it. This will keep the code clean and maintainable.
Before creating the provider, a JS library must be installed into the project.
1 npm install humanize-distance --save
The humanize-distance library allows us to calculate the distance between two
latitude and longitude locations. This will be particularly useful when checking our
user's device location versus that of a photo returned from Flickr.
We'll also need to include a nativescript library called nativescript-geolocation
using the tns plugin command:
1 tns plugin add nativescript-geolocation
Let's create another service called the geolocation.service:
NativeScript: Mobile Applications for the Angular Developer 708
1 touch app/services/geolocation.service.ts
In this new file, let's include the following foundation code:
1 import { Injectable } from "@angular/core";
2 import * as geolocation from "nativescript-geolocation";
3 var humanizeDistance = require("humanize-distance");
4
5 @Injectable()
6 export class GeolocationService {
7
8 public latitude: number;
9 public longitude: number;
10
11 public getLocation(): Promise<any> { }
12
13 public getDistanceFrom(latitude: number, longitude: number): string { }
14
15 private _getCurrentLocation(): Promise<any> { }
16
17 }
This provider will be injectable into the application pages. It will use the nativescriptgeolocation
plugin which interfaces with native Android and iOS GPS code. The
humanize-distance library is imported differently because it is JS rather than
TS.
code/nativescript/photos-near-me/app/services/geolocation.service.ts
35 private _getCurrentLocation(): Promise<any> {
36 return new Promise(
37 (resolve, reject) => {
38 geolocation.getCurrentLocation({
39 desiredAccuracy: Accuracy.high,
40 timeout: 20000
41 })
42 .then(location => {
43
44 this.latitude = location.latitude;
45 this.longitude = location.longitude;
46
47 resolve();
48 })
NativeScript: Mobile Applications for the Angular Developer 709
49 .catch(error => {
50 reject(error);
51 })
52 }
53 );
54 }
Using the geolocation plugin we can get the current longitude and latitude of the
device GPS. This is an asynchronous request and must be added to a JS
promise or observable. The result of _getCurrentLocation will be a promise of any
data.
Not all devices have GPS hardware and both Android and iOS require permissions
to use location services. Because of this a few checks must be put into place.
code/nativescript/photos-near-me/app/services/geolocation.service.ts
12 public getLocation(): Promise<any> {
13 return new Promise(
14 (resolve, reject) => {
15 if (!geolocation.isEnabled()) {
16 geolocation.enableLocationRequest(true).then(() => {
17 this._getCurrentLocation()
18 .then(resolve)
19 .catch(reject);
20 });
21 }
22 else {
23 this._getCurrentLocation()
24 .then(resolve)
25 .catch(reject);
26 }
27 }
28 );
29 }
Using the getLocation method a check to see if the geolocation service is enabled is
made. If it is not enabled, a request to enable it will be made. Provided that everything
checks out, a call to the other _getCurrentLocation function will be made. This also
applies if the geolocation service is enabled already.
With the device location in hand, a distance can be calculated from a different
location, more than likely the picture distance.
NativeScript: Mobile Applications for the Angular Developer 710
code/nativescript/photos-near-me/app/services/geolocation.service.ts
31 public getDistanceFrom(latitude: number, longitude: number): string {
32 return humanizeDistance({ latitude: latitude, longitude: longitude }, { latitude:\
33 this.latitude, longitude: this.longitude }, 'en-US', 'us');
34 }
The getDistanceFrom method will use the humanize-distance library to get us a
better distance format like kilometers, miles, etc.
Like with the Flickr provider, the geolocation provider needs to be added the project's
@NgModule block. Let's open our project's app/app.module.ts file and include the
following lines:
1 import { GeolocationService } from "./services/geolocation.service";
2
3 @NgModule({
4 // ...
5 providers: [FlickrService, GeolocationService]
6 })
7 ...
Essentially, we're importing the provider and adding it to the providers array of the
@NgModule block. At this point the geolocation provider can be used throughout the
application.
Including Mapbox Functionality in the NativeScript
Application
As of right now neither of the two application routes have any functionality that is
particularly useful. The application has two very useful providers, but they aren't
being used yet.
Since geolocation will be used, it makes sense to present a map. There are many
options when it comes to maps. Two popular map solutions are Mapbox and Google
Maps. For this example Mapbox renders itself the most convenient.
To install Mapbox in a NativeScript application, execute the following:
NativeScript: Mobile Applications for the Angular Developer 711
1 tns plugin add nativescript-mapbox
The Mapbox plugin for NativeScript has its own set of available HTML markup
tags. To expose these tags in an Angular application, they must be registered in the
project's app/app.module.ts file like so:
1 import { registerElement } from "nativescript-angular/element-registry";
2
3 var map = require("nativescript-mapbox");
4 registerElement("Mapbox", () => map.Mapbox);
Once registered, the <Mapbox> tag can be used within HTML files. However, Mapbox
requires a valid API token in order to be used.
Register for an API token via the Mapbox Developers Page¹⁶².
Let's store the value of the mapbox access_token open the project's app/config.js
file. This is the same file where we added the Flickr API information. Modify this
file to look like the following:
¹⁶²https://www.mapbox.com/developers/
NativeScript: Mobile Applications for the Angular Developer 712
1 export const Config = {
2 Flickr: {
3 CLIENT_ID: "FLICKR_CLIENT_ID_HERE",
4 API_URL: "https://api.flickr.com/services/rest/?"
5 },
6 MapBox: {
7 ACCESS_TOKEN: "MAPBOX_ACCESS_TOKEN_HERE"
8 }
9 };
The Mapbox API token will be obtained similarly to how the Flickr API token was
obtained within the application. While Mapbox hasn't been added to the UI or the
page logic, it is not able to be added.
Implementing the 1st Page of the Geolocation
Application
There was a lot of preparation that went into this project so far, but each of the pages
are now ready to be crafted.
Open the app/components/imageList-component/imageList.component.ts file that
was created earlier. We added foundation, but now it is time to finish it with
functional logic.
1 import { Component, NgZone } from "@angular/core";
2 import { FlickrService } from "../../services/flickr.service";
3 import { PhotosSearchResponse } from "../../models/photosSearchResponse";
4 import { Router } from "@angular/router";
5 import { GeolocationService } from "../../services/geolocation.service";
6 import { Config } from "../../app.config";
7
8 @Component({
9 selector: "ImagesListComponent",
10 templateUrl: "components/imagesList-component/imagesList.component.html"
11 })
12 export class ImagesListComponent {
13
14 private mapbox: any;
15 public mapboxKey: string;
16 public photos: PhotosSearchResponse[];
17
NativeScript: Mobile Applications for the Angular Developer 713
18 public constructor(private flickrService: FlickrService, private geolocationService: \
19 GeolocationService, private zone: NgZone, private router: Router) { }
20
21 public onMapReady(args) { }
22
23 public dropMarkers() { }
24
25 public centerMap(args: any) { }
26
27 public showPhoto(args: any) { }
28
29 public loadPhotos() { }
30
31 }
In the above TS file, each of the services and models that were previously
created are now being imported into the page. The ImagesListComponent has a
private variable which will hold the Mapbox and several public variables that will
be bound to the UI.
In the constructor method each of the two providers are injected so they can be
used throughout the current page of the application.
In a typical Angular application an OnInit would be used after the constructor
method has executed. To prevent a race condition, this page will not make use of it.
Instead, an onMapReady method will be created and used via the HTML markup. In
other words, when the Mapbox thinks it's ready, this onMapReady method will trigger.
code/nativescript/photos-near-me/app/components/imagesList-component/images-
List.component.ts
22 public onMapReady(args) {
23 this.mapbox = args.map;
24 this.geolocationService.getLocation().then(() => {
25 this.loadPhotos().subscribe(
26 photos => {
27 this.photos = photos.map((photo) => {
28 photo.distance = this.geolocationService.getDistanceFrom(
29 parseFloat(photo.latitude),
30 parseFloat(photo.longitude));
31 return photo;
32 });
33 this.dropMarkers();
34 this.mapbox.setCenter({
NativeScript: Mobile Applications for the Angular Developer 714
35 lat: this.geolocationService.latitude,
36 lng: this.geolocationService.longitude,
37 animated: true
38 });
39 },
40 error => console.log(error));
41 });
42 }
Once triggered, the mapbox variable will be set with the current Mapbox. Using
the geolocation service, the device GPS location is obtained and Flickr photos near
the location are queried. A humanized distance is calculated for each of the photos
retrieved from the API call.
The photos obtained from the Flickr API are stored in the photos array at which
point they are placed as markers on the map using the dropMarkers method. At the
end of the initialization period the map is centered on the devices location.
The dropMarkers method called from the onMapReady looks like the following:
code/nativescript/photos-near-me/app/components/imagesList-component/images-
List.component.ts
44 public dropMarkers() {
45 let markers = this.photos.map((photo: PhotosSearchResponse, index: number) => {
46 return {
47 lat: photo.latitude,
48 lng: photo.longitude,
49 onTap: () => {
50 this.zone.run(() => {
51 this.showPhoto({ index: index });
52 });
53 }
54 }
55 });
56 this.mapbox.addMarkers(markers);
57 }
In the above method, the photos array is recreated through a JS map and
stored as markers. The new objects found in the array include the longitude and
latitude of the photo and a tap event, showPhoto, which will navigate to the next
NativeScript: Mobile Applications for the Angular Developer 715
page. To keep everything in sync, the showPhoto method must be added within the
Angular zone.
The markers array is added to the Mapbox for display on the soon to be created map
component.
code/nativescript/photos-near-me/app/components/imagesList-component/images-
List.component.ts
68 public showPhoto(args: any) {
69 let photo = this.photos[args.index];
70 this.router.navigate(["/image-component", photo.id]);
71 }
The route to the second page of the application requires a photo id. This information
is obtained from a specific photo that was selected. Remember, the photo information
was added within the dropMarkers method.
code/nativescript/photos-near-me/app/components/imagesList-component/images-
List.component.ts
73 public loadPhotos() {
74 return this.flickrService.photosSearch(
75 this.geolocationService.latitude,
76 this.geolocationService.longitude);
77 }
The loadPhotos method was used in the onMapReady method for subscribing to the
Flickr observable. It was created to make the lines of the file shorter and easier to
read.
The final method of the 1st application page, centerMap, will center the map on a
particular photo:
NativeScript: Mobile Applications for the Angular Developer 716
code/nativescript/photos-near-me/app/components/imagesList-component/images-
List.component.ts
59 public centerMap(args: any) {
60 let photo = this.photos[args.index];
61 this.mapbox.setCenter({
62 lat: parseFloat(photo.latitude),
63 lng: parseFloat(photo.longitude),
64 animated: false
65 });
66 }
So what does the UI markup look like for the TS logic that was just
implemented? Open the project's app/components/imageList-component/image-
List.component.html file. The UI is composed of two vertical sections, a list of
pictures which resides on the upper level and a map which resides on the lower
level.
1 <ActionBar title="Photos" class="action-bar"></ActionBar>
2 <StackLayout>
3 <GridLayout columns="*" rows="*, 280">
4 <ListView [items]="photos" row="0" col="0" class="list-group" (itemTap)="centerMa\
5 p($event)">
6 </ListView>
7 <ContentView row="1" col="0">
8 </ContentView>
9 </GridLayout>
10 </StackLayout>
In the above markup a GridLayout will allow for vertical sections, hence the two row
values. The asterisk in the columns means that each row will take the full width of
the screen. Since there is an asterisk and numeric value in the rows, the bottom row
will have a height of 280 and the top row will take all remaining part of the screen.
The ListView is setup to iterate over each element in the public photos array. When
a row is tapped, the centerMap method is called to position the map over the photo
that was clicked. The ContentView is the second row and it will hold the map.
The ListView is incomplete though. It should really look like the following:
NativeScript: Mobile Applications for the Angular Developer 717
1 <ListView [items]="photos" row="0" col="0" class="list-group" (itemTap)="centerMap($event\
2 )">
3 <template let-item="item">
4 <GridLayout columns="auto, *" rows="auto" class="list-group-item">
5 <Image [src]="item.url_q" width="50" height="50" col="0" class="thumb img-rou\
6 nded"></Image>
7 <StackLayout row="0" col="1">
8 <Label [text]="item.distance + ' away'" class="list-group-item-heading"><\
9 /Label>
10 <Label [text]="item.title" class="list-group-item-text" textWrap="true"><\
11 /Label>
12 </StackLayout>
13 </GridLayout>
14 </template>
15 </ListView>
Each row of the ListView will have two columns and an automatically sized row
height. The 1st column of the list row will be the image returned from the Flickr
API and the second column will have stacked text which includes the photo title and
the humanized distance.
1 <ContentView row="1" col="0">
2 <Mapbox
3 accessToken="{{ mapboxKey }}"
4 mapStyle="streets"
5 zoomLevel="17"
6 hideLogo="true"
7 showUserLocation="true"
8 (mapReady)="onMapReady($event)">
9 </Mapbox>
10 </ContentView>
The Mapbox calls the onMapReady function and uses the mapboxKey found in the
configuration file. Other default properties are used as well.
The first and default, page of the application is now complete. However, a page for
showing the picture still needs to be completed. This is the page navigated to after
tapping a marker on the map.
NativeScript: Mobile Applications for the Angular Developer 718
Implementing the Second Page of the Geolocation
Application
The second and final page of the application will show an image based on what
was selected in the previous page. Open the project's app/components/imagecomponent/
image.component.ts file and include the following TS code:
1 import { Component, OnInit } from "@angular/core";
2 import { ActivatedRoute } from "@angular/router";
3 import { FlickrService } from "../../services/flickr.service";
4
5 @Component({
6 templateUrl: "components/image-component/image.component.html"
7 })
8 export class ImageComponent implements OnInit {
9
10 public url: string;
11
12 public constructor(private activatedRoute: ActivatedRoute, private flickrService: Fli\
13 ckrService) { }
14
15 public ngOnInit() { }
16
17 public getPhoto(photoId: number) { }
18
19 }
The Flickr provider was imported to what was created previously and it is injected
into the constructor method. The url variable will hold the image URL that will be
bound to and presented in the UI.
NativeScript: Mobile Applications for the Angular Developer 719
code/nativescript/photos-near-me/app/components/image-component/image.component.ts
14 public ngOnInit() {
15 this.activatedRoute.params.subscribe(params => {
16 let photoId = params["photo_id"];
17 this.getPhoto(photoId);
18 });
19 }
When this page is initialized, the ngOnInit method will obtain the URL parameter
and pass it to the getPhoto message.
code/nativescript/photos-near-me/app/components/image-component/image.component.ts
21 public getPhoto(photoId: number) {
22 this.flickrService.getPhotoInfo(photoId).subscribe(
23 photo => {
24 this.url = `https://farm${photo.farm}.staticflickr.com/${photo.server}/${\
25 photo.id}_${photo.secret}_n.jpg`;
26 },
27 error => console.log(error)
28 );
29 }
After making a request to the Flickr API with the Flickr provider, the public url
variable will be filled.
With the logic in place, open the project's app/components/image-component/image-
component.html file and include the following markup:
1 <ActionBar></ActionBar>
2 <StackLayout>
3 <Image [src]="url" width="360" height="360"></Image>
4 </StackLayout>
The Image tag will present an image based on the url that was populated in the
TS code. Within the action bar, there will be a back button to navigate to the
previous page.
Try it out!
Now that we have the basic structure for our app in place, try running:
NativeScript: Mobile Applications for the Angular Developer 720
1 tns livesync android --emulator --watch
2 # or
3 tns livesync ios --emulator --watch
When you're ready to create a build call:
1 tns build android
2 # or
3 tns build ios
NativeScript for Angular Developers
NativeScript makes it very easy for Angular developers to develop native mobile
applications that use native device features, SDKs and concepts. As technology
evolves for the best, the need to know Java or Objective-C is dwindling in favor
of these cross platform mobile development frameworks.
Obviously there is a lot more to learn about using NativeScript than we can cover in
just this 1st chapter. Checkout these resources:
• Official NativeScript Site¹⁶³
• Official NativeScript Docs¹⁶⁴
• NativeScript App Examples¹⁶⁵
• NativeScript on StackOverflow¹⁶⁶
¹⁶³https://www.nativescript.org/
¹⁶⁴https://docs.nativescript.org/
¹⁶⁵https://www.nativescript.org/app-samples-with-code
¹⁶⁶http://stackoverflow.com/questions/tagged/nativescript

zzz
        --------------	WEB DEVELOPMENT WITH ANGULAR AND BOOTSTRAP	----------------------------------------------
            
    ■ CHAPTER 1 QUICK START

        ANGULAR'S EVOLUTION
        Angular is a frontend JS-based web application framework, that provides u with everything u need, with which to build amazingly powerful Single Page Applications (SPAs)
        While Angular wasn't the 1st JS-based frontend web application framework, it was quite possibly the most powerful 1 of them - this is likely due to Angular's SPAcentric focus
        The initial release of Angular was in late fall of 2010. Since then, dozens of competing libraries and frameworks have come on the scene, including some, 
        that also have large adoptions and large production implementations, such as: Ember.js, Backbone.js, React.js. Angular, despite having perhaps the highest learning curve, remains the most powerful of them all
    
        The Angular naming and versioning jungle can, at 1st glance, seem confusing:
(B)     Angular's 1.x releases: Basically, any release prior to Angular 2 is commonly referred to as AngularJS. AngularJS is no more actively in development mode. It has been put under long term support mode.
        Angular framework is being actively developed and so developers need to be specific about which of the 2 Angular frameworks they are referring to, when discussing them
        Fortunately, there are 2 completely dedicated websites for them:    https://angularjs.org/      https://angular.io
        The Angular team adopted semantic versioning, starting with the 2.0.0 release. You can read more about semantic versioning: https://semver.org
(B)     Angular 2 was a complete rewrite of Angular 1.x (that is, AngularJS) and is thus not backward compatible with AngularJS
        Version 3 was skipped, as a release number altogether. Due to having adopted semantic versioning, the Angular team never released Angular 3 and so went straight from Angular 2 to Angular 4
        Specifically, there was a misalignment of the router package's version, which was already distributed as version 3.3.0. We'll cover routing in Angular in great detail in Chapter 4, Routing
        Just know, that there wasn't ever an Angular 3. No big deal. In the Windows OS world, there was never a Windows 9 either. These things happen 
        While Angular 4 was not a complete rewrite of Angular 2, it did have some changes in its core libraries, that required the team to increment its major number from 2 to 4
(B)     All releases from Angular 2 onward are commonly referred to as Angular 2+ / simply just as Angular
        
        You should really only be using Angular and not AngularJS (unless u have an exceptionally good reason for it)
        With the exception of there not being an Angular 3, there will be 2 major releases per year - they should be contiguous in numbering scheme (that is, 8, 9 and so on) 
        and they are expected to be backward compatible - at least within the same major version number (as per the spirit of semantic versioning)
(B)     The official Angular release schedule: https://angular.io/guide/releases
        Since Angular is a complete rewrite of the AngularJS platform and this is worlds apart from AngularJS, we'll skip AngularJS altogether and start by taking a look at Components, which are Angular's building blocks
        
        ANGULAR'S BUILDING BLOCKS
        Adding new features is the business of publishing new frameworks - but luckily, the fundamental underlying architecture does not change very often. When it does, it's not typically a complete overhaul
(B)     With the exception of Angular 2.0, which was completely divergent from its predecessor, all major releases so far contain largely the same architecture. Core architectural pieces of the framework:

            1) Components - are like widgets, that are in charge of displaying themselves along with the data they consume and / or manipulate on areas of your screen called "views"
            An Angular application is like a tree of components and Angular provides mechanisms for components to communicate with each other in a bidirectional manner - parent to child and child to parent

            2) Templates - components rely on their templates for rendering their data. Templates are where u define what the component looks like and u can hook in styles to window-dress your component any way u like
            A component can either contain its template (HTML) and its styling (CSS) either directly within itself / have references to template and style files outside of itself
            At the end of the day, the world's fanciest frontend frameworks produce HTML, CSS and JS, because these 3 things are the only things, browsers understand
            
            3) Directives - within the templates, u create for your component, Angular enables u to alter the DOM with powerful constructs called "directives"
            There are directives for controlling the way things are rendered on the screen (that is, the component view) such as repeating snippets of HTML / for displaying things based on conditional logic for hiding or showing thingsb / filtering arrays of data and much more
            
            4) Modules - Angular is modular. That is to say, that its functionality is wrapped up in modules, known as "NgModules" and are themselves libraries. Modules are perfect for lumping code together in an organized way
            Np. there are modules for helping with forms, routing and communicating with RESTful APIs. Many 3rd-party libraries are packaged as NgModules, so u can incorporate them into your Angular applications
            2 examples of this are "Material Design" and "AngularFire" - we'll be taking a look at both of these libraries in later chapters
            
            5) Services - are not really an Angular artifact per se, but rather a very general notion representing encompassed functionality, functions and features, that your application's components may need to consume
            Things such as logging, data retrieval / virtually any calculation / lookup service, can be written as services - these services can reside within your application / live externally from it
            You can think of a service, as a highly specialized class, that provides some service (such as looking up the distance between 2 zip codes) and does it well
(B)         Just as with components, not only are there tons of 3rd-party services u can use in your Angular applications, but u can create your own custom services. We'll learn how to do this in Chapter 12, Integrating Backend Data Services
            
            6) Dependency injection (DI) / Inversion of Control (IoC) - is a very useful and common software design pattern. This pattern is used to inject objects into the objects, that depend on them
            The object you're using, that depends on other objects, can just go ahead and use it without needing to worry, where it is, in order to load it / how to instantiate it - u just use it, as if it just sprung into existence, at the time u needed it
            Services are perfect for injecting into our application. We'll learn how to use DI in Angular and how we can use the Angular command-line interface (CLI) to generate injectable services of our own design
        
(B)     AngularJS was built using JS, while Angular was built using TS. While this adds a level of abstraction, when writing Angular applications, using TS provides a few important advantages 
        when building larger apps with larger teams - we'll get to those shortly. AngularJS was based on controllers, whereas Angular is component based. You'll learn all u need to know about components in Chapter 6, Building Angular Components
        
        SPAs are notorious for being difficult for implementing Search Engine Optimization (SEO), but Angular is SEO friendly
        It's possible to build native mobile applications with Angular. It's also possible to build cross-platform, desktop-installed applications with Angular. Angular can also run on the server, using Angular Universal
        You have to admit, this is a pretty impressive and exciting list. These things and more make learning Angular a worthwhile endeavor and the marketplace is asking for Angular knowhow
        
        SETTING UP YOUR DEVELOPMENT ENVIRONMENT
        In order to get started with Angular, you're going to need to have the Angular CLI installed - to install that, u 1st need to have "Node.js" and "npm" (node package manager) installed
        If you've already got Node.js and npm installed, great ! If not, don't worry - they are easy to install and I will take u through the installation process in Appendix A, Toolchain for Web Development with Angular, near the back of the book
        In Appendix A, I also take u through installing the Angular CLI and how to use it for building Angular applications. For brevity, I'll refer to the Angular CLI tool, as just the CLI from this point forward
        
        If u are unsure, whether u have NodeJS and npm installed, you can check really quickly, by typing "$ node -v" and "$ npm -v" on your command line
        Similarly, u can type "$ ng -v" on the command line to see whether you have CLI installed. If u get a version number back, u have that particular tool installed (as shown in the following screenshot I took)
        Do not type $ at the beginning of the commands. The $ signifies the command prompt, entry point for the commands you'll type. Unix-based operating systems, such as macOS and Linux systems, 
        commonly use $ or % as their command prompt-depending on the shell being used, or if there are any custom settings specified in a configuration file on your system
        Windows operating systems typically use the greater than sign, >, as their command prompt
        
        We'll also need a code editor. There are many code editors available today, including a number of free ones. Though any code editor will suffice, I would suggest you use Visual Studio Code for your Angular development
        The reason for this is that Visual Studio Code is free, it's cross-platform and is an excellent code editor. It's also the code editor, that I've used while writing this book and so when I suggest the use of an extension, you can easily install the same one
        
        Zainstaluj Node.js:         https://nodejs.org/en/              Razem z Node.js - automatycznie instaluje się "npm"
        Zainstaluj Angular:         npm install -g @angular/cli

        The preceding is all u need for this 1st chapter. When we start building the example project, which requires us to have a local database, you'll also need to install MongoDB
(B)     MongoDB, also known as Mongo, is a great NoSQL database, that is also free and crossplatform. I take you through Mongo's installation process in Appendix B, MongoDB
        Additionally, there will be other software, that you'll need to install, such as Chrome extensions and I will let u know, what they are and where to find them at the appropriate time. For now, let's get started with writing some Angular code
        
        WRITING YOUR 1ST ANGULAR APPLICATION
        When it comes to experimenting with Angular code, as u pick up this awesomely powerful framework, u generally have 2 choices of how to proceed. The 1st is to use an online code editor such as JSFiddle, Plunker, StackBlitz or more
        In Appendix C, Working with StackBlitz, you'll learn about the basics of using StackBlitz, so u can use it from time to time to test some quick code, without needing a test project in your development environment. You can visit the StackBlitz website here: https://stackblitz.com
        The 2nd approach is to use your own local development environment - and since we've already set it up in the previous section, u can create a project, whose sole purpose is to run some quick example code, if you'd rather use that, than an online code editor
        My goal is to show u, that u have options - there's not just 1 way to experiment with some code, as u learn Angular
        When u use an online code editor, such as StackBlitz, the only software u need installed, is a browser - no other tools whatsoever. While this makes things very easy, the trade-off is, that u are extremely restricted in what u can do
        That being said, I encourage u to experiment with an online code editor, but we'll only be using our development environments throughout this book
        So let's do that and create a small application together in just a few minutes time - we'll build a to-do list app
        
        Using your development environment
        From this point forward, we'll be using our terminals + the CLI + the Visual Studio Code. Head on over to https://code.visualstudio.com, where you'll be able to download the Visual Studio Code installation package for your operating system of choice
     
        Location of your files
        When it comes to setting up a local environment, u can, of course, place your directories and files wherever u like. If you have a folder, where u have your web application projects, go to it now
        If u don't have a dedicated place for projects, this is as good a time as any, to get into the habit of being organized. Np. on my machine, I have a folder named "dev" for any and all development I do
        Within my "dev" folder, I have a folder named "playground", where I have a subfolder for each technology I'm learning / playing with
        I prefer to use a Mac, when writing code and so my complete pathname to where I have my Angular play stuff is /Users/akii/dev/playground/angular (as shown at the bottom of the screenshot of my terminal, a few pages back)
        That same screenshot also shows the versions of Node.js, npm and the CLI that I had installed at the time of writing. If having a directory structure like this works for u, by all means, use it
        If u already have a way u organize your work, use that. The important thing is to be very disciplined and consistent with how you organize your development environment
        
        Generating our "to do list" application
        With the installation of what we need now being out of the way - meaning we have our CLI tool available to us - go to your terminal and type the following at your command
            ng new todolist --style=scss --routing            
        The "ng" command runs the CLI tool and its new command instructs it to create a new Angular application. The application, in this case, is named "to-dolist"
(B)     You'll notice, that there also are 2 command-line flags, which are special options for the new command. The "style" flag tells the CLI, that we'd like to use scss, instead of css 
        and the "routing" flag tells the CLI, that we'd like it to integrate and set up routing for us by default. We'll be using SASS, as opposed to CSS, in this book and SCSS is the file extension for Sass files
        As a reminder, we're going to have a crash course on Sass in Chapter 3, Bootstrap - Grid Layout and Components
        The 1st time u use the CLI to create your Angular application, it will take anywhere from 45sec to well over a minute for it to create your project for u
        This is because it needs to download and install various things for u, before it creates the project's folder structure. However, when creating subsequent Angular applications, the CLI won't take nearly as long
        
        Serving up our to do list application
(B)     Once the CLI has completed creating the application, u can run it by changing to the project directory "cd to-dolist" and issuing the 
            ng serve                    This will have the CLI run your application
(B)     The CLI's built-in web server will be listening on localhost port 4200 by default. By the way, the CLI's web server keeps watch on your project files and when it notices a change in 1 of your files, 
        it reloads the application - there's no need for u to stop the server and issue the server command again. This is very convenient, as you're making lots of changes and tweaks during development
        Next, open your browser and visit http://localhost:4200 and u should see sth like the following, which proves, that the CLI is working correctly
        Now, that the CLI created the to-do list application for u, open that folder in Visual Studio Code (I'll be referring to Visual Studio Code as the IDE)
        You should see a folder structure for your "to-do" list project in the left-hand panel of your IDE, similar to the following (except for the "to-do" folder, which u won't have just yet; 
        we'll get to how to generate that using the CLI in the upcoming subsection on components). The following is a screenshot of the to-do list project in the IDE (with the app.component.ts file open):
        When working on your Angular applications, the vast majority of your time will be spent working within the "src | app" folder
                
        ANGULAR BASICS
        Components are the basic building blocks of Angular. In fact, u can think of an Angular web application as a tree of components
        When u use the CLI to generate the shell for your Angular application, the CLI also autogenerates 1 component for u. The filename is app.component.ts and is in the src/app folder
        The "app" component is how your Angular application is bootstrapped - meaning, that it is the 1st component, that is loaded and all the other components are pulled into it. This also means, that components can be nested
        The previous screenshot shows our project directory structure, with the "src/app" folder expanded and the app.component.ts open in the IDE's file editor window
(B)     The .ts file extension indicates, that it is a TS file. Interesting note - when u write Angular applications, u use TS instead of JS. In fact, the Angular team used TS to write Angular !
        After the following "Components" section, u'll find a complete code listing for our Angular application. There are 6 files, that u'll have to edit
        3 of them are already available in the application, that u generated with the CLI
        The other 3 will be available in your project, once u use the CLI to generate the "to-do" component, which is the directory, that u are presently missing, when u compare your project structure to the previous screenshot
        You'll find out how to do that in the following Components section, which is why the complete code listing was inserted afterward
        Don't worry - follow along, keep the faith, that Angular mastery is within your grasp and you'll be just fine. If u don't believe me, just lie down on the floor and mumble these words, This too, shall pass, 3 times, slowly
        
        Components
        This section is a high-level fly-by on Angular components - just enough coverage of what an Angular component is
        Chapter 6, Building Angular Components, is completely dedicated to Angular components and is where we're going to take a deep dive into them
        Consider this section to be a little peek behind the component curtain and when we get to discussing components, we're going to pull the curtains wide open and take a good look at the Component Wizard of Oz
        Remember, that in the Wizard of Oz story, Dorothy and the gang were petrified of the Wizard, but when he was finally revealed behind the curtains, they all soon stopped being scared
     
(B)     As previously mentioned, u can think of components, as the basic building blocks and of your Angular application as a tree of nested components
(A)     Buttons, progress bars, input fields, entire tables, advanced things, such as carousels and even custom video players - these are all "components"
        The components on your web page can communicate with each other and Angular has a couple of rules and protocols for how they can go about doing so
        
(B)     When u write a component file, as in the code that follows, there are 3 MAIN SECTIONS to it:
        1) The 1st is the "import" section
        2) The middle section is the component "decorator" and it's where u indicate, what the component's template file is (which defines what the component looks like) and what the components style file is (which is used to style the component)
               Note: Since we used the "style=scss" flag, we get our file in SCSS, as opposed to the traditional CSS type file
        3) The "export" section is the last section in the component file and is where all the logic for the component will be placed
        There's a lot more, that can go into a component's TS file, than what is shown in the following code snippet, as we'll see in Chapter 6, Building Angular Components

            import { Component } from '@angular/core';                  to jest plik "app.component.ts"
            @Component({
                selector: 'app-root',
                templateUrl: './app.component.html',
                styleUrls: ['./app.component.scss']
            })
            export class AppComponent {
                title = 'app';
            }

        The CLI created the "app" component for us by default, when it created our application for us, but how do we create our own components ? 
        The easiest way to generate a new component is to use the CLI: 
(B)         ng generate component name-of-component
        So, to generate a new component named "todoitem", we would type:                     Remember to do this from within the src | app folder
            ng generate component todoitem              (UWAGA - W KSIĄŻCE JEST TROCHĘ INNA NAZWA. TA TUTAJ JEST PRAWIDŁOWA. UŻYWAJ KODU Z FOLDERA (ŚCIĄGNIJ KOD Z WWW !!!))
        The CLI will generate this component and insert it into its own folder and the name of the newly created folder will be the same as the component
      
        Inside this folder, u will see 4 new files and their names all start with "to-do-item.component", because the name of our component is "to-do-item" and it's a component
        We'll discuss what the file ending in "spec.ts" is used for later, but u may already have a good guess as to what the other 3 files are for
(B)     The component file itself is indeed the 1 named "todoitem.component.ts". This file contains a reference to 2 of the others:
        - to-do-item.component.html - which is the template for the component (the HTML code for defining its markup structure)
        - to-do-item.component.scss file, which will hold the styling for the component
        Additionally, the CLI modified an existing file named "app.module.ts". We'll discuss this file in more detail later on, but for now, all u need to know is, that this file acts as a registry for your application's components
        
        You may be thinking - that's a lot of files. Are they all needed ? The short answer to that is "no"
(B)     In Chapter 5 "Flex-Layout - Angular's Responsive Layout Engine" - we'll look at how we can eliminate the .html file and the .scss files and just put all of our component stuff (the HTML and the styling) into our component file
        However, there is a reason the Angular team provided the mechanism to have all these things be separate - so your application's code can be tidy and organized. You can thank them later
            ng g c name-of-component        - shortcut syntax, when using the CLI to generate a component            "g" is short for generating and "c" is short for the component
        
        Code listing for the "to-do-list" application
        Now, that u have the to-do component generated, u have 4 new files within the "to-do-item" folder. You'll edit 3 of them to look like the following code listings, that follow
        You also need to edit 3 of the files, that were already in your project (where we'll open the curtains to meet the wizard), we can also integrate components from other libraries and frameworks into our application
        We'll take a look at how to do this with NG Bootstrap in "Chapter 6 Building Angular Components" and with Angular Material in "Chapter 7 Templates, Directives and Pipes"
(B)     There's no shortage of components for Angular and the amount available for your use will only grow over time
      
        Whenever I learn new technology and follow along with a book / blog post / whatever else - I enter everything in by hand - even, when the files are available for download
        Yes, manual entry can be a tedious process, but it engages your brain and the material and concepts start to get absorbed
        Simply downloading the files and cutting and pasting the contents into your application does not have the same effect. I'll let u decide, which way u want to go
        If u opt for downloading the code, there are instructions at the beginning of this book for doing so
        
        The code listing for todoitem.component.html (within the src | app | todoitem folder):
            <div class="container dark">
                <div class="column">
                    <p>Add a todo item</p>
                </div>
                <div class="column">
                    <p>Todo list ({{ itemCount }} items)</p>
                </div>
            </div>
            <div class="container light">
                <div class="column">
                    <p class="form-caption">Enter an item to add to your todo list</p>
                    <form>
                        <input type="text" class="regular" name="item" placeholder="Todo item ..." [(ngModel)]="todoItemText">
                        <input type="submit" class="submit" value="Add todo" (click)="addTodoItem()">
                    </form>
                </div>
                <div class="column">
                    <p class="todolist-container" *ngFor="let todoItem of todoItems">{{ todoItem }}</p>
                </div>
            </div>
        
        The code listing for todoitem.component.ts (within the src | app | todoitem folder) is as follows:
            import { Component, OnInit } from '@angular/core';
            @Component({
            selector: 'app-todoitem',
            templateUrl: './todoitem.component.html',
            styleUrls: ['./todoitem.component.scss']
            })
            export class TodoitemComponent implements OnInit {
            itemCount: number;
            todoItemText: string;
            todoItems = [];
            ngOnInit() {
            this.itemCount = this.todoItems.length;
            }
            addTodoItem() {
            this.todoItems.push(this.todoItemText);
            this.todoItemText = '';
            this.itemCount = this.todoItems.length;
            }
            }

        The code listing for todoitem.component.scss (within the src | app | todoitem folder) is as follows:
            .container {
            display: grid;
            grid-template-columns: 50% auto;
            }
            .column {
            padding: .4em 1.3em;
            }
            .dark {
            background: #2F4F4F;
            }
            .light {
            background: #8FBC8F;
            }
            input.regular {
            border: 0;
            padding: 1em;
            width: 80%;
            margin-bottom: 2em;
            }
            input.submit {
            border: 0;
            display: block;
            padding: 1em 3em;
            background: #eee;
            color: #333;
            margin-bottom: 1em;
            cursor: pointer;
            }
            .todolist-container {
            background: rgb(52, 138, 71);
            padding: .6em;
            font-weight: bold;
            cursor: pointer;
            }
            .form-caption {
            }
        
        The following is the code listing for app.component.html (within the src | app folder)
            <app-todoitem></app-todoitem>
            <router-outlet></router-outlet>
        
        The code listing for app.module.ts (within the src | app folder) is as follows:     UWAGA - KOD W KSIĄŻCE I W FOLDERZE Z WWW TEŻ JEST BŁĘDNY. TEN TUTAJ JEST POPRAWIONY - DZIAŁA !!!
            import { BrowserModule } from '@angular/platform-browser';
            import { NgModule } from '@angular/core';
            import { FormsModule } from '@angular/forms';
            import { AppRoutingModule } from './app-routing.module';
            import { AppComponent } from './app.component';
            import { TodoitemComponent } from './todoitem/todoitem.component';
            @NgModule({
            declarations: [
            AppComponent,
            TodoitemComponent
            ],
            imports: [
            BrowserModule,
            AppRoutingModule,
            FormsModule
            ],
            providers: [],
            bootstrap: [AppComponent]
            })
            export class AppModule { }
        
        The code listing for app.component.scss (within the src | app folder)
            /* You can add global styles to this file and also import other style files */
            body {
                font-family: Arial, Helvetica, sans-serif;
                color: #eee;
                background: #869bbd;
                padding: 4em;
                }
                a {
                color: #fff;
                text-decoration: none;
                }
                ul {
                list-style-type: none;
                margin: 0 0 2em 0;
                padding: 0;
                }
                ul li {
                display: inline;
                margin-right: 25px;
                }
                ul li a {
                font-size: 1.5em;
                }

        Cool! So, now u have all the code in place. Do u remember how to run your Angular application ? 
            ng serve                at your command prompt and once the message comes up, that the compilation was successful, open your browser and go to  http://localhost:4200
        Does the application work ? If so, congratulations on building your 1st Angular application ! If not, check for typos. Play around with your new application
        We haven't bothered to take the time to add functionality to edit the to-do item / delete them, but u can clear it out by just reloading the application, by hitting your browser's "refresh" button
        Why do things get cleared out upon refreshing the page ? This happens, because we have an SPA and are not persisting the data, that we enter into a database
        We'll definitely be sure to add the ability to persist our data, when we build our much larger application, which will be introduced to u by the end of this chapter
        
        Interpolation
(B)     Interpolation is how u get a value from a variable within your component class to render in the component's template. If u recall, the logic for the component goes in the export section of the component class
        That is the same place, where variables are, that u would like to use interpolation to have their values rendered in the template (that is, rendered on the web page)
        Let's assume, that u have a variable called "items" and that its value is currently "4"
(B)     To render the value in the template, u use a pair of double curly braces with the variable in between them. The variables and component logic are written inside the class
        Don't worry - we'll see lots of code snippets throughout the book, that use interpolation, but for now, u can see this sample code, that shows it in action
        The code is meaningless and hardcoded for now, but it does demonstrate interpolation:
        The 1st screenshot is of the component file (home.component.ts) - the variable is declared on line 10:
                items: number = 4;
        This 2nd screenshot is of the component's template file (home.component.html) - notice the pair of double curly braces on line 6:
                <p>Todo list ({{ items }} items)</p>
        This last screenshot shows the rendered value "4" in this case. That's the basics of interpolation. We'll see much more advanced usage of it throughout the book, as we work on our annotated photo album
     
        Templating and styling
        We've already mentioned sth about templating and styling in the last few paragraphs of the Components section
        Now, that we have a small project available to us - the 1, that we created with the CLI - we can see what this looks like in code
        Open your Angular project in the IDE and open the "app.component.ts" file. Lines 5 and 6 in this app component file contain the references to its associated template (the .html file),
        and its style file (.scss), respectively. The following is a screenshot of the open project in my IDE with the "app.component.ts" file open
    
        Property binding
(B)     There are 2 types of data binding we can do in Angular: 1-way and 2-way. Interpolation is very similar to 1-way data binding
(B)     This is because, in both cases, data flows from the component class to the component template and not the other way around. Property binding is data binding in the sense, that the data is being bound to a property
        It's also possible to have 2-way property binding - meaning, not only can the value of a component property be bound to the template, but the template can alter the value of a component property
        This is made possible in Angular by "ngModel". Again, don't worry about this for now. We will take a look at 2-way property binding later on. Just know, that both 1-way and 2-way property binding is possible in Angular
(B)     Implementing 1-way property binding is very straightforward. All u need to do, is to put square brackets around the HTML property (in the component's template) u want the data bound to and assign the variable to it
        To see a quick example of what 1-way property binding looks like in code, take a look at the next 3 screenshots: 
        - the 1st screenshot is of the component file (home.component.ts) - the variable "txtPlaceholder" is declared on line 11
                txtPlaceholder: string = "Enter your todo item here";
        - this next screenshot is of the component's template file (home.component.html) - in line 14, u can see the square brackets around the placeholder property of the input element
                <input type="text" class="regular" [placeholder]="txtPlaceholder">
        - this last screenshot is of the application running in the browser. You can see the text, Enter your todo item here, inserted as the placeholder text for the textbox via 1-way property binding:
    
        Event binding
(B)     In Angular, event binding simply means, that an event will be registered on an element within a component and when that event happens, it will trigger a function to be called. In other words, an event will call a function
        There are a ton of events, that u can have Angular listen for - such as a button being clicked / a mouse hovering over an image / when the user presses a key down /when the cursor is in a textbox / lots more
        And of course, u can write any function u can possibly think of to make other stuff happen, such as calling a web service, changing the color of the background page, 
        calculating the value of Pi to 1,000 decimal places / virtually anything else your heart desires
        But how can we set up event binding in our Angular application to tie the event we're interested in, on the element we're interested in, to run the function we want ? The Angular team made this super easy for us
        Suppose we'd like to have some user interaction via events, such as click / mouseover - we can use event binding to map the functionality
        Now, that example is not very interesting, but we do have our to-do list application to look at the code we've already written. If you've typed in the code listings
        
        OUR SAMPLE PROJECT
(B)     Learning a new programming language / a new framework, is a matter of handson experimentation and repetition. Even Dr. Sheldon Cooper from The Big Bang Theory can't learn Angular, just by reading a book on it
        However, just following along with random code examples isn't much fun to do and, at the end of the day, u don't really have anything u can use
        So, the approach we'll take on our journey to Angular mastery is to build a fully fledged web application, that is fun to build and practical, since u can deploy it and use it yourself
      
        Annotated photo album
        The application, that we'll be building together, is based on 1 of the online services I've launched called "Vizcaro" - a photo sharing service, but instead of sharing individual photos, u share albums (groups of photos)
        Also, the photos and albums will be annotated, so u can add titles and captions to them. Our version won't have all the bells and whistles, that my online service offers, 
        but it will have just enough parts to make it a great web application to build, in order to learn the material in this book
        
        Design principles
(B)     There are generally 2 types of design: the way, in which u design your user interface (the GUI) and the way, in which u design the software components (API interfaces, services, components and more)
        Throughout this book, we'll be covering quite a few design principles for the code. Angular is a spectacularly well-designed piece of software and this is great for us, 
        because it provides a perfect opportunity to discuss software design, as we learn Angular itself, in addition to when building our application
        We'll also be covering user interface design principles in general, as we build our application throughout the remainder of this book, but particularly, when we build out our templates using our wireframes to help guide us
        In general, the term UX design is used, when discussing user interface design. Borrowing a definition of UX design from Wikipedia:
            "UX design is the process of enhancing user satisfaction with a product, by improving the usability, accessibility and pleasure provided in the interaction with the product"
       
        Wireframes
        Wireframes have been around since the early '80s. Their focus, at least initially, was on what the screen in the desktop application did (remember, web applications were not around yet) and for its general layout
(B)     They were not meant to be used as what the final design was to look like - including font selection, colors and other properties of the controls on the screen. In essence, they were the prototype on paper
        Paper prototyping, conversely, is a process, that uses the wireframes. It's worth noting, that the nouns "wireframes" and "mockups" are used interchangeably - they are the same thing. I'll briefly cover the paper prototyping process at the end of this chapter
        
        Wireframing tools
        As u probably have already guessed / already know - there are several tools available for creating wireframes, when laying out your application, such as "Balsamiq Mockups" / "Mockflow" / "Visio"
        For my web applications and in this book, my preference is to use "Balsamiq Mockups". Which 1 u end up using for your applications / are already using - doesn't matter
        In fact, even if your wireframes are drawn by hand using a pen on the back of your napkin from your favorite fast food restaurant, it would be cool with me
(B)     Seriously, the important thing is that u get into the habit of creating wireframes, before writing a single line of code. Why ? Because it's a smart thing to do and it saves u a lot of time
        Additionally, it gives u the perfect opportunity to really think about what you're going to be building. And it's sth, that u can present to users, in order to get their feedback on the usability, without writing a single line of code
        There are even more benefits - it gives u some idea on how u would design your data model for the application, as well as APIs for services it may consume. Would u start a business without a business plan ?
        Would u build your dream home without a blueprint ? Building a web application shouldn't be any different specification out the pages using wireframes. Always. Capiche ?
        
        Wireframes for our annotated photo album
        There are 10 wireframes that we'll be using for building our application-one for each screen it will have. The following is the listing of them and a short description precedes each screenshot
    
        Home page
        Every web application needs a starting page of some kind. It's known by many names, typically 1 of these: home page / landing page / index page / splash page. Ours will be straightforward
(A)     No Flash animation / rainbow-colored backgrounds - it will be a simple page, that lets the user know, what the site does and hopefully it does that within 5-7sec. If it doesn't - u may lose the visitor forever
        
        Dashboard
        Most web applications don't have a dashboard page, but those that do, typically provide a summary of things the user has / the last time they had logged in / any notifications. that the company would like to bring to the user's attention
        If u use online banking, chances are that your bank's online banking web application has a dashboard page - and it probably is a list of accounts (checking, savings, credit cards, car loans and more) and the balances on those accounts, that u have with them
        We're going to build an application, that users will implement to create photo albums and so our dashboard will contain the number of photos we have uploaded / the number of photo albums / the last time we logged in / more

        Image upload
        Since our application is supposed to enable our users to create photo albums, we'd better have a way for them to upload their photos ! 
        Yes - we are dedicating an entire web page to upload 1 photo at a time, because we will use this same page to preview it after it has been uploaded - and to undo the upload
        You'd be surprised to know, that there is a wellknown photo sharing site, that does not show, what u have just uploaded, until u go to the listing of your photos !
        Having an immediate confirmation, that the photo u intended to upload is, in fact, the 1, that was uploaded
     
        Photo preparation
        Uploading a photo is the 1st step in our annotated photo album application. We are devoting another web page to preparation the photo
        This is where we will allow the user to resize the image and annotate it (give it a name and a caption). The photo's caption will be shown, when viewing it in the photo album
     
        Create Album
        Before the user can add photos in their photo albums, they have to be able to create the albums. This is what the following web page will be used for
        
        Photo listing
        You always need to think of usability and how to design the most intuitive user interface u possibly can. This page will show a listing of all the photos, that the user has uploaded
        Additionally, they can edit the name and caption for any of the photos right on this same page. The less jumping around from page to page, that your users need to do, the happier they'll be
       
        Photo album listing
        This page does for photo albums, what the previous page did for photos - provides a listing of all the albums the user created and has an intuitive way to edit their name and description (as opposed to the caption for photos) without going to another web page
     
        Workbench
        The workbench is the place, where the user will be able to drag a photo onto a photo album. This will be our way of allowing the user to intuitively associate a specific photo to a specific album
        By the way, not only will our drag and drop feature be intuitive and functional, it will add an element of fun for the user. Psychologically, users want to play on the site
        Dragging and dropping - though not a mind-blowing experience - is more fun to do, than it would be to select a photo from a photo dropdown, then select an album from an album dropdown and finally, click a connect / associate button
        The former method would please the user and the latter would make them send u a nastygram - then leave the site never to return
        
        Album viewer
        At the end of the day, the users want to see their photo albums in an engaging way. The drag and drop stuff was fun, but they're not here for that
        They're here to see photos from their son's birthday party / their daughter's high school graduation / pictures of their dream home
        This is an important page for them - it's where their work of using our site will pay off for them
    
        This concludes the introduction of our annotated photo album, that we'll be building throughout the remainder of the book, the wireframing and this chapter's planned material, that was to be covered
        I did, however, want to quickly discuss paper prototyping, as a closing to the chapter and to tie it back to the planning of our Angular application
        
        PAPER PROTOTYPING
        As mentioned near the beginning of this chapter, paper prototyping is a process. We had also mentioned, that the core focus of paper prototyping was on usability testing
        What we hadn't mentioned, was that paper prototyping should be a part of the software development methodology, that your development team uses - be it waterfall / some form of agile
        Specifically, paper prototyping should come immediately after the requirements documents are delivered to the project manager. That is the high-level view of what paper prototyping is and where it fits in
 
        Let's now take a look at the mechanics of the process at the lower level, meaning the interaction of the development team with the users of the application, that is to be developed
        The mechanics / process, in which paper prototyping is done, is to 1st create the wireframes and print them out (I know, more trees will be cut down and global warming becomes an even larger threat, but paper prototyping is important)
        Once the paper version is in front of u - your boss / your client / a group of intended users (such as a focus group) / u / whomever else - will use the paper prototype just like they would 
        by clicking their mouse onto the actual web application, as if it were already finished and in production. You would ask them to pretend, that it was the actual finished application
        It sounds silly at 1st, but human beings have an incredible imagination and with little effort, they will be using it, as they would the real thing ! This is not hypnosis here, but rather sth quite magical starts to happen
        Without your direction, except for at the very beginning, when u explain, what you're requesting of them and why, they will start to ramble on, talking out loud about the actions they are taking
        or are thinking of taking, such as - Ok, so now I need to fill this out and submit the form / Where is the button to undo what I just did. I made a mistake
        The best info you're going to get from people going through this exercise, is when they offer suggestions for how sth may be improved, such as - It'd be nice, if I can easily navigate back to where I... 
        Can u imagine coding web pages and then realizing the changes being asked to have a far-reaching effect and would be a timeconsuming change ? It happens a lot
        Do u realize, what u have by doing this ? You have test users and u haven't written a single line of code ! It is quite a powerful exercise ! Try it and email me your story
        So, when I explain this to a client - not to be the user, but how to present the paper prototyping process to their users and / or clients - I'm usually asked, But this is paper
        How do we change the screen ? I reply the best way I can - by showing them an example. I usually have a sample set of wireframes with me. Not only to demonstrate the paper prototyping process, but also to just show a good example of wireframes
(B)     I lay down the login screen on the table we're seated at and I ask them to log in using their finger as the mouse pointer and then typing on their imaginary keyboard
        After they chuckle and just play along with me by typing their username and password by fake typing on the table under the wireframe, they then hit the login button and I become the computer 
        I pick up the login wireframe and put down the dashboard wireframe. They usually stop chuckling, look at the dashboard page, take a few seconds and then look at me nodding and say, This is cool. I get it
     
        SUMMARY
        This chapter was packed with a wide array of topics, I know. It was inevitable, because there is no 1 best starting point for all the readers
        Np. some readers know, what wireframes are and have used them for years, while other readers may have only just heard of the term / maybe not even that
        This is the 3rd edition of this book, but it is quite a bit different from the 1st 2 editions and even, if it was largely the same, which it isn't, it doesn't mean, that readers have already gone through the 1st 2 editions
        You can think of this 1st chapter as a type of funnel - a wide enough funnel, that brings readers of all levels of experience and differing knowledge, into a common track for learning Angular and the other symbiotic technologies, that are covered in this book
        Starting with Chapter 2, the funnel approach is over. The rest of the chapters will be a lot more focused on the subject matter at hand. So, thank u for hanging in there with me
        Still, I hope, that there were a few things, that made wading through this 1st couple of dozen pages worthwhile, even if you're not completely new to Angular
        In review, we covered the evolution of Angular, including its semantic versioning and release schedule
        Although the installation of NodeJS / npm / CLI - are covered in Appendix A, this chapter is what guided that discussion and we then used the CLI to build our 1st Angular app and a "to-do list" app together
        We'll name the app to-do list because we're developers and not marketers (wink). We also covered how to use StackBlitz for building the same Angular application without having any reliance on our local development environment
        We covered the 1st very basic building blocks of Angular, that u need to know, since they will be used again and again for any Angular apps u build: templating / property binding / event binding / class binding
        Lastly, we introduced the annotated photo album application, that we'll be building together throughout this book and covered UX design principles / wireframing / paper prototyping along the way
        In the next chapter, we will 1st understand the relationship between JS and TS. We will do a crash course on TS and it's advantages over JS

    ■ CHAPTER 2: ECMASCRIPT AND TS CRASH COURSE

        Chapter 1 was a heterogeneous mix of topics, that may have seemed a little loosey-goosey, but it was presented that way to lay down a swath of material and topics
        related to frontend web application development - with an obvious inroad to Angular, for starting your adventure in becoming an Angular guru
        From this point onward, each chapter will remain as focused as possible and thus is dedicated to a specific area of coverage. As u progress through the chapters, u will generally find them to become more and more technical
        This is a natural progression and not to be feared, because, as u may recall, 1 of my promises made to you in Chapter 1, was to not get so deeply entwined in the technical details as to reach a point of diminishing returns
        In other words, no deep technical babble, that won't add any value to our purpose. Instead, we'll get as technical, as we need to get - no more and no less
        Additionally, the material will be presented in an engaging way, where u have the greatest chance for retention with the least amount of effort
        Regardless, please do not take this comment to mean, that u don't have to work at it. As with anything else in life, the better u want to become at sth, the more work it will take on your part
        We all reap what we sow. That being said, this chapter and the next 1 will be a gradual ramp up to the technical deep dives, that follow - kind of like the warm-up, before we start working our Angular technical muscles throughout the rest of the book
        This chapter will cover the following topics: the relationship between JS and TS
        
        THE (QUICK) ROADMAP 
        This chapter is a crash course on TS and is meant to serve as a way to fast-track the transition from JS to TS for developers, who are already comfortable with JS
        As was mentioned in Chapter 1, TS is the language we'll be using throughout this book, when working on Angular-specific things 
        and so this chapter serves as your preparation for the programmatic part of getting up to speed for web development with Angular
        You can think of Chapter 3, Bootstrap - Grid Layout and Components, as being this chapter's cousin, in that its goal is similar, but for the presentation side (that is, the layout of the web pages), as opposed to the programmatic side
        Together, Chapter 2 and Chapter 3 will round out the prerequisites for building client-side web applications in general-regardless of the client-side web application framework, but also specifically for Angular-based ones
        From Chapter 5, Flex-layout - Angular's Powerful Responsive Layout Engine, onward, it's going to all pretty much be Angular-centric
        
        THE RELATIONSHIP BETWEEN JS AND TS
        JS and TS are inextricably tied together. Thus, while this chapter covers 2 technologies: ECMAScript + TS, they are similar enough for this chapter to cover both simultaneously
        How similar are they to each other ? Well, for the most part, u can consider TS to be a superset of JS
(B)     The most useful description of their relationship: TS is a strictly typed language with lot of powerful features with optional typing and with its transpiler, it becomes plain JS
        This is important and brings several advantages for developers - it's compelling enough for Google's Angular team to switch from JS to TS for developing Angular itself
        We'll cover what a transpiler is, as well as what the advantages of using TS are, very shortly
        
        A series of fortunate events for JS
        Before we jump into the technical parts and the code, it would be worthwhile to take a quick look at the evolution of JS and some of the drivers, that led to the need for a language such as a TS
        Also, just as Angular's naming jungle caused some confusion in the development community, JS has had an even more confusing versioning past since its inception over 2 decades ago 
        and so I'd like to try and clear up some of the confusion around JS's version naming. More importantly, I'd like to cover what I like to refer to, as the series of fortunate events for JS
        This will help set the pace for much of the material we'll be covering together in the rest of the book. I must confess, I love working with JS
        I have always enjoyed the language - not for the language itself, but because it allowed us to make the web come alive without the need for other plugins, such as Flash / Shockwave
        However, in recent years, there are a few additional reasons for why I love working with the language and the exact reasons I love JS are precisely the series of fortunate events, that I will cover shortly
(A)     Having said that, I have friends in the industry, that are on the other end of the spectrum, who view JS as a toy language and prefer to remain shackled to languages, such as Java and C#, avoiding JS at all costs, 
(B)     until they have to grudgingly write some code for the client side. These old-timers' usage of JS typically extends no further, than binding a click event to a function call (using the jQuery library) to submit form data to their Java / C# APIs
        Sure, about a decade ago, JS wasn't as powerful as Java / C# for a few reasons, such as it was a language, that only ran on the client side (that is, on browsers),
        there were not as many libraries for it and highly performant runtimes for it did not really exist. All this was about to change, due the series of fortunate events - specifically, 3 of them. Let's review them quickly:
        
        1) Chromium project
(B)     The 1st 1 was Google's Chromium Project. In September of 2008, Google released Chrome V8, which was a high-performant JS engine. Google's Chrome V8 supercharged the way, in which JS code was able to be executed
        It was such a successful project, that it enabled other technologies to materialize, including the 1, that truly changed JS's future immediately and forever: Node.js (referred to simply as Node)
        
        2) JS frameworks
        The 2nd event in the series of fortunate events, that have cemented JS's reign, as the most important programming language for web applications and possibly for mobile and even desktop applications as well, has been the explosion of JS frameworks
(A)     Ever since about 2010, the development world has gone absolutely ballistic in its insatiable urge to create JS-based frameworks, not only for client-side web application development (Ember, Knockout, React), 
        but for server-side libraries (thanks again to Node), frameworks for creating native mobile applications (Ionic, React Native, Native Script) and frameworks for developing desktop applications as well (Meteor, Electron)
(B)     I haven't mentioned Angular in this paragraph, because we've already learned, that Angular can be used for building cross-platform applications for all 3 domains - browser, desktop, native mobile
        
        3) ECMAScript 2015
        The 3rd event in this series of fortunate events, was the release of ECMAScript 2015. ECMAScript is the official name for JS, when discussing its standard
        Despite the increase in major version releases, the JS language had largely gone on unchanged for many years
        This was due to differences between influencing players (who are best left), causing splintered development and stalled progress in evolving the language
        To summarize, this was a whirlwind tour of the current state of JS and some of its ecosystem. JS's ecosystem is so vast, that several books would need to be written to cover it. Np. we've not even made mention of visualization JS libraries
        There are hundreds, if not thousands, of libraries available for JS, that u can use for your projects, that we can't even hope to begin to cover
        However, there is a part of the JS ecosystem, that we will absolutely cover: unit testing. You probably know about the importance of unit testing and have likely written unit tests for server-side code 
        using frameworks such as: JUnit, NUnit, RSpec and others, depending on the programming language u used. However, unit testing is just as important on the client side and most developers don't do it, even though they may write unit test script for the server side
        In Chapter 13 Unit Testing, u will learn how to write unit tests for the client side and, specifically, how to write them to test your Angular application
        The 2 frameworks we'll cover together are: Jasmine (a popular unit testing framework) and Karma (a test runner, that has plugins for testing frameworks, such as Jasmine)
        
(A)     ECMAScript 5 is also known as ES5 and ECMAScript 2009       https://www.w3schools.com/js/js_es5.asp
(A)     ECMAScript 6 is also known as ES6 and ECMAScript 2015       https://www.w3schools.com/js/js_es6.asp     let, const, Arrow Functions, Classes, Map, Set

        TS CRASH COURSE
        TS has a number of advantages over JS for developers:
        Purely object-oriented     Optional static typing    Type inference    Access to ECMAScript features    Transpilation    Great tooling support with IntelliSense   You can build Angular applications !
        
        Transpilation vs. compilation
(A)     Developers can usually define what compilation is, within the context of programming: compilation is the process of transforming source code, by putting it through another program known as a compiler, into machine-readable code
        This resultant code is typically referred to as assembly code, which is a set of machine instructions native to the machine's CPU, which the code is meant to be run on
(A)     Transpilation, on the other hand, is the process of transforming source code written in 1 language into equivalent code in another (or target) language
        While this definition is good enough for discussion, for it to be fully accurate, we have to also note, that the source and target languages may, in fact, be different versions (or releases) of the same language
        For our transpilation needs, we'll be using TS's transpiler "tsc", which comes packaged with TS. The reason we care about transpilation, when building Angular applications, is because we will be writing our code in TS
        However, web browsers only have JS engines / interpreters and so we need a way to transpile it into JS
        
        Let
(B)     The "let" and "const" keywords were introduced in ES6. In order to discuss what these are and how they work, let's review what the "var" keyword does
        Prior to ES6, the way, in which u initialized a variable, was to use the "var" keyword. The 2 things to remember about "var":
            - when u use "var" to define a variable outside of a function body, it becomes globally scoped. This is to say, that all the other functions in your JS file have access to it
              While this may sometimes be convenient, it can also be dangerous, because the value may inadvertently be changed by a function other, than the 1, that u intended the variable to be used for
(B)           This is possible, when more than 1 function refers to the same variable name
            - when u use "var" to define a variable within a function, it becomes locally scoped. In contrast to globally scoped variables, locally scoped variables are only accessible within the function, in which they were created
              This is true regardless of block scope, because JS variables declared with the "var" keyword are scoped to the nearest parent function
(B)     You can, of course, still use "var" to declare and define your variables, since the keyword has not been deprecated. It's just that u now have more explicit control over the behavior of your initialization code 
        and the readability of the code has improved with "let" and "const", since the intentions are clear for when you're looking at JS code
        The "let" keyword creates block scope local variables and gets its name from other languages, that have a similar construct, such as Lisp, Clojure, Scala, F#
        In these languages, variables declared using "let" can be assigned, but not changed. However, in ES6, variables assigned using "let" can be changed - even so, regardless of whether they are changed / not, the variable is a local block scoped variable
        If u find this is a little confusing, you're not alone. Getting a firm understanding of the nuances in variable scoping is not sth, that u can learn by just reading
(B)     Programming is like learning math (or like learning most things, for that matter): the more u do it, the better u get
(B)     That being said, 1 way to boil it all down in your mind is to look at this 1 main difference between "var" and "let"                remember, that 1 main difference and you're golden
        since u can have more, than 1 block within a function and even nested blocks (or sub-blocks), variables defined with the "let" keyword are accessible only within the block they are defined, as well as from that block's nested blocks ("block scope")
        Rather, than being scoped to the function, they are scoped to the block
(A)     In contrast, the scope of variables defined with "var" is the entire closing function ("function scope") - nie mają "block scope"
            - var is function scope             function scope is within the function           function setWidth(){var width = 100; console.log(width);}               if (true) {var a = 5;}  console.log(a);   // 5
            - let and const are block scope     block scope is within curly brackets               if (true) {let a = 5;}       console.log(a);         // Error

        Let's look at some code to understand the impact of the "let" keyword and then we can move on to discussing the "const" keyword:
            let x = 5;
            if (x === 5) {let x = 10; console.log(x);}       // this line will output 10 to your console      note, x was allowed to be changed
            console.log(x);                                  // this line will output 5 to your console, because the change to x was made within a block
        
        Const
        The "const" keyword creates a constant. You'll be glad to know, that since you've gone through the pain of understanding what the "let" keyword does, understanding what the "const" keyword does, will be dead simple:
(B)     const and let are identical in the way, in which their scoping works. The only difference between "let" and "const" is that u cannot redeclare a constant and its value can't be changed
        
        Data typing
        Every programming language has data types. They only vary in the number of types available and the values (and range of values, for number types), that the typed variable can hold
(B)     I won't wade into the philosophical debate between "strongly" typed vs. "statically" typed vs. "loosely" typed languages (usually referred to as "static" vs. "dynamic" typing) in this book,
        but since this chapter is devoted to JS and TS, I do need to say a couple of quick things about their typing
(B)     JS is a "loosely" typed language - which is to say, it is a "dynamic" language, as opposed to it being a "static" language. What this means, is that variables in JS are not bound to
        any particular type, but rather their values are associated with a type. Variables can be assigned and re-assigned, to values of all available types
        While convenient, hard-to-find bugs can occur, since there is no compiler, that checks for adherence of value to a typed reference - and this is because, when u declare a variable using: var / let / const - u do not specify an associated type
        
(A)     In contrast, TS is "optionally statically" typed. The important word here is "optionally". TS is a "statically" typed language, yes, but it does not force u to explicitly annotate your variable with the intended type
        This is because TS has what is called "type inference", which is to say, that the TS runtime will infer (wywnioskuje) the variables data type at runtime
        This is the default behavior of TS. Now, this is where the "optional" part of it comes - if u want to strictly type the variable, 
        thereby binding the datatype to the variable, instead of it resting with the variable's value, u have to explicitly add a type annotation to the variable declaration
        
        Here it is in code:     var num: number = 12345;    // this is a statically typed variable
                                var num = 12345;            // this is a dynamically typed variable
(B)     Both the preceding lines are valid TS syntax, but here are their differences:
            - the 1st line, the statically typed variable, which is annotated with the "num" keyword, is checked by the TS transpiler and any issues will be reported by it
            - the 2nd line, where the variable declaration is made in the JS fashion (that is, no annotations for static typing), goes unchecked and any issues will only be found at runtime
        
        ES6 has 7 data types, 6 of which are known as "primitive" data types and 1 of which is a reference data type (which is just called "Object")
        JS also has several built-in data types in its standard library, but since this is not comprehensive coverage of JS, we'll only cover a few of them here: the ones, that you're likely to use in your Angular development
        
        The following is the list of the primitive data types provided:   Null   Undefined   Boolean   Number  String  Symbol
        The following are the built-in data types provided:               Dates     Arrays     Maps    Sets
        
        Objects
        Only having primitive data types and built-in complex data types is not enough, when writing expressive software, that attempts to model the real world / fictitious worlds (in gaming)
        The solution is to have programming languages with a construct for creating custom objects. Fortunately, JS and thus TS, is a programming language, that allows for the creation of custom objects
(B)     An object in JS is a collection of mapped keys and values, where a key can be either a string / a symbol. This is similar to the case for many other programming languages, such as for Python's dictionary and Ruby's hash
        Not to get too technical just for the sake of being technical, but JS is not a classical object-oriented language
        Rather, JS uses prototypal inheritance to create other objects, instead of creating an instance of an object from a class definition. In other words, JS doesn't have the notion of classes
(B)     JS has prototypes. Objects in JS inherit directly from other objects. In fact, when u create an empty object in JS using curly braces, it's really syntactic sugar for using the create method of the built-in object
(A)     There are several ways available to u for creating an empty object in JS. We won't cover them all here, but we'll cover 2 of the ways, that have been available in JS for many years and are made available to us in ES6:
            - using the Object constructor: var myObject = new Object();
            - using the curly brace syntax: var myObject = {};
            - using ES6 class syntax (we'll get to the syntax in the following Classes section) 
(B)     The 1st 2 methods create an empty object. If u want to create an empty object in JS with minimal fuss, the 2nd approach is obviously the easiest. However, the 3rd approach, ES6 class syntax, is what we'll be using in this book
        
        JSON
(A)     JSON, which is an acronym for JS Object Notation, is not a data type per se, but rather structured data. JSON is used as a lightweight data interchange format and is used by many programming languages
        Not only will we cover this more a little later, but we will make extensive use of this format to pass data back and forth between our Angular application and the backend web services, that we'll also be building for it
(B)     Just as programming languages have data types, data interchange formats often do as well. Here are the data types allowed to be represented in JSON:  String   Number   Object   Array   Boolean    Null
        You may have noticed, that there is a large overlap between JS and JSON data types. This is not by accident, because JSON is JS Object Notation and thus was modeled after JS's data types
        Here's an example of JSON data, that contains the names and ages of 3 people (each of which is a JS object):
            {"people": [{"name":"Peter", "age":40}, {"name":"Paul", "age":42}, {"name":"Mary", "age":38}]}
        In the previous JSON example, I have "people" as the key and its value is an array of 3 people objects. There's no hard and fast rule, that says, u have to name structures nested structures, but it does become more legible
        In this simple example, u could have instead omitted the key with no loss of data, as this next JSON sample shows:
            [{"name":"Peter", "age":40}, {"name":"Paul", "age":42}, {"name":"Mary", "age":38}]
        However, the 1st example, where we have the "people" key, is not only easier to read, but also easier to work with in the code
        When we write our RESTful web service APIs for our application in "Chapter 12 Integrating Backend Data Services", we will take the 1st approach, providing keys for our collections of data
(A)     Here's an interesting note for u about data interchange formats: while there are a few formats to choose from, such as XML and SOAP (Simple Object Access Protocol), when developing web services, JSON is the most popular 1 of all and it was inspired by JS
        
        JS runtime environment
        The rest of this chapter has many code snippets, so if u'd like to experiment with the material, as u work your way through the chapter, it's a good idea to fire up your JS runtime environment
        Unless you're using a JS IDE, such as WebStorm by JetBrains, u have a few options available to u for testing out JS code. Here are 3 of the many choices:
(B)     You can use an online JS console https://es6console.com/. You can use Node right in your Terminal (Appendix A shows u how to install Node)
(B)     You can use the console within your developer tools in your browser. Np. I primarily develop using Chrome and Google has excellent tools for developers
        Any of these choices will work just fine. I prefer using the Node Terminal for quick little things and it's what I used to test the code I wrote for this chapter
        
        1) Arrays
        Arrays are part of a collection of objects and are referred to as indexed collections. If you've written any amount of JS, u have used arrays
        Array objects can hold any valid JS data types and can grow and shrink, by calling their built-in methods, such as "push" and "splice"
        U can search for the existence of a value in the array with the "indexOf" method, get an array's length by using its "length" property and so on
            var myDreamCars = [];               the JS syntax for creating an empty array
            myDreamCars.push("Porsche");        u can use the array's built-in "push" method to add an item to the array
            var myDreamCars = ["Porsche", "Mercedes", "Ferrari", "Lamborghini"];        alternatively, u can create the array in place in 1 fell swoop
        The "indexOf" method is quite handy - when u need to find where in the array a specific item is / whether it exists in an array at all
            var indexOfMercedes = myDreamCars.indexOf("Mercedes");          np. we'd like to see, where in array the "Mercedes" is
        Given our "myDreamCars" array, the "indexOf" function would return 1. This is because arrays in JS start their index at 0 and the Mercedes was in the 2nd slot of our array
        What, if what we're looking for, is not in the array ? Let's see what happens when we look for a Corvette:
(B)         var indexOfMercedes = myDreamCars.indexOf("Corvette");          the "indexOf" function returns a "-1", which indicates, that the item we were searching for, was not found
        
        2) TypedArray
(B)     TypedArray is used in ES6 and even though it has a few of the same methods, as normal JS array objects, it is quite different from what you'd probably expect. In fact, TypedArray is not an array at all
        If u try passing in TypedArray to Array.isArray(), u will see, that the value returned is "false". OK, so what are they then? 
(B)     TypedArray gives us a view of an underlying binary data buffer and enables us to access and manipulate data. We won't be covering TypedArray in this book, because we won't be using them
(B)     and it is an advanced data type and mechanism, but the reason I mentioned it, is so that u are aware, that it exists
        Before we move on, let me at least cover the motivation for its creation and a use case for when u may wish to look into possibly using it
        TypedArray came into being with ES6, because web applications are getting more advanced all the time and the client machine now has so much power available to it, 
        that writing a client application, that processes and manipulates audio and video, is a good idea
        In order to do this, u need a mechanism to enable your JS code to be able to read + write data to these raw binary streams
(B)     2 examples of sth, that u may want to build, where TypedArray would be put to immediate good use, are:
            - video editing (where u wish to remove segments of unwanted footage) 
            - sampling audio (where u change the frequency of a sound byte, maybe creating 11 versions of the original sample to create a chromatic scale, so as to be able to play melodies from the original single sample)
        Once again, this is an example of how far JS has come
        
        3) Maps                                     http://kursjs.pl/kurs/es6/map-set.php                   Map i Set wprowadzone w ES6
        Maps is a data structure, that came to JS in ES6. Maps are used for mapping values to values. Moreover, they allow the use of arbitrary values as keys, meaning that u can use integers as keys or strings or even objects
        However, the use of symbols as keys is not allowed. There are also a few handy methods for performing operations on maps and u can also iterate over a map
        Let's take a look at code for creating a map and explore some of its common built-in functions
            var mapLangCurve = new Map();           let's 1st create our map - create 1 for mapping learning curves to programming languages, using the "new" keyword
        And now let's add a few entries to it using the Map's "set" function:
            mapLangCurve.set('Python', 'low');      mapLangCurve.set('Java', 'medium');      mapLangCurve.set('C++', 'high');
        While u can add key-value pairs in Map 1 line at a time, as we just did, the "set" method is chainable and so we can use this syntax to accomplish the exact same thing, which saves some typing:
            var mapLangCurve = new Map().set('Python', 'low').set('Java', 'medium').set('C++', 'high');
        Alternatively, as a 3rd way to declare and initialize our language learning curve Map, we can pass an array of 2 element arrays to the Map's constructor. Let's assume, we had our array of 2-element arrays set up like this:
            var arrLangCurve = [['Python', 'low'], ['Java', 'medium'], ['C++', 'high']];
        We can then pass that into the constructor like this:
            var mapLangCurve = new Map(arrLangCurve);
        These 3 methods of creating our Map all produce the exact same results
        Let's move on and quickly look at some of the common operations, that can be done on Map:
            var langCurveSize = mapLangCurve.size;                   we can get the Map's size using its "size" property
            var javaLearningCurve = mapLangCurve.get('Java');        we can retrieve a key's value using the "get" function
            var blnCurveExists = mapLangCurve.has('C++');            we can check for the existence of a key in Map using its "has" function
            mapLangCurve.delete('Python');                           we can delete a key and its value using the "delete" function
            mapLangCurve.clear();            we can clear out a set, removing all its items in 1 fell swoop, with the "clear" function. If you're following along in your JS environment, don't try this just yet, because we need some data to iterate through it
        You can iterate over Map very easily in JS using the "for" construct, but we need to know, what we would like to iterate over. Do we want to get our map's keys ? or its values ?
            for (let key of mapLangCurve.keys()) {console.log(key);}            or maybe we'd like to get both. Here is how we iterate over our map's keys
            for (let value of mapLangCurve.values()) {console.log(value);}      here is how we iterate over our map's values
            for (let item of mapLangCurve.entries()) {console.log(item[0], item[1]);}       here is how we iterate over both our Map's keys and its values
        Most of the time, u'll probably want to have access to your map's keys and values and so u should use the map's entries function
        A bit later in this chapter, we'll take a look at a construct, that ES6 gave us, called "destructuring", which gives us the ability to access keys and values directly
        
        Objects are similar to Maps in that both let you set keys to values, retrieve those values, delete keys and detect, whether sth is stored at a key
        Because of this, Objects have been used as Maps historically. However, there are important differences between Objects and Maps that make using a Map better
        Object and Map are based on the same concept — using key-value for storing data. However, they are indeed quite different from each other, mainly in:
            - key field: in Object, it follows the rule of normal dictionary. The keys MUST be simple types - either integer / string / symbols. Nothing more. But in Map it can be any data type (an object, an array, itd.)
            - element order: in Map, original order of elements (pairs) is preserved, while in Object, it isn't
        
        4) WeakMap                                              https://JS.info/weakmap-weakset
        WeakMap is a funny creature and is not inherited from Map, although they both are collections of key-value pairs and share some of the same functionality
        The most important difference between Map and WeakMap is the datatypes, that can be used as their keys. With map, we've seen, that u can use a variety of data types as its keys, including objects
        However, WeakMap can only have "objects" as its keys. This is by design and makes WeakMap particularly useful, if u only care to have access to the value of the key, if the key has not yet been garbage collected
        I know, it sounds like a strange use case, but if u consider, that WeakMap can help mitigate memory leaks in your JS programs, it may be enough for thinking of how u may be able to make use of WeakMap in your code
        The Weak part of the data structure's name comes from the fact, that WeakMap holds the references to its key objects weakly. This is to say, that they are candidates for being garbage collected
        This fact leads us to this next point. Since our keys may be garbage collected at any point without our involvement, it would not make sense to make them enumerable
        and so they are not and this means, that we cannot iterate over the collection. If u need to iterate over the list of keys / values in your collection => u should use the Map
        Conversely, if u don't need to iterate over Map and just intend to use it as a lookup table => u may want to consider using WeakMap
        
        5) Set                                              http://kursjs.pl/kurs/es6/map-set.php
        Set is a collection of unique values and can be iterated over, in the order, in which its elements were added to it. Set can contain homogeneous data, but each piece of data (that is, element) needs to be unique
        If u try to add an existing element to a set, there will be no effect on the set. Sets have many of the same functionality, that maps have. Let's create a Set object and zip through a few of its commonly used functions
            var setCelestialObjects = new Set();            to create a set, we call its constructor using the "new" keyword
            setCelestialObjects.add('Earth');               let's add a few elements (that is, celestial objects) to our Set
            setCelestialObjects.add('Moon');                setCelestialObjects.add('Solar System');       setCelestialObjects.add('Milky Way');         setCelestialObjects.add('Andromeda');
            setCelestialObjects.add(['Aries', 'Cassiopeia', 'Orion']);                                     setCelestialObjects.add(7);
        The number 7 isn't exactly a celestial object, but I want to show u, that u can add different types of elements to the same Set. The same thing with our array of constellations: we can add arrays and any type of object to our Set
            var sizeCelestialObjects = setCelestialObjects.size;            we can get the size of our Set using the "size" property
            setCelestialObjects.clear();                                    don't do this now, but u can clear out Set using its clear function
            setCelestialObjects.delete('Andromeda');                        we can delete an element from our Set by passing its value into set's "delete" function
            for (let element of setCelestialObjects) {console.log(element);}        u can iterate over Set using the "for" construct, as we used for our Map
        If u'd like to perform an operation on every element in your Set, u can use set's "forEach" function, which takes a callback as its parameter
            var setIntegers = new Set();    setIntegers.add(1);    setIntegers.add(7);    setIntegers.add(11);              np. if u had a set of integers in your Set and wanted to square all of them
            setIntegers.forEach(function(value) {console.log(Math.pow(value, 2));});
        The preceding code does not change the elements within our Set, while it prints the squared values to our console. We can't easily change our elements in place, but we can create a new Set and store our squared elements in there:
            var setSquaredIntegers = new Set();
            setIntegers.forEach(function(value) {setSquaredIntegers.add(Math.pow(value, 2));});
            var blnElementExists = setCelestialObjects.has('Moon');                 we can check for the existence of an element in our Set using the "has" function
        If u recall from when we covered maps, the Map object had the following 3 functions: keys / values / entries. Sets have these same 3 functions as well, but their resulting value is quite different
        When u call these built-in functions on your Set, u will get a "SetIterator" object back.
        We won't be using "SetIterator" in this book, but as with when I gave u a use case for TypedArray, I'd like to give you a use case for "SetIterator"
        A Map object and a Set object are different data structures and u iterate through each of these structures in different ways
        If u use iterators, u can build a function, that can iterate through these 2 types of data structures in the same way. In other words, u can pass the objects into your function, that iterates over the collections without worrying about their type
        
        6) WeakSet
        WeakSet is a collect of weakly held objects, where each 1 must be unique. Duplicate objects are not allowed to be added. Recall from our discussion on WeakMap, 
        that its keys may be garbage collected from under our feet, since their keys can only be objects. Thus, as it was with WeakMap, so it is with WeakSet with respect to iteration: we can't iterate over the collection
        WeakSet has a very small amount of built-in functions, namely: add / delete / has. WeakSet also has a "length" property, similar to arrays, as opposed to the "size" property for Map
            var myWeakSet = new WeakSet();          we can create an empty WeakSet object using its constructor
        Let's create 3 empty objects to add to our WeakSet and then add them to it using the WeakSet object's "add" function and then get the number of objects it contains using its "length" property:
            var objA = {};       var objB = {};      var objC = {};            myWeakSet.add(objA);      myWeakSet.add(objB);        myWeakSet.add(objC);
            var lengthMyWeakSet = myWeakSet.length;     // lengthMyWeakSet will be set to 3
(B)     You may be asking, wait a minute. You said, that the objects must all be unique and any duplicates will not be inserted into the WeakSet object. All the objects are empty - are they not the same ? 
        True, duplicate objects will be rejected, when the insertion operation is tried. However, while our 3 objects all have the same value (that is, they are all empty), they are in fact 3 separate and distinct objects
(B)     In JS, as with most other object-oriented languages, it is the object reference (that is, the underlying memory address) and not its contents, that determine, whether the object is the same, as another object / not
            var blnSameObject = Object.is(objA, objB);          here is how u can compare 2 object variables referencing the same object       
        objA and objB each reference empty objects, but these are 2 different objects !!        thus, blnSameObject will be set to false
        If we did the following since the objB and objC variables point to the same object in memory, the line, that tries to add objC to myWeakSet, will have no effect on myWeakSet, because the underlying object was already contained in the WeakSet object:
            var objA = {};      var objB = {};         var objC = objB;     // objB and objC now both point to the same object in memory
            myWeakSet.add(objA);        myWeakSet.add(objB);        myWeakSet.add(objC);            var lengthMyWeakSet = myWeakSet.length;     // lengthMyWeakSet will be set to 2
        
        7) Classes
        Several pages ago, we covered 3 different ways to create an object in JS. I had also mentioned, that we were going to cover how to create an object using the ES6 "class" syntax later on
        Additionally, I had mentioned, that JS doesn't have the notion of classes, yet we're covering classes in this section. Let's clear all this up and take a look at how to create classes in JS and how to create objects from these classes
(B)     For JS releases prior to ES6, the notion of "classes" did not exist. Rather, whenever u created an object, under the hood, the JS runtime would inherit directly from other objects and not from classes 
        (remember, that JS is not a classical object-oriented language - it uses prototypal inheritance). This doesn't make JS bad, but it does make it different
        In order to bring the same style and semantics from classical object orientation, ES6 brought us the notion of "classes"
        A class is a blueprint for objects and when we create an object from this blueprint / template - it is referred to as "instantiation". We use a class to instantiate (to bring into existence) - 1 / more objects from it
        Let's create a "Car" class and give it a constructor + 3 properties + 3 methods:
            class Car {constructor(make, model) {this.make = make; this.model = model; this.speed = 0;}
                       get speed() {return this._speed;}          set speed(value) {this._speed = value;}     speedUp() {this.speed += 10;}     slowDown() {this.speed -= 10;}}
        I've purposely used the term "methods" here, whereas previously I had always referred to them as "functions". Since we're now discussing classes and objects, in the classical object-orientation parlance, method is of better choice a word, than function
        
        2 relationships, that u need to remember for any object-oriented language:      - objects are instances of their classes        - objects encapsulate data and methods, that manipulate that data
        The data represents the state of the object at any moment in time and the methods represent the behaviors the object has - that's pretty much it
        
        OK, back to our class example. Our Car class has a constructor, that takes 2 parameters: the car's make and model. It also has 3 instance variables: make / model / speed
        Additionally, it has 2 methods: speedUp / slowDown. Lastly, the speed instance variable is actually a property - this is because it has an associated getter / setter
(B)     Sth to pay attention to, is that the setter / getter in our class have an underscore in front of the property name, while the associated instance variable does not
        This is important, because without the underscores, the JS runtime would throw an exception (RangeError: Maximum call stack size exceeded), when instantiating your Car object
        Great ! So, how do we create our instance of it (that is, a Car object) and how can we call its methods and read its property ? Here's the code to help answer these questions
            var myG6 = new Car('Pontiac', 'G6');                we create our Car object, just like any other object, by calling its constructor
            myG6.speed;                 let's read our car's current speed - this returns 0, which is the value it was initialized to
            myG6.speedUp();     // this increases our speed by 10 mph                       myG6.speedUp();     // this increases our speed by another 10 mph
            myG6.speedUp();     // this increases our speed yet again, by 10 mph            myG6.speedUp();     // this increases our speed, 1 last time, by ... u guessed it, 10 mph
            myG6.speed;         // this now returns 40       how fast are we going ? We'd better check
            myG6.slowDown();    // this decreases our speed by 10 mph                       myG6.slowDown();    // this decreases our speed by another 10 mph
            myG6.speed;         // this now returns 20              let's check our speed again
        To wrap up this section, here are a couple of things to keep in mind about classes in JS:
            - unlike Java / Python, classes in JS can only have 1 constructor. Overloading constructors is not supported
            - u can have a super call in your class (used in calling the constructor of a class higher up in the hierarchy), but it must be called prior to using the "this" reference, as in when we assign the make and model parameters to their respective instance variables

        8) Interfaces
        So far, we have been looking at several new additions to JS, that have been made available to us. This section on interfaces, for our purposes, is a TS-specific thing, since JS does not have the notion of interfaces
        Interfaces are like a contract for a class and provide a set of rules, that the class must follow. Let's switch gears from building a "Car" class to building an "Animal" class and while we're at it, let's have our class implement an interface we'll call "Species":
            class Animal implements Species {}
            interface Species {name: string; isExtinct: boolean;}
        Our Animal class is empty. It doesn't even have a constructor / any instance variables and that is not a problem for us, since it still serves our purposes to demonstrate how to use interfaces
        Take a look at the "Species" interface for a moment:
            - it has 2 public properties. TS has access modifiers, just like Java / C# have and we'll get to those, when we make use of them in later chapters
              For now, all u need to know is, that the lack of an access modifier on the properties makes the properties public. This is important, because since an interface describes the public interface of the class, that implements it, its properties must be public
            - the 2nd thing, that you'll notice is, that we're typing the properties. We're declaring the "name" property as being of type string and the "isExtinct" property as being of type boolean
(A)           This is 1 major advantage of TS, as we've previously learned and is where TS got its name (that is, a typed JS)
(B)     We'll see access modifiers in action later in the book. There are 3 of them:
            - public: this is the default modifier and it means, that the property / function is visible to all other code
            - private: the visibility to a class's properties and functions marked as private are only available to member functions of the class, that they're declared in
            - protected: this is the same as private, but the class members are also visible to any classes, that are inherited from the class, that they're declared in
        The way, in which we marry the class to the interface, is by using the "implements" keyword in the class definition, as we have done so in this example. Once we do that, the class must adhere to the interface contract
(B)     So now what ? If the "Animal" class doesn't implement the 2 properties, that the Species interface says it must, then TS will throw an error during transpilation
        We can also have an interface describe an optional contract and we can do this by appending a question mark to the end of the property / function. We don't have a function listed in our interface, but we can absolutely have functions as well
            interface Species {name?: string; isExtinct?: boolean;}             if our interface was an optional contract, it would look like this
        
        9) Inheritance
        We mentioned, that class members marked with the "protected" access modifier are also visible to any classes, that are inherited from the class, that they're declared in and so we'd better discuss inheritance real quick
        A class can inherit from another class. In order for a class to do that, we use the "extends" keyword in the class definition. Let's switch gears once more, this time going from Animal to Employee:
            class Employee {constructor(name) {this.name = name; this.title = "an employee";} annouceThyself() {return "Hi. My name is ${this.name} and I am ${this.title}.";}}
            class Manager extends Employee {constructor(name) {super(name); this.title = "a manager";}}
        Let's create an Employee object and have the employee announce himself:
            var emp = new Employee("Goofy");       console.log(emp.annouceThyself());        // Hi. My name is Goofy and I am an employee
        Let's create a Manager object and have the manager announce himself:
            var mgr = new Manager("Mickey");       console.log(mgr.annouceThyself());        // Hi. My name is Mickey and I am a manager
        Here's what's going on:
            1. We created an "Employee" class            2. We created a "Manager" class, that inherits from Employee
            3. The "Manager" class does not have any properties / functions, other than it's constructor. However, it inherits the properties (name and title) and the method (annouceThyself), from the Employee class
            4. The constructor in the Manager class calls the constructor in the Employee class, passing in the manager's name         5. The manager's constructor reassigns the value for the "title" property
        This was fairly straightforward, but there are 2 takeaways to remember:
            - the inheriting class gets all the class members from the class, that it inherits from 
            - 1 constructor can call it's parent's constructor and this can continue up the chain, if the parent had a parent and so on
        
        10) Destructuring
        Destructuring is a super cool and useful construct, that we will use many times throughout this book and it'll be sth, that u won't be able to live without in your Angular projects, after you finish this book
        In short, destructuring is a JS expression, that enables us to easily extract data from objects and collections. Assume we have the following object:
            const author = {1stName: 'Aki', lastName: 'Iskandar', topics: ['Angular', 'JS', 'TS', 'Bootstrap', 'Node'], cities: ['Calgary', 'Cleveland'], publisher: 'Packt'}
        If we wanted to extract 1stName, lastName and publisher, we know exactly how to do that the old-fashioned way (that is, before ES6):
            const 1stName = author.1stName;          const lastName = author.lastName;        const publisher = author.publisher;
            const {1stName, lastName, publisher} = author;     Destructuring (despite it's odd-looking syntax) saves us a lot of keystrokes, by giving us the exact same result (new variables with the extracted data)
            console.log(publisher);                  // Packt         we can easily see, that it did its job, by writing a variable out to the console
        
        11) Template strings
        Template strings are strings, that are enclosed within backticks (that is "`"). Note: the backtick character is typically found on the same key on your keyboard, as the tilde (that is ~) and is immediately to the left of the number 1 key
        JS always gave us the ability to create strings using double quotes, as well as by using single quotes, so what was the motivation for the 3rd type of string creation character ? 
        Well, as it turns out, given the proliferation of frontend frameworks, there was a common need to do 3 things:        String interpolation        Multiline strings        Tagged templates
        
        12) "for-of" loop
        JS brought us the "forEach" construct for looping through collections. It is a great built-in method to use, but u can't break out of this loop
        We also have the "for-in" loop, which is great for objects with keys, that are strings, but it has some drawbacks, when iterating through arrays
(B)     Enter the new "for-of" loop. It works well for objects, arrays and maps and u can break out of it. Here is the syntax, which is identical to that for the for-in loop, other than changing "in" to "of":
            let myArray = [5, 10, 15, 20, 25];      for (var item of myArray) {console.log(item);}
        
        13) Decorators
        Decorators are also a TS thing. Decorators in TS decorate functions and classes, just as they do in some other languages, such as Python / Java
        We won't spend too much time here, because we won't be writing our own decorators for the application we're going to build together, but since Angular makes use of decorators quite a bit, 
        I wanted to at least give u an idea of what they are used for. We'll also look at a quick example of how to create 1 and how to use it, but we'll fly through it quickly
        Decorators are a way to add functionality to a function / a class (typically a class), by annotating the class with the decorator. The decorator is just a function, although it has some strange looking syntax at 1st glance:
            function iq(target) {Object.defineProperty(target.prototype, 'iq', {value: () => "Genius"})}
            @iq
            class Person {}
            let readerOfMyBook = new Person();
            console.log(readerOfMyBook.iq());       // prints out "Genius" to the console
        This is intermediate to advanced level TS and an entire chapter can be written on decorators. We don't have the luxury to cover them in detail here, 
        but the takeaway is that they are simply functions, that add functionality to functions / classes and to do that, u only need to annotate the function / class with the name of the decorator (that is, @NameOfDecorator)
  
        14) Promises
        We will cover promises in greater detail, when we make use of them in Chapter 12, Integrating Backend Data Services and so I'll defer the code until that time
        The reason is, that showing a really good real-world example of a promise, so that it's not contrived, takes quite a bit of code, since there needs to be asynchronous code, that is called
        So, I promise to have real-world promises later on in the book. However, we can at least look at a definition, so that u know what they are
(B)     When u call a function, that may take a long time to return a result / to complete its task and u don't want to delay the execution of your program, u can call that function asynchronously
        This means, that your code will continue on to the next line, after it calls the function on the previous line asynchronously
(B)     If u don't call it asynchronously, your program's execution will stop and wait for the function u last called to return from what it was doing, such as reading a bunch of records from a database
        There are a few different ways to call a function asynchronously. The most common way to call a function asynchronously, is to use callbacks
        A "callback" is a function, that u pass to the function, that u call asynchronously, so it can then call that function, when it has completed its work
(B)     That's how callbacks got their name - the function u called, calls u back, when it's done
(B)     Promises are another mechanism we can use to program asynchronously. Although Promises made things a little more manageable, writing good asynchronous code in JS, is often still notoriously difficult
        Because of this fact, people started writing JS libraries to try and make asynchronous code easier to write. There are several out there. 1 library, that saved my sanity, is called "Async"
(B)     All this being said, I still have not given u a definition of Promises, so here it is: a Promise is a proxy for a value, that is not yet known - it's like a placeholder for the value, 
        that will eventually come back from a function, that was called asynchronously. This construct allows asynchronous functions to immediately return a value, as if it was a synchronous method
(B)     The initial value, that is returned, is a Promise and the Promise will eventually be replaced by the value, that comes back from the called function, once it has completed its work
        I know, this may be a lot to get your head around, but when we write our code in Chapter 12, Integrating Backend Data Services, u will understand Promises
        
        15) Modules                                                                 Prior to ES6, JS did not have the notion of modules
        Modules are simple code files, that can be loaded into the other code, so that the functions within the module that is being loaded, are made available to the code, that is importing the module
        Modules can load modules. Modules lead to modular code and that is a good thing. Rather, than write a monolithic bunch of code in 1 file, u can split it up into logical units and have that code live in more, than 1 file
        This leads to code reuse, namespacing, maintainability. While JS didn't have modules, we were still able to accomplish the same thing, to a degree
        We can load script files with script tags, before calling their functions in our web pages
        However, what about JS running on the server side / another environment outside of web pages ? Without modules, writing non-monolithic applications becomes difficult
        "alphafunctions.js":
            function alpha1() {console.log("Alpha 1 was called");}
            function alpha2() {console.log("Alpha 2 was called");}
(B)         export {alpha1, alpha2};                                   The "export" keyword is used to mark, which functions can be exported and thus imported into other modules
        "main.js":
(A)         import {alpha1, alpha2} from ./alphafunctions;
            alpha1();       // "Alpha 1 was called" is written to the console
        
        16) Default exports
        Let's assume, that we always want to import our alpha1 function into other modules / at least more often, than not. We can add the keyword's "export default", before the keyword "function"
        So when we import it, we no longer need the curly braces around the function name:
        alphafunctions.js:
            export default function alpha1() {console.log("Alpha 1 was called");}
            function alpha2() {console.log("Alpha 2 was called");}
            export {alpha1, alpha2};
        main.js:
            import alpha1, {alpha2} from ./alphafunctions;
        While this isn't an earth-shattering difference, the terms "default exports" do come up in conversation and in code snippets on blog posts and so on, so I wanted to make sure we at least took a quick look 
        so that u understood, why the curly braces were sometimes there and other times not. When u use JS libraries, u'll see this in the documentation and code examples as well
        
        SUMMARY
        In this chapter, we have covered some of the history around JS and specifically the series of fortunate events around JS's ecosystem, that have cemented the language,
        as the most important programming language in recent history. We can now not only write client-side code for execution in the browser, but we can write JS code, that runs on the server
        As if this wasn't a compelling enough reason to use more JS, than what u may have used in the past, u can also use JS for native mobile development and for creating desktop applications as well
(B)     It's quite an exciting story ! We then took a low fly-by look at the additions to JS, that were added with the release of ES6
(B)     These additions were quite substantial, especially since JS had remained largely unchanged for over a decade and have really strengthened the language as a result
(B)     We also enumerated some of the benefits, that TS brings to the table. Remember, that u can view TS as being a superset of JS and u can define it as "ES6 plus" optional typing
        Microsoft's contribution of TS to JS developers was 1 of the most important things, the company has contributed to the open source world in a long time
(B)     Angular itself was written in TS, due to the advantages TS has over pure JS and so when building Angular applications, it's best to use TS to write them
(B)     We've remembered, that JS is the only language, that can be executed in the browser, but fortunately, TS ships with a transpiler to turn our TS code into pure JS code
        As mentioned in the roadmap "Chapter 3 Bootstrap - Responsive Grid Layout and Components", we have a similar goal
        We will do a crash course on SASS, which is what we'll be using to style our Angular components, instead of using CSS
        We'll also cover enough of Bootstrap to get u comfortable with using the venerable CSS framework to lay out our web pages for ListingCarousel, the web application we'll be building together
        You'll gain enough knowledge to immediately apply these skills to virtually any web application project u may currently have / soon be starting on in the future

    ■ CHAPTER 3: BOOTSTRAP - GRID LAYOUT AND COMPONENTS

        This is a big and important chapter. However, it's not going to be all work and no play, because this chapter is where we're going to start building our example application together and we should be able to have some fun with it
        Along the way, we'll also be covering quite a bit of material in various areas. Here's the list of things, that we're going to cover:
            - We're going to formally introduce our example application "Listing Carousel" and this includes some suggestions for how u may leverage this application into sth else, that u may prefer doing - 
              either alongside this book (instead of building Listing Carousel) or after finishing the book, if u'll 1st be building Listing Carousel along with me
            - We're going to cover our game plan for how we're going to incrementally build our application throughout the book and u will also see, 
              that we have a few alternative technologies to choose from for building Listing Carousel - or for an application of your choice, that u may be inspired to build, by the end of the book
            - We're also going to take a look at Sass, which is a technology for making writing your CSS for your projects a little easier and even more organized
            - We'll definitely be looking at Bootstrap - at both of its major parts: its responsive grid and a few of its components
            - In Chapter 1, Quick Start, we took a sneak peek at some of the wireframes, that will make up our example application. Well, this chapter is where we're going to write the HTML code, leveraging Bootstrap, to bring the wireframes to life
            - As bonus material, we'll also be looking at the process, in which software projects go from inception to realization, using a real-life case study, Listing Carousel
              This includes project phases, such as: analysis, requirement gathering, use cases diagrams, wireframing, implementation
        By the end of this chapter, our web pages will be hardcoded and won't have any Angular code in them whatsoever. As we progress through the book, we will start to slowly bring them to life 
        by gradually converting our Bootstrap application into a fully fledged Angular application, by adding routing, Angular components, templates, data and more
        
        A WORD ABOUT WHAT THIS CHAPTER IS NOT
        This chapter covers a lot of ground, including Sass and Bootstrap's responsive grid and several of its components. However, this chapter is not comprehensive coverage of all u need to know about either of these things
        The reasoning for this is simple - not only are there books devoted to Bootstrap, but Bootstraps's website is the ideal place for where to look up documentation on Bootstrap
        Duplicating their documentation would not have been a good use of this book's pages, nor would it have been a good use of your time and hard-earned money
        Instead, the smarter thing to do, is to introduce Bootstrap's grid and components in a practical way - such as by building an application together in this book - and to just refer u to the official documentation, as needed
        By the way, the same thing applies to "Chapter 5 Flex-Layout - Angular's Responsive Layout Engine", "Chapter 8 Working with NG Bootstrap" and "Chapter 9 Working with Angular Material", because each of these technologies has their own official documentation
        My job is to do the following:       - introduce these technologies to u (and point u to their official documentation)        
                                             - demonstrate, how they can be applied in a practical, interesting and engaging way
                                             - encourage u to work through the entire book, so u can be well on your way to becoming an Angular web development guru
(B)     By the way, Angular, of course, also has its own official documentation, but there's so much to it, that it can be intimidating to even get started
        In my experience, a far more interesting way to learn a new technology is by following a tutorial - and that is exactly what this book is - a comprehensive tutorial for building an application, 
        with the added explanations and some bonus material sprinkled in throughout the chapters in the appropriate sections. If I did my job well, u should be able to build almost any application u are likely to need (or want) to build with Angular
        Let's now take a look at Listing Carousel, which is the example application we'll be building together
        
        OUR EXAMPLE APPLICATION
        Listing Carousel, our example application for this book, is a real-life online application, that provides realtors (that is, professional real-estate salespeople) 
        with an opportunity to share their listings to their contacts on social media in an engaging and informative way. 1 of my companies owns and operates it
        The reason I chose this application, is not so u can steal my code and try to compete with me (which would be totally uncool and not recommended), but rather because with some tweaks here and there, 
        u can turn the application into your very own online service, if u wanted to. Np. u can easily turn this application into a classified application (such as Craigslist, or Kijiji) 
        by just adding search capability or even into a dating / matchmaking site, by adding search and just a bit more code. Or, if u love food, how about turning it into a restaurant site ? 
        Sign up restaurants to list their menus in the carousel - 1 meal / appetizer per slide - and then the restaurant owners can share their menus with their social media circles
        Or, if u like having new ways to share photo albums, u can turn the application into sth like that. 1 idea I had a while ago, was to create a site, where people can showcase their portfolios 
        (such as for artists, architects and photographers) - feel free to build sth like that and run with it. The options are truly endless. The point is, I wanted to come up with a fun application for the book,
        that would give u some motivation to work through the entire book. Why ? Simple - because I know, that this book would not be as valuable, as it can be to u, if all u were to do, is to read it
        So, commit to dive into the code with me and build sth, that u would enjoy. Who knows, maybe u will come up with a great idea for a profitable online business ! 
        My goal is to make the time u invest in working through this book, as time well spent and, if I succeed, u can then give this book a 5-star review (wink). Does this sound good ?
     
        Game plan
        There's a step-by-step game plan for using Listing Carousel, as our focal point for our discussions, as we cover the material in this book together
        Though this book was not explicitly broken up into parts (that is, groupings of chapters), we can loosely group them now by partitioning the work we need to do for building our application into 3 main stages
        Follow along with me and this will all make sense - giving us a way to marry the material (that is, the book's chapters) to the application we'll be building together, as well as to give ourselves a target for what we're shooting for
        It's nice to know, where you're going, before u start driving and to be able to recognize, where u are at all times. Having a roadmap / game plan like that, makes the entire process more enjoyable, 
        thereby maximizing the chances, that u'll work through the book, instead of just using it to look things up here and there. This book wasn't designed to be like a cookbook
        Instead, it was designed to teach u how to cook. You will learn to cook by fire (pun intended), by preparing a meal of the right complexity - which demands a certain level of knowledge and skill to cook it properly
        There are 4 main benefits of this book:     - it gives u all the ingredients and even substitutes ingredients (that is, choices), that u need to prepare the meal
                                                    - it gives u the knowledge and teaches u the process and skills required of the chef in order to cook the meal
                                                    - it does these things in a methodological way, so u learn it effectively and as efficiently as possible
                                                    - the meal selection is a dish representative of the complexity of the majority of dishes you're likely to need to cook up
                                                      In other words, if u learn how to cook this meal (that is our example application), u should be confident in being able to prepare any meal, that u will be asked to prepare
        Cooking analogies aside, this book's promise is to teach u how to build a practical application using Angular through a methodological process
        After all, if u think about it, that's why u bought this book - isn't it ? Otherwise, u could have just tried to Google things here and there, hoping to be able to eventually piece everything together
        That's not fun, nor is it an intelligent way to go about learning Angular. When u want to learn sth new / take rudimentary skills to the next level - in anything, not just Angular 
        - u need to have a target in mind and a roadmap / game plan to get there. Well, we know our target, which is to build Listing Carousel, learning Angular and a bunch of other goodies, along the way. So let's now take a look at our game plan
     
        In phase 1 of building our application, we need to decide what to build, what features it will have and what it will look like. Once we have that all scoped out and wireframed, 
        the next step is to build out the skeleton for our application. By the end of this stage, our application is likely to just be hardcoded - being nth more, than some HTML and CSS
        Our only components will be the ones we select to use from Bootstrap's library of components. You can think of this, as our application having skin and bones, but not yet having guts / a beating heart
        In phase 2 of building our application, well, you guessed it, we're going to start giving our skin and bones application some guts ! Specifically, it will be Angular guts ! 
        Remember, in the 1st phase, we're not even using Angular at all - not a single ounce of it - which is intentional
        Though our application will surely be more lively by the end of this 2nd phase, than what it will be in its 1st phase, it'll behave more like a robot - very mechanical
        If u remember the movie, The Wizard of Oz, it will be like the Tin Man - very much alive, but with no heart
        This 2nd phase (that is, giving our application some guts) will be comprised of "Chapter 4 Routing", "Chapter 7 Templates, Directives and Pipes" and "Chapter 6 Building Angular Components"
        Last, but not least, in phase 3 of building our application, we'll finally be giving our Tin Man a heart ! Yeah ! OK - what gives our application a heart ? The answer is data and APIs !
        The data is like blood for our application and the APIs are like the heart - taking data in and pushing data back out. I bet, u never thought of web applications in this way, and
        from now on, u won't be able to think of them in any other way (smiling). This 3rd phase will comprise "Chapter 10, Working with Forms", "Chapter 12, Integrating Backend Data, Services", 
        "Chapter 11, Dependency Injection and Services" and "Chapter 14, Advanced Angular Topics"
        "Chapter 13 Unit Testing" and "Chapter 15 Deploying Angular Applications" are not really parts of any of the phases per se, but they play a very important supporting role
        In these 2 chapters, we will learn how to test the code we write for our application and how to deploy it in a couple of different ways
    
        That's our big picture look at our game plan. Let's zoom in a little and take a look at our 5-step game plan for our 1st phase of building our application and we'll then be on our way to our 1st technology topic, SASS
    
            Step 1: In this chapter, we're going to look at Bootstrap's responsive grid, as well as several of Bootstrap's components:
                    - I'll be explaining how Bootstrap's grid works and can help us lay out our web pages
                    - I'll cover the Bootstrap components, that we'll be using on our pages, as we build out the pages - and we'll be using our wireframes to guide us, in conjunction with Bootstrap's grid
            Step 2: In "Chapter 5 Flex-Layout - Angular's Powerful Responsive Layout Engine", we're going to replace Bootstrap's grid system with Flex-layout
                    We'll only be doing this with a couple of web pages, leaving all the others with the Bootstrap grid. There are 2 reasons why we'll be doing this:
                    - to show u, that there are always alternate options available - and u can often mix and match these alternatives
                    - being able to mix and match provides us with a path to replace 1 technology with another, without the need to do it all in 1 shot
                      We don't want to keep rebuilding things in their entirety - we just want to redo enough of a couple of pieces of what we built originally, in order to learn how to apply that specific alternate technology
            Step 3: In "Chapter 6 Building Angular Components", we'll be looking at how we can build our own components for use in our web pages
                    Since we are in control of the HTML and CSS, when creating our components, we can leverage Bootstrap's components for the look and feel, when creating our own Angular components
                    Note: "Chapter 7 Templates, Directives and Pipes" is a part of this as well, since these 2 chapters go together
            Step 4: In "Chapter 8 Working with NG Bootstrap", we will discover, that there are ready-made Angular-ready Bootstrap components
                    Just as we will replace Bootstrap's grid with Flex-layout for a couple of our pages, we will do the same thing with components - that is, to replace a couple of Bootstrap components with components from the NG Bootstrap project
                    Our motivation for doing this is to realize, that there are many different 3rd-party components, that we can readily use for our Angular applications - including ones, that are based on Bootstrap's components
            Step 5: In "Chapter 9 Working with Angular Material", we will once again replace a couple of our Bootstrap components, but this time, they will not have any relation to Bootstrap components
                    The Angular Material project has beautifully designed components, that are tailor-made for use in Angular applications and we'll learn how to incorporate a couple of those into our application
        
        Again, the important thing to note here, is that we have choices in terms of technologies for both laying out our web pages and as to which components we use - including creating our own custom components - when building our Angular applications
        Furthermore, as u'll see in "Chapter 12 Integrating Backend Data Services", u have virtually unlimited choices as to server-side and database technology stacks
        And, in "Chapter 14 Advanced Angular Topics", we will explore a couple of 3rd-party authentication APIs we may want to leverage for our application, instead of writing our own from scratch
        Yup ! We have a ton of interesting stuff to cover in this book together. That said, let's focus on 1st things 1st and get started with the goodies, this chapter has to offer: 
        Sass, Bootstrap, the typical evolution of software projects (that is, inception to realization) and building out our pages for Listing Carousel using Bootstrap (that is, Phase 1 of building our application)
        I'll provide a similar game plan for phase 2 of building our application at the start of "Chapter 7 Templates, Directives and Pipes" and 1 final game plan for phase 3 of building our application 
        at the start of "Chapter 12 Integrating Backend Data Services". I know, that was a lot of ground to cover, but reviewing our game plan was an important thing for us to do - 
        it's always helpful to know, where we are and where we're going. Now, let's pick up the pace and rip through the Sass crash course, before our coverage of Bootstrap
        
        SASS CRASH COURSE
        As is the case for most technologies, including all the ones mentioned in this book, such as ES6 / Bootstrap / Node / MongoDB - entire books can be written about them. Sass is no different
        The goal of this crash course is not to turn u into a Sass expert, nor is it to regurgitate Sass's official documentation. Due to space constraints, the goal of the crash course is 
        to merely introduce Sass to u and to motivate u to explore it further on your own, either after u complete this book / in parallel with it, because Sass is a really cool technology
        The Bootstrap team has adopted Sass for the Bootstrap project and other technologies (such as Compass) are built on top of it
        Strictly speaking, u don't have to know, how to use Sass, in order to write Angular applications - or even to work through this book - but it's a worthwhile technology to learn
        and so I encourage u to take a closer look on your own. Let's cover some Sass basics together now
        
        What is Sass ?
        - Sass is an acronym for "Syntactically Awesome StyleSheets" - but, of course, there's more sassiness to Sass, than the acronym !
          Sass is an extension to CSS, which gives us additional power and flexibility, when writing our CSS for our web applications. Sass, when compiled, generates well-formatted CSS for us
(B)       Specifically, the additions to CSS, that Sass brings to the table, include things such, as: nested rules / variables / conditional logic / mathematics / mixins / more
          Additionally, Sass makes it easier to maintain and organize the style sheets in our web projects. We'll be taking a look at many of these things in this crash course
        - Sass is compatible with all versions of CSS, not just CSS3 and CSS4
        - Thanks to the Angular CLI, Sass fits nicely into our Angular applications, because the CLI compiles the SASS in our components for us by default
        - Sass's official website: https://sass-lang.com/
        
        Compass framework                                               You can learn all u want to about Compass at their official website: http://compass-style.org/
        Compass is a CSS authoring framework, that is built on top of Sass, providing some neat additions and will also compile your Sass to CSS
        A compass is an option for u, if you're working on non-Angular projects (remember, the Angular CLI takes care of compiling Sass to CSS for us for our Angular projects)
        We won't be covering Compass in this book, but I wanted to at least bring the technology to your attention, because I know, that Angular is not the only technology you'll be using as a web developer - however, as web developers, we can't avoid using CSS !
        The takeaway point here is, that u can simply use the Angular CLI for Sass for Angular projects, but do take a look at leveraging Compass for your non-Angular projects, especially if your project tends to be CSS heavy
        Large companies use Compass. 2 of them, that I know of and whose online services I utilize on a daily bases, are:
        LinkedIn https://www.linkedin.com/ - the world's largest employment-oriented social networking service and Heroku https://www.heroku.com - a super popular cloud application platform
        Another nice online reference, that provides tutorials on Sass and Compass, is named "The Sass Way": http://www.thesassway.com/
        
        2 SASS styles
(B)     Sass has 2 flavors of syntax: the older syntax, that relies on indentation and the newer syntax, that uses curly braces, as opposed to indentation
        Another difference between the 2 syntactical styles is, that the old-style does not require semicolons at the end of the lines, where as the new style does require them
(B)     The file extensions between these 2 styles also differ - the older style's file extension is .sass and the current style's file extension is .scss
        Let's now look at a quick example of each one's CSS syntax. The 1st code block is the older style (.sass) and the 2nd code block produces the same effect in the newer syntactical style (.scss)
        We'll be using the new style throughout the book. The sample code given here is for writing .sass syntax:
            $blue: #0000ff
            $margin: 20px
            .content-navigation
                border-color: $blue
                color: lighten($blue, 10%)
            .border
                padding: $margin / 2
                margin: $margin / 2
                border-color: $blue
            
        The sample code given here is for writing .scss syntax:
            $blue: #0000ff;
            $margin: 16px;
            .content-navigation {
                border-color: $blue;
                color: lighten($blue, 10%);      }
            .border {
            padding: $margin / 2;
            margin: $margin / 2;
            border-color: $blue;         }
        The main difference between the 2 syntactical styles is, that the older style aims to be terse, while the newer style aims to be more familiar to developers used to traditional CSS syntax
        In the preceding code blocks, u may have noticed $blue and $margin. These are not CSS items, but rather they are examples of variables. You've probably also noticed division operators
        Variables and mathematical evaluation are just a couple of things, that can be in your Sass code. We'll see these and more Sass features a bit later in the sections, that follow
        Regardless of which syntax u use - old / new - the compiled result is the same. If u were to take either of the preceding code blocks and run them through an online compiler,
        such as Sass Meister (I'll mention this tool shortly as well), the resultant CSS will be the following:
            .content-navigation {border-color: #0000ff; color: #3333ff;}
            .border {padding: 10px; margin: 10px; border-color: #0000ff;}
        
        Installing Ruby
        Sass is written in Ruby and so we need Ruby installed on our computers. To download and install the latest version: https://www.ruby-lang.org/en/downloads/
        To find out, if u already have Ruby installed on your machine, run this command on your command line / Terminal: $ ruby -v
        If Ruby is installed, the output will display the version number. Np. the output in my Terminal, when I execute: "$ ruby -v" is "ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin16]"
        Any version from 2.3 onward is more, than good enough for our purposes
        
        Installing Sass
        Once u have Ruby installed, installing Sass is a breeze. Head on over to https://sass-lang.com/install and follow the directions
        Just like u can get the version of Ruby, by running "ruby -v" at your Terminal / command line, u can do the same thing with Sass
        Execute this command: "sass -version" to see what version of Sass u have on your system at your Terminal / command line. The output on my system shows the following: Sass 3.5.5 (Bleeding Edge)
        
        Online tools for Sass
        There are several online tools, that we can use to compile our Sass files down to CSS files. 1 of the ones I like, is named "Sass Meister" and u can access it here: http://www.sassmeister.com
        I like it, because it is super easy to use and provides decent help, when there is a problem with your Sass syntax. It also supports both Sass syntaxes, the older style and the newer style 
        and it also allows u to choose from a few different Sass compilers. You can find these settings under the Options menu option, at the top of the window panes
        To use the tool, simply write your Sass code in the left pane and the compiled CSS will appear in the right pane. Pay attention to the selected options, so that the ones, that are activated, are the ones u want
        
        Offline tools for Sass
        Just as with online tools, we have several options, that we can choose from, to compile our Sass files down to CSS files using offline tools. I've used "Koala", because it's easy to use, is cross-platform and is free
        You can download Koala for free from the project's website: http://koala-app.com/
        Koala gives u the ability to work with more, than just Sass. You can also use Koala to compile and / or compress Less / JS / CoffeeScript and u can even use the Compass framework with it
        The best way to learn, how to use Koala, is to read the official documentation, which can be found at https://github.com/oklai/koala/wiki#docs
        But if u'll just be using Koala to compile your Sass files (at least for now), let me quickly outline the steps for you here to save u from needing to jump back and forth between the book and the online docs
        All u need to do, is to create a web project using any text editor of your choice - such as Sublime Text / Visual Studio Code - and create a CSS folder, as well as a Sass folder in your project's root folder
        You don't need a completed project, of course - all u need is the very basic folder structure. Once the project structure is created, u can open Koala to get started, using it to compile your Sass files for u
            1. Create an empty project structure, which, as a minimum, has the following:
                A root folder with an empty index.html page in it         A CSS folder in the root folder with an empty styles.css file in it       A Sass folder in the root folder with an empty style .scss file in it
            2. Open the Koala application
            3. Click the large plus sign (+) in the top-left corner, navigate to your project's root folder and select it. At this point, Koala will find your styles.scss and styles.css files
            4. Right-click on your styles.scss file in Koala's right-hand pane, select Set Output Path and then navigate to and select your styles.css file in your file explorer
        Observing the preceding steps is all u need to do, to set Koala up to compile your Sass files for u. The output of the compilation will be inserted into your styles.css file
        
        Sass features and syntax
        Let's take a look at some of Sass's features, that u are likely to use in your applications. We won't be using all of these in our example application, but I wanted to show u some of the cool stuff, that Sass has to offer

        1) Nesting
        Using Sass, u can nest CSS rules within each other. Sass is not only easier to read, but it helps to avoid a lot of duplication of the CSS selectors. This is especially true for highlynested CSS rules
            #outer-frame p {color: #ccc; width: 90%; .danger-box {background-color: #ff0000; color: #fff;}}
        The preceding Sass code will be compiled and the equivalent CSS code will be generated:
            #outer-frame p {color: #ccc; width: 90%;}
            #outer-frame p .danger-box {background-color: #ff0000; color: #fff;}
        
        2) Variables
        Sass variables are just like u would expect them to be: they store info, that you'd like to reuse throughout your style sheet. This saves time and annoying errors
        And just like global variables in other languages, u only need to define them in 1 place - so if they ever need to change, u just have to change the variable in 1 place, rather than change all of the occurrences in your CSS styles
        You can store almost anything. Here is an example where we store the font information and a font color:
            $font-stack: Helvetica, sans-serif;            $primary-color: #333;
            body {font: 100% $font-stack; color: $primary-color;}
        The preceding Sass code will be compiled and the equivalent CSS code will be generated:
            body {font: Helvetica, sans-serif; color: #ccc;}
        
        3) Mathematical operations
        Since Sass compiles down to CSS, u can have it do mathematical calculations for u, instead of doing them yourself
        You can also have the math be run on variables, as opposed to hardcoded numbers as in the following example, which, of course, is super handy to be able to do:
            .main-container {width: 100%;}
            article {float: right; width: 700px / 960px * 100%;}
        The preceding Sass code will be compiled and the equivalent CSS code will be generated:
            .main-container {width: 100%;}
            article {float: right; width: 72.91667%;}
  
        4) Imports
        Sass enables u to import 1 style sheet into another 1 using the @import directive. This does, as it sounds and is very straightforward. Let's look at an example
        In the following 3 code listings, the 1st 1 is the base style (base.scss) sheet, that is applied to the entire site and the 2nd is the style sheet, that is used for the report pages (reports.scss)
        The 3rd is the resultant CSS style sheet we would get, when the reports style sheet imports the base style sheet during Sass compilation. Note, that the file extension is not required, when using the @import directive in Sass
        /* base.scss */
            body {margin: 10px; padding: 10px; font: Helvetica, sans-serif; color: #333; background-color: #eee;}
        /* reports.scss */
            @import 'base';
            p {margin: 5px; padding: 5px; color: #0000CD; background-color: #EEE8AA;}
        The preceding Sass code will be compiled and the equivalent CSS code will be generated:
            body {margin: 10px; padding: 10px; font: Helvetica, sans-serif; color: #333; background-color: #eee;}
            p {margin: 5px; padding: 5px; color: #0000CD; background-color: #EEE8AA;}
  
        5) Extend
        Using @extend lets u share a set of CSS properties from 1 selector to another. 1 selector can extend (that is, inherit) from another 1 using the @extend Sass directive
        The following example shows a common set of style attributes for a set of 3 related styles - active / inactive / terminated:
            %common-status-styles {width: 200px; height: 75px; padding: 10px; color: #333;}
            .active {@extend %common-status-styles; background-color: green; border-color: #001a00;}
            .inactive {@extend %common-status-styles; background-color: yellow; border-color: #999900;}
            .terminated {@extend %common-status-styles; background-color: pink; border-color: #ff5a77;}
        When the preceding Sass code gets compiled, it turns into the following CSS:
            .active, .inactive, .terminated {width: 200px; height: 75px; padding: 10px; color: #333;}
            .active {background-color: green; border-color: #001a00;}
            .inactive {background-color: yellow; border-color: #999900;}
            .terminated {background-color: pink; border-color: #ff5a77;}
        
        6) Mixins
        Mixins are like named templates. They are Sass's way to allowing u to group CSS / Sass declarations (that is, CSS styles) together and give it a name
        This way, u can include these declarations in other CSS classes as needed, without copying and pasting - which causes a bit of a mess, should anything need to change later on
        In a sense, they are also like variables, because u only need to change sth in 1 place (that is, in the mixin itself), but they are more powerful, than variables, which is why I mentioned, that they are like templates
        In fact, mixins can even be parameterized using variables. Let's look at an example and the preceding description should become clear, as to what I mean, when I say, that mixins are like templates
        Here is an example of styling a dropdown, that I like to use in my websites. We'll parameterize the width, so that we can create different sizes of dropdowns. Note the use of the @mixin directive:
            @mixin custom-dropdown($dropdown-width) {
                -webkit-appearance: button;  -webkit-border-radius: 2px; -webkit-box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.1); -webkit-padding-end: 20px;  -webkit-padding-start: 2px;  -webkit-user-select: none;
                background-image: url(https://www.maxfusioncloud.com/static/img/15xvbd5.png), -webkit-linear-gradient(#FAFAFA, #F4F4F4 40%, #E5E5E5);
                background-position: 97% center; background-repeat: no-repeat; border: 1px solid #AAA; color: #555; font-size: 10pt; margin: 0px; overflow: hidden; padding: 5px 12px 6px 6px; text-overflow: ellipsis;
                white-space: nowrap; width: $dropdown-width;}
        And here is how we can use the mixin (note the use of the @include directive):
                .small-dropdown { @include custom-dropdown(75px); }
                .medium-dropdown { @include custom-dropdown(115px); }
                .large-dropdown { @include custom-dropdown(155px); }
        This will compile to the following CSS:
                .small-dropdown {-webkit-appearance: button; -webkit-border-radius: 2px; -webkit-box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.1); -webkit-padding-end: 20px; -webkit-padding-start: 2px; -webkit-user-select: none;
                background-image: url(https://www.maxfusioncloud.com/static/img/15xvbd5.png), -webkit-linear-gradient(#FAFAFA, #F4F4F4 40%, #E5E5E5); background-position: 97% center; background-repeat: no-repeat;
                border: 1px solid #AAA; color: #555; font-size: 10pt; margin: 0px; overflow: hidden; padding: 5px 12px 6px 6px; text-overflow: ellipsis; white-space: nowrap; width: 75px;}
                .medium-dropdown {-webkit-appearance: button; -webkit-border-radius: 2px; -webkit-box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.1); -webkit-padding-end: 20px; -webkit-padding-start: 2px; -webkit-user-select: none;
                background-image: url(https://www.maxfusioncloud.com/static/img/15xvbd5.png), -webkit-linear-gradient(#FAFAFA, #F4F4F4 40%, #E5E5E5); background-position: 97% center; background-repeat: no-repeat;
                border: 1px solid #AAA; color: #555; font-size: 10pt; margin: 0px; overflow: hidden; padding: 5px 12px 6px 6px; text-overflow: ellipsis; white-space: nowrap; width: 115px;}
                .large-dropdown {-webkit-appearance: button; -webkit-border-radius: 2px; -webkit-box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.1); -webkit-padding-end: 20px; -webkit-padding-start: 2px; -webkit-user-select: none;
                background-image: url(https://www.maxfusioncloud.com/static/img/15xvbd5.png), -webkit-linear-gradient(#FAFAFA, #F4F4F4 40%, #E5E5E5); background-position: 97% center; background-repeat: no-repeat;
                border: 1px solid #AAA; color: #555; font-size: 10pt; margin: 0px; overflow: hidden; padding: 5px 12px 6px 6px; text-overflow: ellipsis; white-space: nowrap; width: 155px;}
        By now, u can see how cool Sass is and how much time it can save u, as well as how u can use it to avoid code duplication and avoid making the silly cut and paste mistakes
        And as if all this wasn't cool enough, Sass gives u a lot of power with its built-in functions. There are a ton of them, which is what gives Sass so much power and utility
        You can take a look at them here: http://sass-lang.com/documentation/Sass/Script/Functions.html. We'll only be covering 1, just to show u an example of how to use a function in the Built-in Functions section, that follows
 
        7) Placeholders
        Placeholders are intended to be used with the @extend directive. Rulesets, that do make use of placeholders, but which do not use the @extend directive, will not get rendered to CSS
        A valid use case of using placeholders is, if u are writing a Sass library for code reuse
        You can write a Sass file, that has placeholders and which is meant to be included in another Sass file, that u / someone else writes
        If a ruleset in the Sass file imports the other Sass file, that acts as a library and the ruleset extends the placeholder in your library, it will be rendered to the CSS file, when the Sass files are compiled
        And, if no rulesets extend the placeholder, the placeholder will not be rendered / printed to the CSS file. Let's take a look at an example. Note, that the placeholder is prefixed by a percent sign (%):
            %warning-placeholder {color: red; font-weight: bold; font-size: 1.5em;}
            .warning {@extend %warning-placeholder;}
        The preceding Sass code compiles down to the following CSS:
            .warning {color: red; font-weight: bold; font-size: 1.5em;}
        
        8) Built-in functions
        When we covered Sass's "extend" feature, the border colors for each class were 20% darker, than their corresponding background colors
        In order to find a color, that is 20% darker, than another, u have to do some tedious math - and if u decide to later change that percentage, it'll require more tedious math
        Fortunately, Sass has built-in functions for us to do all sorts of things, including darkening / lightening colors and a whole lot more
        Now, let's revisit the Sass code we had seen in the previous "Extend" section and this time write it more flexibly, using variables and the built-in darken function, in order to have Sass do the math for us
        This way, it makes it easy to change the percentage later on, if we choose to. The compiled output of the following Sass code would be the exact same, as the compiled output in the previous Extend section and so we won't repeat that here:
            /* Example of using variables and a built-in function */
            $active-color: green; $active-border-color: darken($active-color,20%); $inactive-color: yellow; $inactive-border-color: darken($inactive-color,20%); $terminated-color: pink;
            $terminated-border-color: darken($terminated-color,20%); %common-status-styles {width: 200px; height: 75px; padding: 10px; color: #333;}
            .active {@extend %common-status-styles; background-color: $active-color; border-color: $active-border-color;}
            .inactive {@extend %common-status-styles; background-color: $inactive-color; border-color: $inactive-border-color;}
            .terminated {@extend %common-status-styles; background-color: $terminated-color; border-color: $terminated-border-color;}
        
        9) Custom functions
        Sass gives us a lot of power through using its ready-to-use, built-in functions, but sometimes, there's no substitute for custom functions - functions, that do exactly what u want for the project at hand
        The folks on the Sass team knew this and thus gave us a way to add custom functions to our Sass files
        Let's take a quick look at how we can create a custom function. Our function will compute the width, as a percentage given 2 parameters, the number of columns for the target width and the total number of columns we have
        In this short example, you'll notice, that we do the following:
            - Make use of variables - Perform some simple math - Use a built-in Sass function (that is, percentage) - Introduce 2 new Sass commands: @function and @return:
            @function column-width-percentage($cols, $total-cols) {@return percentage($cols/$total-cols);}
            .col-1 {width: column-width-percentage(4, 12);}         .col-5 {width: column-width-percentage(5, 12);}
        This compiles to the following CSS:
            .col-1 {width: 33.33333%;}          .col-5 {width: 41.66667%;}

        BOOTSTRAP CRASH COURSE
        In this section, we're going to take a look at Bootstrap, in particular, its responsive grid and its components. We're going to cover just enough of Bootstrap's grid to give u a solid start on how to use it
        We're also going to cover just 5 of Bootstrap's components to get u started. Bootstrap has a lot more, than 5 components and there are many ways, u can customize each 1 of them
        However, this is a crash course on Bootstrap and not a comprehensive manual - which is what would be needed to even attempt to cover Bootstrap in any level of detail
        Bootstrap is a vast library with tons of options for its use and thus it is far more important to just show u the basics and to show u where to go for further info on Bootstrap, 
        than it is to attempt to cover it exhaustively. The good news is, that this crash course on Bootstrap is the fastest way to get u up and running with it
        The reasoning for taking this approach:
            - we won't be using all of the Bootstrap components for our example application 
            - our example application will also be made from "ng-bootstrap" components and Angular Material components (which we'll be covering in later chapters: "Chapter 8 Working with NG Bootstrap" and "Chapter 9 Working with Angular Material")
            - the most important part of Bootstrap for us will be Bootstrap's Grid - and we'll be covering the grid in more detail, than the 5 components we'll be looking at
        However, unlike the Sass crash course, we will see how to use Bootstrap in a practical way, since we'll be using it directly in our example application, as we lay out the home page in this chapter

        What is Bootstrap ?
(B)     Bootstrap is a CSS framework for building responsive websites, with an emphasis on being mobile-1st. While there are other frontend presentation frameworks, 
        Bootstrap is still the king of the hill in this arena - not only due to being the 1 with the most mind share, but it probably has the most runtime
        What I mean by runtime, is the number of times it's been used in websites and thus it has been put through its paces more, than the other CSS frameworks
        Bootstrap's leading mind share (that is, popularity) is primarily due to 3 things:
            - it was 1 of the very 1st frameworks of its kind (so the competition was virtually non-existent)
            - it came with the backing of 1 of the top social websites in the world (Twitter)
            - it has been around since August 2011 and so is mature
        Additionally, as we'll see in "Chapter 8 Working with NG Bootstrap", the ng-bootstrap project is all about creating Angular widgets using Bootstrap 4, which says a lot about what the Angular community thinks of Bootstrap
        There is a reason, that this 3rd edition remains true to the relationship between Angular and Bootstrap and that is because they are each leaders in their respective niches, 
        as well as being symbiotically compatible and complimentary. In fact, these 2 frameworks are all u need to build the frontend part of powerful web applications,
        choosing just about anything u like for building out the backend, since all backend frameworks these days can produce and consume JSON, including mainframes still running COBOL programs
(B)     This is because JSON has become the most popular way to integrate systems through messaging
        
        Motivation
        If you've ever tried to build a website, that works well on different viewport sizes (that is form factors / screen sizes) without the use of a framework to help u along, 
        the motivation for Bootstrap is pretty easy to see - building sth like that from scratch is both tedious and difficult. Mobile computing really escalated the need for sth like
        Bootstrap to come along and it was inevitable, that it would. While the same can be said for just about any framework, in that you probably shouldn't spend time reinventing the wheel,
        unless u have an extremely good set of reasons for doing so, it can be argued that (for the vast majority of websites and even web applications) the frontend has become more important, than the backend
        It's been a fact for the last several years, that the client side is the new black. I'm not suggesting, that the backend is not important - nothing could be further from the truth and i, 
        Integrating Backend Data Services, is completely devoted to building out the backend. However, I am suggesting, that when mobile computing came to be, 
        we already had more, than enough backend technologies and scores of frameworks to choose from, but were lacking in frontend frameworks
        The final comment I will add to conclude this motivation section, is that killing 2 birds with 1 stone in the business world can give companies a competitive advantage (that is, speed to market) 
        and / or financial advantage (that is, cost savings) - and so it isn't any different with software development. If u can build sth once, in this case, a series of web pages 
        and use the same client-side code for both mobile and desktop, instead of building 2 sets of everything (or even 3 sets, considering tablets as well), u should realize savings of both time and money
        That is the promise - unfortunately, it is not always fulfilled. However, getting some advantage in these areas is certainly better, than getting none at all
        
        Bootstrap's role in our example application - for our example application, Bootstrap will be used for only 2 purposes:
        - To lay out the web page using its responsive grid        - To leverage some of it's read-to-use components for quickly building a nicely styled UI        

        Installing Bootstrap
        Installing Bootstrap, for the purposes of learning it, will be different from how we'll install "ng-bootstrap" in our Angular application
        This chapter focuses on Bootstrap's grid system, as well as some of its components and so we're going to keep things simple for now, by not creating an Angular application - or make any use of Angular at all, just yet
        By the end of this chapter, we'll just have our skin and bones application (as previously mentioned), which we will then be converting into a fully-fledged Angular application
        Let's get started with the minimal and fastest way to integrate Bootstrap into our HTML. To use all Bootstrap has to offer, we only need to add resource links to 1 style sheet and 3 JS files
        The following is the HTML code, that creates an empty HTML page, that demonstrates the bare essentials to wire in Bootstrap:
            <!DOCTYPE html>
            <html>
                <head>
                    <title>Chapter 3 - Bootstrap: Responsive Grid Layout & Components</title>
                    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" crossorigin="anonymous">
                    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" crossorigin="anonymous"></script>
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" crossorigin="anonymous"></script>
                    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" crossorigin="anonymous"></script>
                </head>
                <body>
                    This page is intentionally blank. It's sole purpose is to show the HTML code, that needs to be added to integrate Bootstrap
                </body>
            </html>
        Following the order of the linked files in the previous HTML code, here are what the 1 CSS file and 3 JS files are for:
            - the bootstrap.min.css file is the minified style sheet for Bootstrap, which is where all the default styles are defined
            - the jquery-3.2.1.slim.min.js file is the minified JS file containing the jQuery library and is referenced, because Bootstrap itself relies on jQuery
            - the popper.min.js file is the minified JS file for yet another 3rd-party library called Popper and is referenced, because Bootstrap makes use of the functionality therein for its Tooltip components
            - and, finally, the bootstrap.min.js file is the minified JS file for Bootstrap itself and is used for various components, such as the modal and drop-down components, which require JS to function
        You'll also notice, that the links are resources to CDNs (that is, content delivery networks). Although there are other ways of installing Bootstrap in our website, the advantages of using CDNs are threefold:
            - we don't need to download and include the files in our web project
            - the load time for the clients loading our web pages is minimized on account of the fact, that these resources may have already been downloaded to their browsers, while visiting other sites before ours
            - the servers are optimized for delivering those assets (using caching and other hosting strategies)
        We will look at adding our navigation bar on our home page, when we take a look at the Navs and the Navbar components later in this chapter
    
        Bootstrap's responsive grid system
        From my perspective, especially as a web developer, that focuses on Angular, the most important thing, that Bootstrap offers, is a responsive grid
        The reason for this is, that there are many web / HTML components from many different libraries to choose from for web development (such as "NG Bootstrap" and "Angular Material", both of which we'll be covering in later chapters) 
        and, hence, we're not at all limited to just using Bootstrap's components. However, no matter which components u end up using / if u create your own (as we'll learn how to do in "Chapter 6 Building Angular Components"), 
        the Bootstrap grid can still be used for building responsive layouts and greatly simplifying our laborious task of creating well-designed web applications
        Bootstrap's grid makes it really easy for us to lay out our pages for use with various viewport (that is, screen) sizes
        We simply use special Bootstrap classes to dictate, how things get positioned on our pages for the different viewport sizes, that our applications may be running on
        If you've ever wondered, if Bootstrap is built on top of anything else, the answer is, unsurprisingly, yes. Libraries and frameworks often piggy-back on 1 another
        This is how modern software in the open-source world is built. After all, why reinvent the wheel, when there are perfectly sound wheels already available for our use ? 
(B)     We have already seen (from the previous section on installing Bootstrap), that Bootstrap relies on jQuery and Popper. Bootstrap's responsive grid system is built on top of the CSS Flexbox, which was introduced in CSS3
(B)     There is a newer grid system in CSS4, called the "CSS Grid", but Bootstrap 4 does not use it. Bootstrap uses CSS Flexbox. This does not mean, that Bootstrap is behind the times, because newer does not necessarily mean better
        Some things are made easier using the CSS Grid and other things remain easier using CSS Flexbox. A bit later on, when we discuss Bootstrap's predefined classes, 
        that are used for aligning things vertically / horizontally within the grid, the class names may seem familiar to u, if u are familiar with CSS Flexbox
(B)     This is because Bootstrap uses CSS Flexbox under the covers and the class names were inspired by its class names
        The grid itself has 3 main parts to it (container / row / column) and each 1 of these is a class defined in Bootstrap's CSS file - which is why it needs to be referenced in our pages
        This is where the vernacular gets a little confusing, so let me explain sth real quick. As u may know, there are no HTML elements named: container / row / column
        We do, however, have the "div" element in HTML, and, in Bootstrap, we decorate it with a class - particularly, with a class of: container / row / column
        But when we are talking about Bootstrap, it would be easier to pretend, that there are HTML elements of these types
        Let me clarify this, because I'll be referring to the Bootstrap row, as the row element and the Bootstrap column, as the column element from here on. Here's what I mean:
            - it is easier to say the "container element", rather than have to say the div element with a class of container (in code, this is what the container element looks like: <div class="container"> )
            - it is easier to say the "row element", rather than have to say the div element with a class of row (in code, this is what the row element looks like: <div class="row"> )
            - it is easier to say the "column element", rather than have to say the div element with a class of column (in code, this is what the column element looks like: <div class="col"> )
        
        The container
        The container is the root / top-level element in the grid. It holds 1 / more rows, which must be nested within the container and the rows, in turn, can contain zero / more columns
        To create a Bootstrap grid, we start off by creating a container - and to do that, we simply create a set of HTML div elements and assign the container class to the 1st div element
            <div class="container"></div>
        Do u see why I mentioned the previous stuff about a container element ? It's a messy way to try and explain it. So, let's rephrase that now using our new vernacular. To create a Bootstrap grid, start off by adding a container element:
            <div class="container"></div>
        There are 2 types of containers, that u can have - and it is their class name, that differentiates them from 1 another:
            <div class="container"></div>           fixed-width container centered in the middle the viewport
            <div class="container-fluid"></div>     full-width container, that spans the entire viewport width (no margins)
        
        The row                                                             The row element must be nested within the container element
        A Bootstrap grid must contain at least 1 row and can contain as many rows, as are needed. Adding to the previous container code, here is what the code for a grid looks like, that has 2 rows:
            <div class="container">
                <div class="row"></div>
                <div class="row"></div>
            </div>
        A row does not have to contain a column at all - np. u may simply just want empty space between 2 rows in your grid - but it can have a maximum width of 12 columns within it
        However, it is important to note, that the number of columns a row has, is not proportional to the number of nested column elements (we'll look at Bootstrap's notion of a column in the next section)
        This is because the total number of columns in a row is independent of the number of column elements in that row. Let me show u 3 examples to clarify this notion, by adding to the previous row code
        I will explain what class="col-4", class="col-6", and, generally speaking, class="col-x" (where x is an integer ranging from 1 to 12), all mean right after the following 3 grid examples
        In the 1st example, the grid has 2 rows, each of which has 3 columns of equal width:
            <div class="container">
                <div class="row">
                    <div class="col-4"></div>
                    <div class="col-4"></div>
                    <div class="col-4"></div>
                </div>
                <div class="row">
                    <div class="col-4"></div>
                    <div class="col-4"></div>
                    <div class="col-4"></div>
                </div>
            </div>
        In the 2nd example, the grid only has 1 row with 2 columns of equal width:
            <div class="container">
                <div class="row">
                    <div class="col-6"></div>
                    <div class="col-6"></div>
                </div>
            </div>
        In the 3rd example, the grid also only has 1 row with 2 columns, but they are not of equal width. In fact, the 1st column only takes up 25% of the row's total available width and the 2nd column takes up the remaining 75%:
            <div class="container">
                <div class="row">
                    <div class="col-3"></div>
                    <div class="col-9"></div>
                </div>
            </div>
        Now we can discuss what on earth the "colx" class names mean. The grid allows up to 12 columns per row and each column element u embed in the row, can span 1 to 12 columns and this is what the x represents
        As a quick example, if we have a column element in our row and we'd like for it to span 8 of the available 12 columns, our class name would be col-8 and our column element: <div class="col-8">
        The key is that the total number of columns in our row (which is the addition of the x's in our class names) should not surpass 12. However, it can be less than 12
        Additionally, each row in your grid can have different numbers of columns, where each column is also a different width to the other columns within the same row
        Let's quickly look at an example, before discussing some interesting ways, that u can align columns within the row, by adding pre-defined Bootstrap classes to the row element:
            <div class="container">
                <div class="row">
                    <div class="col-10"></div>
                    <div class="col-2"></div>
                </div>
                <div class="row">
                    <div class="col-4"></div>
                    <div class="col-3"></div>
                    <div class="col-5"></div>
                </div>
            </div>
        The grid in the preceding code has 2 rows, where the 1st row has 2 columns of unequal widths and the 2nd row has 3 columns of unequal widths.
        Whenever u have a grid, u need to concern yourself with how things align up within it. Bootstrap has pre-defined classes, that can be used on the row elements, in order to align the column elements within them
        Here are a few of these classes:
            justify-content-center (centers the columns)      justify-content-start (left-justifies the columns)    justify-content-end (right-justifies the columns)    
            justify-around-end (spaces the columns evenly)    justify-between-end (puts all the available space between the 2 columns)
        The interesting thing about these classes - which affect the horizontal alignment of the columns in the encapsulating row - is that u can only see their effect, 
        when the total spanned columns of all the column elements amount to a number less, than 12. This is precisely, why having fewer, than 12 spanned columns, is allowed
        An example of what a row element, that contains fewer, than 12 spanned rows, looks like:
            <div class="container">
                <div class="row justify-around-end">
                    <div class="col-4"></div>
                    <div class="col-4"></div>
                </div>
            </div>
        In this previous example, we have a grid, that has 1 row and that row contains 2 columns. However, since the total spanned columns are fewer than 12, the horizontal alignment, that will be applied 
        (due to the justify-around-end class) will have a visible effect - which is to center the columns while inserting the available unused space (a 3rd of the row's width in this case) around the columns
        This will have the appearance of margins on either side of the columns, with double the margin between them. The other classes mentioned have different horizontal alignment effects, 
        than the description beside them in the bullet list. I encourage u to play around with these classes to get used to them
        
        The column
        The column elements must be nested within the row elements, as the previous examples showed. We've already seen, how many column elements can fit in a row, which depends on their respective column widths
        The columns in the grid are basically your cells in the grid and are where your content (that is, text, images and so on) is to be inserted. If u have a grid, that has 6 rows of 4-column elements each, u have 24 cells in which to place your content
        Just as u can align the column elements within the row elements, using special classes on the row elements, u can also align the content within your column elements, using special classes on the column elements
        Here are some of the classes, u can use on the column elements, in order to align your content within them:
            - align-self-start will force that specific cell's content to the top of the cell
            - align-self-end will force that specific cell's content to the bottom of the cell
            - align-self-center will force that specific cell's content to the vertical center of the cell
        
        Differing viewport sizes
        The final thing, that I would like to cover regarding Bootstrap's grid, is probably the most important 1 of all. What makes the grid responsive ? That is to say, how does the grid adapt to different viewport sizes ? 
        The answer to this is 2-fold. 1stly, most HTML layouts (even vanilla layouts, that were not at all designed to be responsive) have some built-in leeway on how they react, when viewed on screens of varying sizes
        However, while the layout of a standard web page may still be acceptable in the way, a browser renders it on a tablet vs. a regular 19-inch monitor, 
        things tend to break down and not work at all for a website, that looks decent on a tablet, but is currently being viewed on a standard mobile phone, such as the iPhone 7 / a similarly sized Android device
        This is where we need some design intervention and what leads to the 2nd way, in which a Bootstrap grid adapts to the device's viewport size - namely, special tweaks to the classes and class names for the column
        You'll remember, that the class name we've been using for the column element has the following general form:
            <div class="col-x">
        Well, in order to make the grid responsive, Bootstrap has included the ability for us to tweak the classes, by adding a symbol to the class name between the "col" and the "x" (that is, an integer from 1 to 12)
        Np. here is what the column element's class would look like with 1 of these symbols (in actuality, it's not a symbol, but rather a new class name - however, for the purposes of explaining it, u can think of it as a symbol):
            <div class="col-sm-4">
        I'll explain what the "sm" in "col-sm-4" means in a moment, but, in practice, you'll see more, than 1 class name on a column element. Np. here is a likely set of class names on a column element:
            <div class="col-xs-12 col-sm-4 col-md-3" >
        OK, let's decipher what this set of classes is for. To do that, let me 1st list the available symbols and what they mean:
                            Class prefix .col-xs- .col-xs- .col-md- .col-lg- .col-xl-        (...tabelka...)
        In the preceding table, in the 3rd row from the bottom, I've listed the 5 symbols, that are available to u. In the 2nd row from the bottom, I have listed the typical target devices for which the symbol and thus the grid-breakpoint, applies
        I'll discuss the grid-breakpoint in a moment, but I just wanted to say, that these target devices I've listed, are rules of thumb - they are not set in stone. Np. Android tablets are listed in 3 of the 5 viewport size columns
        This is because there are many Android tablet manufacturers and even more sizes of displays (that is, viewports), that they come in. The same can be said for laptops
        However, the viewport sizes on Apple-based products are well known and fewer in number - and is why I listed them by name. Suffice it to say, by taking a look at the typical device's row, 
        u can get a fairly good idea of what column class u probably want to use. Armed with this knowledge of viewport sizes and the previous table, let's now decipher, what this column element and set of classes mean:
            <div class="col-xs-12 col-sm-4 col-md-3" >
        This column element contains a set of 3 classes and each class, basically instructs the browser on how to render the column and its contents, depending on the viewport size
        As an aside, technically speaking, the viewport size is the maximum dimensions (in px) of the display. Taking the case of a 13-inch laptop monitor with its resolution set to 1600 x 900, its viewport size is 1600px wide by 900px high
(B)     Practically, however, the viewport size is the dimensions of the browser window and not the laptop's display itself. This is an important distinction, when we talk about responsive web design because, 
        when using a desktop / laptop computer, people can resize their browsers - which forces the web page to be re-rendered - and, hence, this is truly what the viewport size is, from Bootstrap's perspective and for our purposes
        Coming back to the deciphering of the previous column element, while referencing the previous viewport size table and having mentioned how the resizing of the browser
        dictates the viewport size that we, as developers, care about, we can now decipher what these 3 classes are instructing the browser to do:
            col-xs-12: this tells the browser, that when the viewport is fewer, than 576 px in width, the column should span all 12 columns. In other words, the column should consume the entire available width of the row
            col-sm-4: this tells the browser, that when the viewport is between 576 and 767 px in width, the column should span 4 of the 12 available columns. In other words, the column should consume 1/3 of the row's width
            col-md-3: this tells the browser, that when the viewport is 768 / more px in width, the column should span 3 of the 12 available columns. In other words, the column should consume 1/4th of the row's width
        We could have controlled the rendering of the column for viewport sizes 992 / more px in width, by adding the classes with the class prefixes .col-lg- and .col-xl-, 
        but, in the example we've just seen, we didn't seem to care - which is to say, no matter how wide the viewport is (even 2400px !), our column's width would scale to consume 25% of the row's width
        And that, ladies and gentlemen, is how u can design a web page, while maintaining how the contents in your grid's cells are to be rendered on thousands of viewport sizes
        By leveraging Bootstrap's grid, we no longer need to code up several variations of our web pages to get them to display the way we want on different sized displays. Pretty darn cool, ain't it ?
   
        Bootstrap components
        I will briefly discuss 5 of Bootstrap's components, that we'll be using, showing some basic code for them and pointing u to Bootstrap's official documentation for these components
        
        1) Button components
        Buttons on a web page transport things - such as info, when u click the "submit" button on a form, that u fill out
        But perhaps an equally important feature of buttons is to help make your web pages attractive and intuitive. Luckily, Bootstrap makes it super easy to add beautifully styled buttons to our web pages
        Let's take a look at a few of these, while exploring some of Bootstrap's pre-defined button classes (that is, styles)
        Out of the box, without any tweaking necessary, we can easily insert a beautifully styled button, by assigning 2 classes to the button element:
            <button type="button" class="btn btn-primary">Click me</button>
        That button is blue in color, but there are other default colors we have access to via these other classes:
            btn-2ndary: Light charcoal gray, with white font     btn-success: Light green, with white font    btn-danger: Red, with white font   btn-warning: Goldenrod, with black font
            btn-info: Teal, with white font                      btn-light: Light gray, with black font       btn-dark: Almost black, with white font
        There's also a class for turning a button into a link: btn-link
        If u prefer sth more white / less heavy on the color, Bootstrap has a set of classes, that match the preceding classes, called Outline buttons
        The colors and class names are the same, with the only difference being the word outline between btn and 2ndary, success, danger and so on
        The buttons are transparent, except for the outline, or border and of course, the font color for the text on the button:
            btn-outline-2ndary: Light charcoal gray outline, with the same color for the font          btn-outline-success: Light green outline, with the same color for the font
            btn-outline-danger: Red outline, with the same color for the font                          btn-outline-warning: Goldenrod outline, with the same color for the font
            btn-outline-info: Teal outline, with the same color for the font                           btn-outline-light: Light gray outline, with the same color for the font
            btn-outline-dark: Almost black outline, with the same color for the font        
        All these buttons come in a default size, in terms of height and font size. However, as u may have guessed, Bootstrap has a way, in which to make the default button larger / smaller 
        by adding the .btn-lg or .btn-sm class, respectively:
            <button type="button" class="btn btn-primary btn-lg">I'm large</button>
            <button type="button" class="btn btn-primary btn-sm">I'm small</button>
        You can read all u care to about Bootstrap's buttons: https://getbootstrap.com/docs/4.0/components/buttons/
     
        2) Alert components
        When a user takes an action on a web page, such as updating their phone number on their user profile, it's always nice to let them know, if the update was successful / not
        Sometimes these user feedback messages are referred to as "flash messages" (because they often only appear for a few moments and then fade away, so as to not clutter the screen)
        Bootstrap calls them "alerts" and they are created by adding the predefined alert classes and a role attribute to a div element
        For the most part, their coloring and naming scheme is fairly consistent with the button components:
            <div class="alert alert-primary" role="alert">This is a primary alert</div>           <div class="alert alert-2ndary" role="alert">This is a 2ndary alert</div>
            <div class="alert alert-success" role="alert">This is a success alert</div>           <div class="alert alert-danger" role="alert">This is a danger alert</div>
            <div class="alert alert-warning" role="alert">This is a warning alert</div>           <div class="alert alert-info" role="alert">This is a info alert</div>
            <div class="alert alert-light" role="alert">This is a light alert</div>               <div class="alert alert-dark" role="alert">This is a dark alert</div>
        Not only do Bootstrap's alerts look pretty, but they are quite neat. You can embed links in them (since it's just HTML, after all) and even insert an optional dismiss button
        The alert component is a good example of why Bootstrap depends on the jQuery library, since it's required for the dismissal of the alert component
        Alerts are worth the time to learn, so that u can utilize them in your applications. Here is the link to Bootstrap's documentation on its alert components: https://getbootstrap.com/docs/4.0/components/alerts/
   
        3) Navbar component
        The Navbar component is very rich - u can do a lot with it - but, in essence, it's Bootstrap's way to give u a nicely styled navigation bar across the top of your web page
        The richness comes from the fact, that there are a few sub-components, that can be used:
            .navbar-brand for your company, product, or project name            .navbar-nav for a full-height and lightweight navigation (including support for dropdowns)
            .navbar-toggler for use with our collapse plugin and other navigation toggling behaviors            .form-inline for any form controls and actions
            .navbar-text for adding vertically centered strings of text         .collapse.navbar-collapse for grouping and hiding navbar contents by a parent breakpoint
        Showing examples of all these items here would be too costly, with little associated benefit. Rather, than do that here, I will show u how to use Bootstrap to build the navigation menu 
        for our example application later in this chapter. The code can be found in the code listings at the end of the chapter. The 1st wireframe in the pages, that follow, shows a logo placeholder, a menu and Login and Try Now buttons
        The wireframes represent drafts of the pages we're aiming to build. Our navigation bar will look slightly different, but will encompass all the parts, that are shown on the wireframe
        More documentation on Bootstrap's Navs and Navbar components: https://getbootstrap.com/docs/4.0/components/navs/ and https://getbootstrap.com/docs/4.0/components/navbar/
        
        4) Modal components
        Modal components are great ways to draw your user's attention to things by using them for creating lightboxes, user notifications and more
        I like to use them for popping up forms for users to add items and edit them as well, directly from the page, that lists those items
        This way, all the functionality (that is, view, add, edit and delete) for a listing of items is all done on 1 page. Using the modal component in this way, leads to a clean design, that is intuitive to users
        As with the Navbar component, showing examples here is not the best way to demonstrate modals. Rather, than show contrived examples, I will show u through code 
        (by referencing the code listings at the appropriate time) how we'll achieve creating the modal forms shown in the following wireframes
        When u take a look at the wireframes, u'll see, that I've used modals quite generously throughout the pages. I've even used them for the login and the sign-up functionality of the site
        There are several demos on Bootstrap's modal component: https://getbootstrap.com/docs/4.0/components/modal/
        
        We've only covered 4 commonly used components, that Bootstrap offers, but they are enough for us to get a glimpse of what can be done with pre-defined components
        There are many other components, that can be used and u can find them on the official Bootstrap website: https://getbootstrap.com/docs/4.0/components/
        Again, we're not covering all of Bootstrap's components, because the official documentation has done that job already - and has done it well
        Additionally, we'll be using "NG Bootstrap components", "Angular Material" components and custom components, that we'll be creating together in later chapters
        
        LISTING CAROUSEL - A FORMAL INTRODUCTION
        The evolution of a software project is a very interesting thing and it follows a very logical series of stages. Here are the stages, that we will cover - which are true of any software project:
            1. Idea generation / concept
            2. Analysis / feasibility study: The purpose of conducting a feasibility study on the product concept is to vet the ROI (that is, return on investment) for the project
               In other words, is the project worth the company's investment of its resources (time, money, talent and so on) ?
            3. Requirement gathering
            4. Use cases
            5. Wireframes
            6. Implementation
        With these software project stages outlined, let's look at a real-life example using Listing Carousel
    
        1) Idea generation / concept
        Ideas for software projects can come from anywhere and at any time, but for the vast majority of the time, the ideas are inspired by a need to solve problems, that organizations will invariably have from time to time throughout their lifetimes
        The 2 main categories of problems are addressing an inefficiency and creating an opportunity for itself in the market via creating a competing product, that is better than (that is, differentiated from) those of its competitors
        Stated in other terms, software projects can often be viewed as either being an efficient play / a competitive advantage play. Solving these 2 types of problems are the needs, that every growing organization will have 
        at some point, or at  many points, in time throughout its existence. So, how was Listing Carousel conceived ? Having been a real estate salesperson in a previous life, turned IT pro, it was easy for me to think of a way 
        to develop a better way for real estate agents to spread the word of their new listings (that is, properties for sale) to their social media circles and to showcase their listings in a more informative way, 
        than the other primary options currently available to them. While there are several ways a real estate agent can market their listings, I found they lacked 2 basic things:
            - a way to easily spread the word of their listings to their social media circles (that is, Instagram and Facebook)
            - a way to present the properties in a slightly more engaging way, while also better describing the properties at the same time
        So, the problem I had, was that I had to create a software product, that was markedly differentiated from other software services. The solution was to think of the 2 product differentiators listed previously 
        and to assume, that I can get access to the technology required to make it happen. Thus, for Listing Carousel, u can say, that the software project was conceived as a competitive advantage play
        Great ! I had a potential software project to work on ! What's next ? Well, as mentioned at the start of this section, the next stage was to do a feasibility study
        Recall that the purpose of conducting a feasibility study on the product concept is to vet the ROI for the project and to also do the research to see, whether the required technology was readily available or, if not, can it be created ? Let's briefly look at this next
   
        2) Analysis - feasibility study
        This stage in the project analysis is where the go / no-go decision will be made. The proper way to conduct a feasibility study is to prepare a business plan and present it to investors
        Why ? The reason why managers of a company go through the process of writing a business plan and showing it to investors (or to the VP, President, or CEO of the company-for internal software projects), 
        is because they need a document, that they can share with an investor to gauge the interest in the project. If the investors would be interested in making an investment, then it means, that the project has merit
        The perfect document for this, is a formal business plan, because it contains summary info on all the important things, investors would want to see:
            - Market analysis: is there room in the market for yet another similar product ?
            - What is the market potential ?
            - Competitive analysis: how is our product/service going to be different? Are we going to compete on cost, quality, or features ?
            - Required resources: what personnel does the project need ? And how many man-hours to build it and deliver it to market ?
            - Budgets: how much money in total should be budgeted for the project (IT, sales, operating costs and so on) ?
            - Financial projections: what revenues can be expected over the next 12 months, 2 years, 3 years and 5 years ? What is the break-even point ?
            - Exit strategies: how long do we operate the company for ? How do we get our investment out ?
        You may be asking yourself, if I actually prepared a detailed business plan for a software project, that was fairly small in size. The answer - of course ! Why ? 
        In short, I needed to see whether implenting the project was worth my time and money. Specifically, I spent the necessary time preparing a business plan for the following reasons:
        - Market analysis: as good as an idea may sound to u, u need to do your due diligence in being reasonably sure, that there is a need for yet another product or service in the market u are entering
          If there is room, then u have a potential opportunity. In my case, I believed that room existed for Listing Carousel and that it was sufficiently differentiated to give me a competitive advantage over the competing products in the market
        - Cost and time to develop: time and money are valuable commodities - and developing a software product / service will take both. Every dollar u invest in 1 project, means that u can't invest it in another
          And the same is true of your time. Every hour you spend on doing sth, means u gave that time up for doing sth else instead. So, choose where u place your resources wisely ! 
          In my case, I had some money earmarked for a fun project to do - so the money part was taken care of. How about the time ? This was a difficult decision for me. While I did not really have the time, 
          I liked the project and I have friends, that are real-estate agents - and so I decided, what the hell, let's go for it. So, I knew how much money I needed to invest and roughly how much time I had to invest as well
        - Projected revenues: just because the required resources (that is, time and money) I had to invest, were acceptable to me, it wasn't a done deal yet. The next step was to make some calculations to see, 
          whether I would make a profit over time and how much. If the ROI was high enough, it was a go-ahead. In my case, the ROI was actually not as good, as I wanted it to be - in fact, it was almost zero ! 
          In other words, I would just break even, if I was lucky. However, u also have to listen to your gut and my gut was telling me, that I may be able to sell the software service at some point, 
          which would make the project worthwhile. At the time of writing, I have not yet sold Listing Carousel, but it did start to make a little bit of a profit
        - Exit strategy: Before u embark on building any business - and I treated Listing Carousel as a standalone business - u have to think of an exit strategy. What is an exit strategy ? 
          It basically defines how u will divorce yourself of your obligations of operating and / or servicing the company. Companies don't run themselves and so unless u want to stay married to the company forever, 
          u need to have an exit strategy from the start. I can't take more space in this book to outline this in detail, but suffice it to say, I structured the company in such a way, where my exit strategy was baked in
        
        3) Requirement gathering
        This stage of the software project forms the basis of your project plan, which is what a project manager uses to keep the project on schedule and on budget
        Requirements are typically gathered from the end client (internal / external), but can also come from an idea board, if u are building sth new, that does not yet exist in the market
        Np. for Listing Carousel, I picked the brains of a few real-estate agent friends, telling them what I wanted to build and how I wanted to make it different from what they were already using
        Here is a partial list of what we came up with as requirements:
            - The ability to create a carousel-style photo viewer (1 per listing / property, with any number of photos in it)
            - The ability for the user to upload photos
            - The ability to annotate each photo (that is, a caption at the bottom of the photo)
            - The ability to flip the photo around to show a detailed description of what is shown on the photo
            - The ability for the user to link a photo to a carousel
            - The ability for the user to order / re-order the photos within a carousel
            - The ability for the user to post the carousel of the listing on Facebook
            - The ability for the user to post the carousel of the listing on Instagram
            - The ability to have a magic link manually placed on any website, that the user has access to, which opens the listing's carousel in a modal lighthouse in place
            - The ability to have a soundtrack play, while the listing's carousel auto-scrolls through the photos in it
            - Each carousel will have a unique short permalink assigned to it, so that the user can email / text it to whomever they like
        We won't build all these features into our example application, because there just isn't the space in the book to do so - but we will build the important ones
        The 2 features, that we'll omit are the magic link and the playing of the music soundtrack. I won't make any promises, but I may create a blog post on how to build the magic link on my blog, AngularMotion.io, in the near future
        
        5) Wireframes
        This stage of the process is where the look and feel of the application are planned and laid out. The following are the 12 wireframes for the pages we'll be building 
        (note: a couple of the wireframes were too long to have as one screenshot, such as for the Welcome page and so there is more, than 1 screenshot for them)
        We will be implementing some of these wireframes in the following sections and we will learn to implement some of the layouts and components in chapters to follow
    
        6) Implementation
        This is where the rubber hits the road. We're going to code up some of our web pages using the wireframes we just reviewed to help guide us
        We're also going to need a web server, so we can serve up our new pages in our browser, as we build them out
        
        a) Installing our interim web server
        We'll be using Node's built-in web server for our project from "Chapter 12 Integrating Backend Data Services" onward. But, since we've got a little while to go before we get to that point, we need to have a simple interim solution
        We've not spoken about browsers before, because there wasn't a need to do so - but now, there's a need. While it doesn't matter, which browser u use for viewing Angular applications, 
        it would be easier-though not essential - for us to use the same browser, while we work through this book together. My browser of choice, while I develop web applications, is Chrome
        As with most browsers, Chrome has a ton of extensions, that other developers have created, that do everything from providing subscription notifications to debugging tools and more
        You can search for and install extensions for Chrome from the Chrome Web Store at https://chrome.google.com/webstore/category/extensions. We'll be using Chrome and specifically, a few of its extensions, for a few things in this book
        The 1st order of business is to install a Chrome extension, that will help us serve up the pages we build for our application. It's called "Web Server for Chrome" and u can search for it and install it from the Chrome Web Store
        I didn't include the link to it directly, because the URL was incredibly long. This extension allows u to select a folder for where the files u wish to be served are located, as well as a port to listen on
        There are other options, that u can select as well. 1 common case option, that is enabled by default, is to have the extension automatically show the index.html file. Np. assuming you enter 8887 for the port number, 
        u would point your browser to http://127.0.0.1:8887 and would see, that your index.html page in the folder u specify, would automatically be served up in your browser
        Once u have these 2 settings configured, you're off to the races and can view the pages we create
        
        b) Welcome page
        The 1st wireframe we will implement using the Bootstrap components and grid layout is the Welcome home page
        Take a look at the following wireframe screenshot. We have a header section, that contains our application logo placeholder, navigation menu and Login and Try Now buttons on the right
        This is followed by a jumbotron header, that showcases the title of the application. Then, our content sections are divided, so that we can add our content to the page:
        We will now proceed to implement our code implementation of the preceding wireframe screenshot
        We are 1st going to implement the header section and we will use the <nav> tag to categorize all of our header section code, including the logo, menu and action buttons:
            <nav class="navbar navbar-default navbar-fixed-top">
                <div class="container">
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        <a class="navbar-brand" href="#myPage">Logo</a>
                    </div>
                    <div class="collapse navbar-collapse" id="myNavbar">
                        <ul class="nav navbar-nav mr-auto">
                            <li><a href="#features">Features</a></li>
                            <li><a href="#pricing">Pricing</a></li>
                            <li><a href="#about">About</a></li>
                        </ul>
                    </div>
                    <div class="collapse navbar-collapse ">
                        <ul class="nav navbar-nav navbar-right">
                            <li><a href="#features">Login</a></li>
                            <li><a href="#pricing">Try Now</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        In the preceding code, we are implementing a "nav" tag element and using the Bootstrap navbar classes, navbar-default, navbar-fixed-top, navbar-brand, navbarcollapse and so on
        These classes come with default functionality, that covers almost all aspects of a navigation section. 1 of the interesting things to note in the preceding code is the navbar-collapse class, 
        which helps in rendering various device screen resolutions automatically. We have also added a few menu links for features, pricing and about
        We have also added our action items, Login and Try Now Launch the page in the browser and we should see the output, as shown in the following screenshot:
        Next, we have to make our layouts for the content sections. The jumbotron and content sections. We will use the jumbotron class with a div section and, for the content sections, the Bootstrap grid column classes, row, col-sm-8 and col-sm-4:
            <div class="jumbotron text-center">
                <h1>The Smart way to showcase your listings</h1>
                <p>Simple, beautiful and wonderful app</p>
            </div>
            <!-- Container (About Section) -->
            <div id="about" class="container-fluid">
                <div class="row">
                    <div class="col-sm-8">
                        <h2>Annotate your prices</h2><br>
                        <h4>Some pictures aren't 1000 words and sometimes pictures don't do sth justice</h4><br>
                    </div>
                        <div class="col-sm-4">
                            <span class="glyphicon glyphicon-signal logo"></span>
                        </div>
                </div>
            </div>
            <div class="container-fluid bg-grey">
                <div class="row">
                    <div class="col-sm-4">
                        <span class="glyphicon glyphicon-globe logo slideanim"></span>
                    </div>
                    <div class="col-sm-8">
                        <h2>Our Values</h2><br>
                        <h4><strong>MISSION:</strong> Our mission lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</h4>
                        <br> <p><strong>VISION:</strong> Our vision Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud
                        exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
                        veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
                    </div>
                </div>
            </div>
        Now, let's analyze the preceding code to understand some of the important points. We are making use of the awesome Bootstrap grid utilities to create our application layout, 
        using the column classes to create the layout, which will render on various screen resolutions. Run the application in the browser and we should see the output, as shown in the following screenshot:
        Nice work, fellas, so far. We have just created our 1st Welcome page layout using the Bootstrap layout components. We will continue to use the same and build some more wireframes to make u comfortable
        In the next section, we will learn to create signup and login screens using the Bootstrap modal component
        
        c) Signup
        Next up, we will implement our signup and login pages using Bootstrap's awesome modal component. Take a look at the following wireframe. It's a simple modal window with some form field input elements:
        Let's go ahead and implement the code. The following is the sample code for creating the modal window:
            <div class="modal fade" id="signup-modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
                <div class="modal-dialog">
                    <div class="loginmodal-container">
                        <h1>Signup Account</h1><br>
                        <form>
                            <input type="text" name="1stname" placeholder="1stname">
                            <input type="text" name="lastname" placeholder="Last Name">
                            <input type="text" name="brokrage" placeholder="Brokrage">
                            <input type="text" name="user" placeholder="Username">
                            <input type="password" name="pass" placeholder="Password">
                            <input type="submit" name="login" class="login loginmodal-submit" value="Sign Up">
                        </form>
                        <div class="login-help">
                            <a href="#">Register</a> - <a href="#">Forgot Password</a>
                        </div>
                    </div>
                </div>
            </div>
        In the preceding code, we have used Bootstrap's modal component and modal classes modal and modal-dialog
        Inside the modal dialog content, we have created our signup form with the input form elements - 1st name, last name, brokerage, user and pass
        Launch the page in the browser and we should see the output, as shown in the following screenshot:
        That's a great start to building our application. In the next section, we will build our login page using the same Bootstrap modal component
        
        d) Login
        In the previous section, we have learned about creating the signup form inside a modal window. In this section, we will learn about creating a login screen inside the modal window
        The methodology and principle are exactly the same, as how we created the signup page. Take a look at the following login wireframe, which we are going to implement in just a bit:
        Time for some action. We are going to create a modal window 1st and we can bind a click event to open the dialog window:
            <div class="modal fade" id="login-modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
                <div class="modal-dialog">
                    <div class="loginmodal-container">
                        <h1>Login to Your Account</h1><br>
                        <form>
                            <input type="text" name="user" placeholder="Username">
                            <input type="password" name="pass" placeholder="Password">
                            <input type="submit" name="login" class="login loginmodal-submit" value="Login">
                        </form>
                        <div class="login-help">
                            <a href="#">Register</a> - <a href="#">Forgot Password</a>
                        </div>
                    </div>
                </div>
            </div>
        In the preceding code, we have implemented a modal window with yet another form, this time for a login feature with a number of form elements - a username and password with a submit button
        Launch the page in the browser and we should see the following output: Our application is almost taking shape now. I am sure, u are as excited as I am. Let's go ahead and implement the listings page
   
        e) Listings
        In previous sections, we have created our home page, signup and login pages using the Bootstrap components. In this section, we will create our listings page. Take a look at the following wireframe
        We have to loop through our listings and display a grid section, where we will display all the listings we have so far. Simple enough ? You bet:
        We will need to use Bootstrap's advanced layout and grid components to create the preceding layout. Take a look at the following sample code. We can achieve the preceding layout in multiple ways
        We can either use the Bootstrap grid columns to design the layout or, alternatively, we can make use of table elements to design the structure
        In this example, I will show you how to do it using the table elements and I will leave the grid structure to u as homework:
            <div class="container-fluid">
                <table class="table table-hover shopping-cart-wrap">
                    <thead class="text-muted">
                        <tr>
                            <th scope="col" width="150">Thumbnail</th>
                            <th scope="col">Caption</th>
                            <th scope="col">Property</th>
                            <th scope="col" width="200" class="text-right">Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <figure class="media">
                                <div class="img-wrap"><img src="https://via.placeholder.com/150" class="img-thumbnail img-sm"></div>
                                </figure>
                            </td>
                            <td> Master Bedroom </td>
                            <td> 789 Charelston Rd </td>
                            <td class="text-right"> <a title="" href="" class="btn btn-outline-success" ata-toggle="tooltip" data-original-title="Save to Wishlist">
                                <i class="fa fa-heart"></i></a> <a href="" class="btn btn-outline-danger">Remove</a>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <figure class="media">
                                    <div class="img-wrap"><img src="https://via.placeholder.com/150" class="img-thumbnail img-sm"></div>
                                </figure>
                            </td>
                            <td> Kitchen </td>
                            <td> 789 Charelston Rd </td>
                            <td class="text-right">
                                <a title="" href="" class="btn btn-outline-success" data-toggle="tooltip" data-original-title="Save to Wishlist">
                                    <i class="fa fa-heart"></i></a>
                                <a href="" class="btn btn-outline-danger btn-round">Remove</a>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <figure class="media">
                                    <div class="img-wrap"><img src="https://via.placeholder.com/150" class="img-thumbnail img-sm"></div>
                                </figure>
                            </td>
                            <td> Den </td>
                            <td> 789 Charelston Rd </td>
                            <td class="text-right">
                                <a title="" href="" class="btn btn-outline-success" data-toggle="tooltip" data-original-title="Save to Wishlist">
                                    <i class="fa fa-heart"></i></a>
                                <a href="" class="btn btn-outline-danger btn-round">Remove</a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div> <!-- card.// -->
        In the preceding code, we have created a container using the container-fluid class and inside the container, we have created a table and rows structure to display our listings
        In a more practical scenario, the data will always come from the backend APIs / services. For our example and for learning purposes, we have stubbed the data here
        Launch the page in the browser and we should see the output, as shown in the following screenshot:
        If u see the output as shown in the preceding screenshot, give yourself a pat on the back. We have made great progress in our learning. So far, we have created four pages using various different Bootstrap components and grid layouts
        In the next section, we will explore some of the other wireframes for the application, which I will leave it for u to practice. Most of the wireframes will use the same components, layouts, grid layouts

        f) Create listing
        In this section, I am sharing with u the wireframe for the "Create Listing" page. The Create Listing page can be easily created using the Bootstrap components and layout
        Instead, we will learn to implement this using Flex-layout in the next chapter. The following is the wireframe for your reference:
        In the next section, we will see the design and wireframe details of the Edit Listing page
        
        g) Edit listing
        In this section, we will learn about the design and wireframes for the Edit Listing screen. If u look carefully, the Edit Listing page is similar to the Create Listing page, except, the data is populated on load
        Again, like the Create Listing screen, we will design the Edit Listing page using Flexlayout in the next chapter

        h) Wireframes collection
        In this section, we will see the design wireframes for other pages, which we will create in chapters to come. The following is the design wireframe for the Listing Preview page:
        The following is the design wireframe for the property details. If u notice, we are going to use the same Bootstrap's modal window component. When we open the modal window, we should see the property details:
        Now, we will learn how to design the wireframe for the Photos page. If u look carefully, the layout structure looks familiar to the Listings page
        We will have to create a reusable design using the common libraries, which can be reused across various pages and templates:
        Next up is the Upload Photo page. We will again have to create a modal window component and provide a file upload option, through which we can upload photos easily:
        Now, let's move on to the Edit Photo wireframe. Yet again, we are making use of Bootstrap's modal window component to design our Edit Photo page. We will use Angular's data binding to bind the data in the modal window:
        Last, but not least, we will explore the Photo Preview page. We can display the photos using the modal window Bootstrap component. We will close the common action buttons to close or edit the modal windows:
        That was quite a bit of work we have done in this chapter, as we learned about the Bootstrap grid and layout components
        We have created a few pages as part of our handson learning examples and designed our wireframes that we will use in our application

        Summary
        This chapter was packed with all kinds of goodies. You should now understand the example application, that we'll be building, the high-level game plan for the phases of our build and the 5-step process we're going to take for the 1st phase of our build
        We then moved on to what Sass is and a few of its features, that help us with creating our CSS for the application. We will study the tools to help u, when you're writing the Sass for your applications
        Next, we saw what Bootstrap is and how to integrate it into your applications. We studied what Bootstrap's grid is and the basics for how to use it, along with some of Bootstrap's components and how to use them
        Lastly, we studied the evolution of software projects, from inception to implementation. Here, we covered the different types of analysis, the gathering of the requirements and some use cases
        We also covered wireframes, went into detail on the goal of each wireframe and the basic design principles (that were mentioned during the description of the wireframes)
        So far in the book, with the exception of the quick to-do app we've built in Chapter 1, Quick Start, we have not even touched Angular. This will change - starting with the next chapter, Chapter 4 Routing
        In this chapter, we will create the Angular shell for our application using the CLI (as we did at the beginning of the book). However, we're going to be adding routing to it
        I'll explain what routing is and how to configure routing for our application, as we work through it. So, before u turn the page, pat yourself on the back, stretch a little and maybe pour
        yourself another glass of your favorite beverage. Well done, my fellow budding Angular gurus. With these 1st 3 chapters behind u, u are now ready to meet Angular !

    ■ CHAPTER 4: ROUTING

        The previous chapter was a monster, but it was needed to give u a couple of crash courses on 2 of the technologies you're likely to use / should definitely consider using
        in your web development projects (and this is true, whether / not your project leverages Angular). Additionally "Chapter 3 Bootstrap - Grid Layout and Components" was also there to help set the stage for the rest of the book
        This chapter is much smaller by comparison, but it marks the true beginning of our journey into Angular. Each chapter from this point forward, even "Chapter 12 Integrating Backend Data Services", 
        where the primary focus is on building backend services in Node and MongoDB, has Angular material in it (specifically, how to use Angular's HTTP client and how to wrap your code up in an Angular service)
        1 other note about this chapter, that I'd like to point out, is that most books on Angular don't introduce routing, before they introduce Angular templates and components, which is fine, but we won't be following that approach
        Although routing and component templates are inextricably linked together, which is the likely reason, that most books discuss routing after components, understanding components is not at all a prerequisite for understanding routing
        More generally, most programming books try and present all the material and concepts in advance and then circle back at a later time to try and implement them in some fashion
        1 of the problems with this approach, is that it goes against the way our brains work, when assimilating and internalizing new info. It is usually better to immediately use new info, in small incremental steps
        This book focuses on being as practical as possible, as soon as possible and in a way, that maximizes the retention and understanding of new material
        So, in order to accomplish this, we'll be building our example application together throughout the book, learning the topics, as we need them and not before
        This means, that we will often implement things, that haven't yet been fully explained. They will be explained to u, as we implement them / immediately afterward - when your brain is primed and looking for patterns to forment understanding
        So, don't worry about diving in head 1st - it's usually the best way. I'm your guide and I am with u to all the way to the end of the book. Here is what we'll be covering together in this chapter:
            - Defining what routing is for Angular applications
            - Creating the shell of our application, as well as its 1st few components, using the CLI
            - Configuring routing for our application
            - Taking a look at route redirection, parameterized routes and route guards
            - Completing the routing configuration for our application
            - Taking a look at routing strategies
        
        WHAT IS ROUTING IN ANGULAR ?
(B)     Routing in Angular is simply a set of rules, that map a requested URL to a component. This tends to confuse people, that are coming to Angular from another technology, that has routing, 
        especially a technology, that is not an SPA (single-page application) framework. Let me explain this a bit.
        Angular applications only have 1 page (hence, the term single-page application), as we'll see in a moment, when we create our Angular application
(B)     Angular components have templates, which are standard HTML elements, that are used to design the layout of the structure for presentation. And as we'll see in "Chapter 6 Building Angular Components" - they also have styles
(B)     As was mentioned in the 1st chapter of the book, Angular applications can be thought of as trees of components
        This is to say, that components can contain other components and this nesting of components can continue as much, as is required for your application
(A)     So, although components have templates (note: some web frameworks refer to web pages as templates), Angular's routing maps URL paths to components, not to web pages / templates
        When the template of the component, that the requested URL is rendered (and we'll see how this happens in just a moment), not only is that component's template rendered, but all nested components' templates are also rendered
        The top-level component, that is mapped to by Angular's router, may contain other child components, which in turn can contain other child components and so forth. This is what is meant by a tree of components
(B)     For the most part, data in Angular applications flow from the parent components to their immediate children. It does not flow from the parent component to its grandchild component
        Moreover, data does not flow upward. It is a unidirectional flow - parent to child. I say for the most part, because there are techniques and libraries, that change some of this behavior
(B)     Np. components can talk to each other through an intermediary, which we'll look at later on in the book. However, by design and without outside intervention, data flows from parent to child
        You'll become familiar with all of this, as we progress through the book
(A)     All u have to understand at this point, to understand routing, is that URLs are mapped to components, instead of to pages, because Angular applications only have 1 page
        The only page in Angular apps is the "index.html" page, which is in the "app" directory
        In Chapter 6 "Building Angular Components" we'll see how our default component gets loaded into the "index.html" page. For now, let's get back to routing
        
        CREATING OUR APPLICATION'S SHELL USING THE CLI
        This is where it all starts. We have now reached the point, where we are going to use the CLI to create our application's starting point, as well as the 1st bunch of components we'll need to connect them to our routing configuration
        We've looked at how to install the CLI and we've even created our 1st Angular application together - although our todo application was a tiny 1, just to get our feet wet - back in Chapter 1 Quick Start
        If u haven't yet installed the CLI, you're definitely going to want to do that now. Once you've done that, fire up your CLI and let's begin !
        The 1st order of business is to create a directory on your machine, where you're going to place all your Angular projects. Don't create a directory for our example application, because the CLI will do that for u
        Simply create a folder on your filesystem and navigate to it from your command line (if your OS is Windows) / Terminal (if your OS is a Mac or Linux)
        For brevity, from here on in, I'll be referring to it as your Terminal and the folders as directories.
        Next, we're going to use our CLI to create the skeleton of our application (that is, the root directory) and all the accompanying files and sub-directories, that the CLI creates for us, that are needed for an Angular application
(B)         ng new realtycarousel         This will take about a minute to complete             Would you like to add Angular routing ? Yes          Which stylesheet format would you like to use ? SCSS
            ng new realtycarousel --style=scss --routing            albo pełne polecenie
        If u see Project "realtycarousel" successfully created, as the last line of output, u should now have a directory named "realtycarousel", that will contain all our application files
        The output of the preceding command is displayed in the following screenshot:
            cd realtycarousel          let's now test, that we can run it. Navigate to your realtycarousel directory with the "cd" command
(B)         ng serve                   next, start our Angular application with the CLI's server command
        You should see a bunch of lines output to your Terminal. If 1 of the lines is sth similar to ** NG Live Development Server is listening on localhost:4200
        - open your browser on http://localhost:4200/ ** and the last line is webpack:     Compiled successfully, then u should open a browser and point it to http://localhost:4200
        If u see a page with the Angular logo, this means, that everything was set up correctly. You now have an empty Angular application. You can press Ctrl + C to stop the CLI's development server
        Next, let's add several components, which we will reference in our routing configuration. Again, don't worry about components for now. We will look at them in depth in "Chapter 6 Building Angular Components" and "Chapter 7 Templates, Directives and Pipes"
        Run the following list of CLI commands, 1 at a time:
(B)         ng g c home        ng g c signup        ng g c login        ng g c logout        ng g c account        ng g c listings        ng g c createListing        ng g c editListing        
            ng g c previewListing                   ng g c photos       ng g c uploadPhoto   ng g c editPhoto      ng g c previewPhoto    ng g c pageNotFound
        The output of the 1st command is given in the following screenshot. We should see a similar output, when we create all the other components.
        We now have the 1st set of components, that we need. Although their templates are empty for now, this will be good enough to enable us to configure routing for our application
        Since we'll be using Bootstrap for a few things in our application, such as its navigation bar and its responsive grid, we need to install Bootstrap along with its dependencies
(B)     In "Chapter 3 Bootstrap - Grid Layout and Components", we simply referenced a few CDN URLs in the header of our index.html page, in order to be able to use Bootstrap
(B)     However, we will now install Bootstrap differently - we'll be using "npm". You will need Node.js installed on your system, in order to use the node package manager (npm)
            npm install bootstrap@4 jquery popper --save            to install Bootstrap + jQuery + Popper
        We have installed the libraries and now it's time to include them in our config file, so they are available throughout the application
        Open up the angular.json file and include the stylesheet and JS files in the respective sections:
            "styles": [
                "styles.css",
                "./node_modules/bootstrap/dist/css/bootstrap.min.css"
            ],
            "scripts": [
                "./node_modules/jquery/dist/jquery.min.js",
                "./node_modules/bootstrap/dist/js/bootstrap.min.js"
            ]
        The screenshot shows the edited angular.json file:        All set!
        We now have the core files, that we need to be able to set up routing for our application. We also made sure to install Bootstrap, because we're going to create our navigation bar for our application in this chapter
        Moreover, our navigation links will contain special tags, that Angular uses for routing, which is another reason, why we needed to install Bootstrap at this point
        Let's open our project using our IDE (again, it's easiest, if you're using Visual Studio Code - but u can use whichever IDE u prefer), so we can take a look at the project structure
        Additionally, in the next section "Completing our route configuration", we'll be making changes to a couple of files for setting things up, so u'll want to have a way to easily open and edit those files
(B)     With the project now open in your IDE, navigate to the "app" directory, which is located within the src directory. As Angular developers, we'll be spending the vast majority of our time within the "app" directory
(B)     Inside the "app" directory, u will find a number of files, that all start with "app". These files make up the root component (that is, the "app" component) in our application 
        and we're going to be examining, what each of these files does, when we come to "Chapter 6 Building Angular Components", where u will become very familiar with Angular components
        You will see many subdirectories in the app directory - 1 for each component we created just a few moments ago, such as for about "account", "home" and so on
        Remember, the language Angular applications are written in TS, which is what the .ts file extension stands for. Let's roll up our sleeves and configure routing for our application
        
        1ST THINGS 1ST - BASIC CONCEPTS
        In this section, we will quickly touch base and get an overview of some of the basic concepts, before we start adding routing to our Angular apps
        In the basic concepts, we will learn about "Base Href" / "RouterLink" / "RouterLinkActive", which we will need to implement in our templates, while working with Angular routing
        
        Base Href
        Every Angular application, in order to compose the links inside the app, should have "base href" defined at the parent level
        Open the application generated by the Angular CLI and look inside the "index.html" file. We will see the "base href" defined to /, which resolves to be the root or top-level hierarchy
        The following screenshot shows the default "base href" configuration, as generated by the Angular CLI

        ROUTERLINK + ROUTERLINKACTIVE
        In "Chapter 7 Templates, Directives and Pipes", we will learn in detail about components, directives and templates
        For now, just understand that, like the "anchor" element and "href" attribute in HTML5, Angular provides a way to bind the links and the URL resource:
            <nav>
                <a routerLink="/home" routerLinkActive="active">Home</a>
                <a routerLink="/listings" routerLinkActive="active">Listings</a>
            </nav>
        In the preceding code, we are adding 2 links. Notice, that we have added the "routerLink" attribute to the links, which will help us bind the value of /home and /listings, respectively
        Also, notice, that we have added the "routerLinkActive" attribute and assigned the value as "active". Whenever a user clicks on the link, the Angular router will know and make it active
   
        CONFIGURING ROUTES FOR OUR APPLICATION
(B)     It's time to add Angular routing to our application. We have 2 options for implementing routing:
            - we can use the Angular CLI to add routing during the creation of the project
            - or we can add Angular routing manually into our applications
        1st, let's explore the easy way, using the Angular CLI to add routing. The Angular CLI provides us with an easy way to add routing capabilities to our Angular application
(B)     While generating a new project, the Angular CLI will prompt us to select, if we want to add routing to our app
        The following screenshot shows the option displayed in the CLI for adding Angular routing:
        When we choose the option to add routing in our app, we are using the Angular CLI to create files, import the required modules and create the route's rulesets
(B)     Now, let's add routing to our project manually. Let's see how we can configure routing in our app. In order to configure our routing:
        
        1) Open the app.module.ts file
        
        2) Add the following "import" statement to the "import" section at the top of the file:
            import { NgModule } from '@angular/core';
            import { Routes, RouterModule } from '@angular/router';
        "RouterModule" contains the router service and router directives. The "Routes" module defiles the routes type (remember, TS adds variable typing to JS)
        
        3) Write a few routes and ruleset in the app-routing.module.ts file:
            const appRoutes: Routes = [
            { path: 'home', component: HomeComponent },
            ...
            { path: '', redirectTo: '/home', pathMatch: 'full' },
            { path: '**', component: PageNotFoundComponent }
            ];
        This code only shows 3 mappings:        Mapping for HomeComponent       Mapping for a redirection       Mapping for a wildcard, or catch-all, the URL request
        a) The 1st mapping object is the simplest case. A URL path (that is, the part of the URL, that comes after the domain name) maps to 1 component, without any parameters 
           (note routes can be parameterized and we'll look at that in the Parameterized routes section shortly)
(B)        What this route does, is instruct Angular to render the HomeComponent template, when the path in the requested URL ends in the home
        b) The 2nd mapping object is an example of how to get 1 path to redirect to another URL, and, thus, route. This is typically referred to as route redirection
(B)        In our case, the path is an empty string, which means, that when only the domain name is entered into the browser location bar, Angular's routing mechanism will redirect the request 
           (that is, change the path in the URL) to /home. And since there is a mapping object, that deals with /home, it will get triggered, thus rendering the HomeComponent template
           This is a common practice for websites - entering just the domain name typically brings the user to the home / index web page
           In our case, since we're building a SPA (which is what Angular web applications are), there is no home page, but rather a home component, 
           meaning that the home component's template is rendered to simulate a home page
        c) The 3rd mapping object is an example of a wildcard match and is placed as the last mapping object
(B)        When Angular's routing mechanism parses the requested URL, it compares it to the mapping objects from the top down. If the URL does not match any of the mapping rulesets, this last mapping object is triggered
(B)        What this means for our application is that, if there are no matches, the "PageNotFoundComponent" template will be rendered
        
        4) Now it's time to import our appRoutes - this is how we tell Angular about our routes. appRoutes is a constant, that holds our route mapping:
            imports: [
                BrowserModule,
                RouterModule.forRoot(appRoutes)
            ]
        
        5) Finally, we will need to import the app-routing.module.ts file into app.module.ts.
        
        The complete code listing of the app-routing.module.ts file is in the "Completing our route configuration section" later in this chapter
        We have added the routes directly into "app.module.ts" file. It's a good practice to always separate out the route config file separately
(A)     Even better, always use the Angular CLI to add routing directly, when u create the project. That's it - we have implemented routing in our project
        In the next section, we will learn in detail about adding more routes, adding parameters to our routes and creating child routes

        PARAMETERIZED ROUTES
        Parameterized routes are routes that have a variable value as part of the URL path. For
        instance, a common example of this is when we reference sth by its ID, as in the
        following:
        /listing/23 (shows property #23 in our realty site)
        /listing/55 (shows property #55 in our realty site)
        /listing/721 (shows property #721 in our realty site)
        Clearly, having to configure potentially hundreds of routes would not only be tedious,
        inefficient and error-prone, but the maintenance of these routes (that is, removing routes
        and adding new ones as the inventory of property listings changed) would be troublesome.
        Fortunately, Angular allows for parameterized routes, which solve issues such as these.
        Take a look at the updated routes in the following code snippet:
        const routes: Routes = [
        { path: 'home'},
        { path: 'listings/:id', component: ListingDetailsComponent },
        { path: '', redirectTo: '/home', pathMatch: 'full' },
        { path: '**', component: PageNotFoundComponent }
        ];
        If you look carefully, in the preceding routes we have added one more route, which
        captures the id of the listing and we are also mapping it to the
        ListingDetailsComponent component.
        In other words, we can also say that we have created a generic template for listings and,
        based on the dynamic value passed during runtime, the respective data will be displayed
        by the component.
        That was easy. What if we have a more complex scenario that involves creating child
        routes? Read on.
        
        CHILD ROUTES
        The routes we have created so far are very easy and straightforward use cases. In complex
        applications, we will need to use deep linking, which refers to hunting down a link into
        many levels under.
        Let's take a look at some examples:
        /home/listings (shows listings inside home)
        /listing/55/details (shows the details of listing #55)
        /listing/721/facilities (shows the facilities of listing #721)
        That's where child routes can be very handy for us to use.
        Routing Chapter 4
        [ 149 ]
        In the following example, we are creating a child route inside the home route path:
        const routes: Routes = [
        { path: 'home',
        component: HomeComponent,
        children: [
        { path: 'listings',
        component: ListingsComponent}
        ]
        },
        {path: 'listings/:id', component: ListingDetailsComponent },
        {path: '', redirectTo: '/home', pathMatch: 'full'}
        ];
        In the preceding code, we are defining children for the home path and, again, we are
        specifying the path and component, which will correspond to the child route path.
        OK, fine. This is good stuff.
        What if we want to add some validation before a user can access a particular route? like a
        bouncer outside a club? That bouncer is called a route guard.
        
        ROUTE GUARDS
        As in most web applications, there are resources (that is, pages/component templates) that
        are accessible to everyone (such as the Welcome page, Pricing page, About Us page, and
        other informational pages) and there are other resources that are only meant to be accessed
        by authorized users (such as a dashboard page and an account page). That's where route
        guards come in, which are Angular's way to prevent unauthorized users from accessing
        protected parts of our application. When someone tries to access a URL that is reserved for
        authorized users, he will typically be redirected to the public home page of the application.
        In traditional web applications, the checks and validations are implemented in the serverside
        code and there is practically no option to validate whether the user can access the page
        at the client side. But using the Angular route guard, we can implement the checks at the
        client side without even hitting the backend services.
        The following are the various types of guards available that we can use in our applications
        to enhance security for authorization:
        CanActivate: Helps to check whether the route can be activated or not
        CanActivateChild: Helps to check whether the route can access child routes or
        not
        CanDeactivate: Helps to check whether the route can be deactivated or not
        Resolve: Helps to retrieve route data before activation of any route
        CanLoad: Verifies whether the user can activate the module that is being lazy
        loaded
        And before we jump into our hands-on exercise, I want to give you a quick overview of
        Angular route guards, such as where to use them, how to use them, what's the return type,
        and so on. Route guards are always injected as a service (that is, we have @injectable and
        we will need to inject it). The guards always return a Boolean value, true or false. We can
        make our route guards return the observables or promises, which internally get resolved
        into a Boolean value.
        We will continue to work on and expand the example we have created in the previous
        section. We are going to add a new component and call it CRUD. As a user, when you try
        to access the crud route, we will check when the route returns true. We will allow the user
        to navigate and see the template; otherwise, the application will throw an error prompt.
        Let's dig right into the code to implement route guards. Just as we learned how to generate
        a component or a service, we can use the ng command and generate a route guard. In the
        Terminal, run the following command:
        ng generate g activateAdmin
        We have just generated a new route guard named activateAdmin. The output of the
        preceding command is displayed here:
        Let's take a look at the files generated by the Angular CLI. Open the activateadmin.
        guard.ts file in the editor. Take a look at the default code generated in the file:
            import { Injectable } from '@angular/core';
            import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from
            '@angular/router';
            import { Observable } from 'rxjs';
            @Injectable({
            providedIn: 'root'
            })
            export class ActivateAdminGuard implements CanActivate {
            canActivate(
            next: ActivatedRouteSnapshot,
            state: RouterStateSnapshot): Observable<boolean> | Promise<boolean>
            | boolean {
            return true;
            }
            }
            The 1st few lines are just importing the required CanActivate,
            ActivatedRouteSnapShot and RouterStateSnapshot modules from the Angular
            router. Next, we know that since route guards are injectable, by using the @injectable
            decorator, we are informing Angular to inject it inside the root. And we are creating a
            class, ActivatedAdminGuard, that has a method already created inside it named
            canActivate. Note that this method has to return a Boolean value, either true or
            false. We have created our route guard, so now let's create a route now in our approuting.
            module.ts file.
            Take a look at the updated code of the app-routing.module.ts file:
            import { NgModule } from '@angular/core';
            import { Routes, RouterModule } from '@angular/router';
            import { CrudComponent } from './crud/crud.component';
            import { LoginComponent } from './login/login.component';
            import { RegisterComponent } from './register/register.component';
            import {ActivateAdminGuard } from './activate-admin.guard';
            const routes: Routes = [
            { path: 'login', component: LoginComponent },
            { path: 'register', component: RegisterComponent },
            { path: 'crud', component: CrudComponent,
            canActivate:[ActivateAdminGuard] }
            ];
            @NgModule({
            imports: [RouterModule.forRoot(routes)],
            exports: [RouterModule]
            })
            export class AppRoutingModule { }
        Note that in the routes, we have added the canActivate interface and, for our crud path, when we try to launch the crud route, since the canActivate method is returning true, the user will be able to see the component template
        Now, go ahead and set the value to false and find out what happens. If u see the application's routing go back to base href, don't be surprised

        COMPLETING OUR ROUTE CONFIGURATION
        As promised in previous sections, I will share the entire source code of AppModule, including the route configurations. The following code may look lengthy or scary, but trust me, it's actually very simple and straightforward
        During the course of learning this chapter, we have generated many components and created their route paths. We are just importing the components and updating appRoutes with their paths. That's it. I promise
        Here is the complete listing of the "app.module.ts" file:
            import { BrowserModule } from '@angular/platform-browser';
            import { NgModule } from '@angular/core';
            import { RouterModule, Routes } from '@angular/router';
            import { AppComponent } from './app.component';
            import { HomeComponent } from './home/home.component';
            import { SignupComponent } from './signup/signup.component';
            import { LoginComponent } from './login/login.component';
            import { ListingsComponent } from './listings/listings.component';
            import {ListingDetailsComponent } from './listing-deatails/listingdetails.component';
            import { EditListingComponent } from './edit-listing/editlisting.component';
            import { PreviewListingComponent } from './preview-listing/previewlisting.component';
            import { PhotosComponent } from './photos/photos.component';
            import { UploadPhotoComponent } from './upload-photo/uploadphoto.component';
            import { EditPhotoComponent } from './edit-photo/edit-photo.component';
            import { PreviewPhotoComponent } from './preview-photo/previewphoto.component';
            import { PageNotFoundComponent } from './page-not-found/page-notfound.component';
            import { FeaturesComponent } from './features/features.component';
            import { PricingComponent } from './pricing/pricing.component';
            import { AboutComponent } from './about/about.component';
            import { SupportComponent } from './support/support.component';
            import { AccountComponent } from './account/account.component';
            import { LogoutComponent } from './logout/logout.component';
            const appRoutes: Routes = [
            { path: 'home', component: HomeComponent },
            { path: '', redirectTo: '/home', pathMatch: 'full' },
            { path: 'signup', component: SignupComponent },
            { path: 'login', component: LoginComponent },
            { path: 'logout', component: LogoutComponent },
            { path: 'account', component: AccountComponent },
            { path: 'features', component: FeaturesComponent },
            { path: 'pricing', component: PricingComponent },
            { path: 'about', component: AboutComponent },
            { path: 'support', component: SupportComponent },
            { path: 'listings', component: ListingsComponent },
            { path: 'listing/:id', component: ListingDetailsComponent },
            { path: 'listing/edit', component: EditListingComponent },
            { path: 'listing/preview', component: PreviewListingComponent },
            { path: 'photos', component: PhotosComponent },
            { path: 'photo/upload', component: UploadPhotoComponent },
            { path: 'photo/edit', component: EditPhotoComponent },
            { path: 'photo/preview', component: PreviewPhotoComponent },
            { path: '**', component: PageNotFoundComponent }
            ];
            @NgModule({
            declarations: [
            AppComponent,
            HomeComponent,
            SignupComponent,
            LoginComponent,
            ListingsComponent,
            CreateListingComponent,
            EditListingComponent,
            PreviewListingComponent,
            PhotosComponent,
            UploadPhotoComponent,
            EditPhotoComponent,
            PreviewPhotoComponent,
            PageNotFoundComponent,
            FeaturesComponent,
            PricingComponent,
            AboutComponent,
            SupportComponent,
            AccountComponent,
            LogoutComponent
            ],
            imports: [
            BrowserModule,
            RouterModule.forRoot(appRoutes)
            ],
            providers: [],
            bootstrap: [AppComponent]
            })
            export class AppModule { }
        We have just created our routes, but we will need to update our template file by creating a few links that will have the path to the aforementioned-defined routes
        1 thing, that's most important in any application is a well-designed menu, which helps guide users and adds to a good user experience
        Using the Bootstrap nav component, we will design a menu for our application in the next section
        
        BOOTSTRAP NAVIGATION BAR AND ROUTER LINKS DIRECTIVES
        Just before we cover a couple of routing strategies to wrap up this chapter, let's circle back and create our Bootstrap navigation bar for our application
        If u recall from the previous chapter, Chapter 3, Bootstrap - Grid Layout and Components, I had mentioned, that we'll be covering the Bootstrap navigation component in this chapter
        The reason for this is that we're going to be tying our navigation bar to our routing by using routing directives as the menu links and so the best place to cover that is in this chapter, since it falls into the domain of routing
        In the previous section, I gave you homework to enter the route path URL manually in the browser bar to see the routes working, in this section, we will add all the route URLs to the Bootstrap navbar component, 
        so that the user can just click and navigate instead of typing manually. At the starting of the chapter, we briefly touched upon routerLink and routerLinkActive. Now it's time to see them in action
        Let's take a look at the app.component.html file, which is the template of our app component. If you are familiar with the notion of master pages in ASP.NET, or a layout page in Rails, 
        then you can consider the app component template as the equivalent for Angular applications. This is because the app component is the top-level component in the tree of components that will form our application
        The reason I brought up the notion of a master layout is that whatever HTML is inserted into it is preserved by the server by it rendering the called page within the layout page
        While this is not what happens in Angular, since it's not a server-side technology, it does hold true in concept. What I mean by this is that whatever HTML we insert into the app component's template, 
        it is generally still visible when other components are rendered within it. This makes the app component template a perfect place to hold our navigation bar, 
        since it'll always be visible regardless of what component template is selected to be rendered by our routing rulesets for a given URL that is requested by our users
        Here is the code listing for our app.component.html file:
            <div>
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="/">LISTCARO</a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav mr-auto">
                            <li routerLinkActive="active" class="nav-item"><a routerLink="/" class="nav-link">Home</a></li>
                            <li routerLinkActive="active" class="nav-item"><a routerLink="photos" class="nav-link">Photos</a></li>
                            <li routerLinkActive="active" class="nav-item"><a routerLink="listings" class="nav-link">Listings</a></li>
                            <li routerLinkActive="active" class="nav-item"><a routerLink="features" class="nav-link">Features</a></li>
                            <li routerLinkActive="active" class="nav-item"><a routerLink="pricing" class="nav-link">Pricing</a></li>
                            <li routerLinkActive="active" class="nav-item"><a routerLink="about" class="nav-link">About</a></li>
                            <li routerLinkActive="active" class="nav-item"><a routerLink="support" class="nav-link">Support</a></li>
                            <li class="nav-item dropdown">
                                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">User name</a>
                                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                                    <a routerLink="account" class="dropdown-item">Account</a>
                                    <div class="dropdown-divider"></div>
                                    <a routerLink="logout" class="dropdown-item">Log out</a>
                                </div>
                            </li>
                        </ul>
                        <form class="form-inline my-2 my-lg-0">
                            <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Log In</button>
                            <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Try Now</button>
                        </form>
                    </div>
                </nav>
                <br/>
                <router-outlet></router-outlet>
            </div>
        Take a deep breath and let's analyze the preceding lines of code. We are using both Angular directives and attributes, along with Bootstrap built-in classes. So let's begin:
        We are creating a menu navbar element, <nav>, provided in Bootstrap and assigning the built-in navbar classes, navbar-expand-lg navbar-light bglight
        We are also creating an element and placeholder for the logo of our application using the navbar-brand class. Using the navbar-nav class, we are defining a collection of links
        We are adding few links using the anchor tag, <a> and assigning the navlink class, which will form the links in the menu section
        We are also creating a drop-down menu using the dropdown-menu class and adding items to the menu using dropdown-item
        For Angular directives and attributes, we are using routerLink and routerLinkActive and, as explained in the 1st thing 1st - basic concepts, section, the routerLink attribute is used to bind the URL resource of the link
        To highlight the active link, we are using the routerLinkActive attribute. You will notice that for all links, we have assigned the attribute value as active
        Angular at runtime will detect the link clicked and will highlight it. Awesome, good job so far. We have implemented a nav menu for our application. We are just one step away from seeing our application in action

        SPECIFYING THE LOCATION FOR RENDERING THE COMPONENT TEMPLATES
        We need to tell Angular where we want the component templates, for the mapped components in our routing rulesets, to be displayed. For our application, we want to have the components that the router calls upon to be rendered under our navigation bar
        Angular has a directive for doing this, <router-outlet>, which is defined in RouterModule. Under the HTML we added for creating our Bootstrap navigation bar, add this following line of HTML:
            <router-outlet></router-outlet>
        That's all that is needed to tell Angular where the components that are called upon by the routing service should be rendered
        
        RUNNING OUR APPLICATION
        Now that we have completed configuring routing for our application, let's take it for a quick spin. Do u remember how to build and start our Angular application? Right! Use the CLI and issue the serve command like this:
            ng serve
        Make sure you are in the application's root folder when you do this. A shortcut for starting the application and opening your browser to localhost in one fell swoop, is issuing the ng server command with the open option:
            ng serve --open
        What u should see is that the URL in the browser's location bar is pointing to http://localhost:4200/home, which is Angular routing at work
        The ng serve command with the open option issued the http://localhost:4200 URL, but this triggered the route redirection to /home. Pretty cool, huh ?
        When we run the application, we should see the output shown in the following screenshot:
        In the next section, we will learn about some of the routing strategies we can implement in our apps
        
        ROUTING STRATEGIES
        There are two client-side routing strategies in Angular:        HashLocationStrategy (typically used for client-side purposes, such as anchor tags)
        PathLocationStrategy (this is the default)
        To enable HashLocationStrategy, in the app.module.ts file, where we have RouterModule.forRoot(appRoutes), append { useHash: true } as the 2nd parameter in the forRoot method. This is what it should look like:
        RouterModule.forRoot(appRoutes, { useHash: true })
        URLs with HashLocationStrategy have a hash sign (#) in their path. Here is an example:
        http://madeuplistofpeople.com/superheros#cloudman
        The preceding URL represents a get request to http://madeuplistofpeople.com/ superheros to the server
        Everything from the hash onward is not part of the request, because the browser only sends everything in the browser's location bar, to the left of the hash sign, to the server
        The #cloudman portion of the URL is used exclusively by the client, and, typically, this is used by the browser to automatically scroll down to the anchor tag on the page 
        (in this case, to the anchor tag with a name attribute of cloudman)
        1 use of the HashLocationStrategy strategy is for using the hash sign to store application state, which is convenient for implementing client-side routing for an SPA
        As an example, consider the following URLs:     http://madeuplistofpeople.com/#/about           http://madeuplistofpeople.com/#/search        http://madeuplistofpeople.com/#/contactus
        This URL pattern is great for an SPA because the only request going to the server is http://madeuplistofpeople.com which is essentially one page
        The client side will handle the different hash fragments (that is, from the hash sign to the end of the right-hand side of the hash sign) in whichever way it was programmed to
        To wrap up this section, an important concept of PathLocationStrategy is that Angular takes advantage of an HTML5 history API called pushstate
        We can change the URL using the pushstate API while suppressing the traditional default action by the browser to send the new request (that is, the altered URL) to the server
        This makes it possible to implement client-side routing without resorting to using a hash sign (#). This is why it is the default client-side routing strategy in Angular
        However, there is a downside. If the browser were to be refreshed, a request would be made to the server, which would reset your application with whatever the server sent back
        In other words, your application would lose its state, unless you had implemented local storage strategies

        SUMMARY
        This was a fairly short chapter, but we still covered a lot of ground. In this chapter, we created the skeleton for our application, including creating the components that we had our routes mapped to
        We then went through a step-by-step process of configuring routing for our application. This included importing the two required modules (that is RoutingModule and Routes), 
        coding up routing rulesets in the form of mapping objects and specifying where the routed components were to be rendered.
        We also installed and integrated Bootstrap into our application and created our Bootstrap navigation bar in our root component's template. We then took a look at how to make Angular aware of installed node packages, 
        Bootstrap and jQuery in particular, since that is how we installed Bootstrap and its dependencies (that is, jQuery and Popper).
        Although we didn't make use of parameterized routes and route guards in this chapter, we mentioned them here because we'll be making use of them later in the book-in Chapter 12, 
        Integrating Backend Data Services and Chapter 14, Advanced Angular Topics-and in the spirit of the book, discussing things at the time we need them and not before, we are deferring their demonstration until the appropriate times
        And to wrap this chapter up, we took a look at the two client-side routing strategies that Angular lets us choose from
        We've mentioned the word components over and over again in this chapter, since routing maps URL paths to components. We've even created several components using the CLI, but we've spent no time understanding components
        That's perfectly fine because, as was mentioned, you didn't need to understand components in order to understand routing
        Now that we have routing under our belt, we'll be looking at components in the chapters ahead. But just before we do that, there is another short chapter, Chapter 5, 
        Flex-layout - Angular's Responsive Layout Engine, that we're going to quickly cover. It's a bit of an odd-ball chapter because Flex-layout is an alternative to Bootstrap's responsive grid and, 
        as such, it is not at all required to build an Angular application. However, I thought it may be of interest to you. With that said, let's turn our attention to Flex-layout

    ■ CHAPTER 5: FLEX LAYOUT - ANGULAR'S RESPONSIVE LAYOUT ENGINE

    ■ CHAPTER 6: BUILDING ANGULAR COMPONENTS

    ■ CHAPTER 7: TEMPLATES, DIRECTIVES AND PIPES

    ■ CHAPTER 9: WORKING WITH ANGULAR MATERIAL
    
    ■ CHAPTER 10: WORKING WITH FORMS
    
    ■ CHAPTER 11: DEPENDENCY INJECTION AND SERVICES
    
    ■ CHAPTER 12: INTEGRATING BACKEND DATA SERVICES
    
    ■ CHAPTER 13: UNIT TESTING
    
    ■ CHAPTER 14: ADVANCED ANGULAR TOPICS
    
    ■ CHAPTER 15: DEPLOYING ANGULAR APPLICATIONS


The previous chapter was a monster, but it was needed to give you a couple of crash
courses on two of the technologies you're likely to use, or should definitely consider using,
in your web development projects (and this is true whether or not your project leverages
Angular). Additionally, Chapter 3, Bootstrap - Grid Layout and Components, was also there
to help set the stage for the rest of the book.
This chapter is much smaller by comparison, but it marks the true beginning of our journey
into Angular. Each chapter from this point forward, even Chapter 12, Integrating Backend
Data Services, where the primary focus is on building backend services in Node and
MongoDB, has Angular material in it (specifically, how to use Angular's HTTP client and
how to wrap your code up in an Angular service).
One other note about this chapter that I'd like to point out is that most books on Angular
don't introduce routing before they introduce Angular templates and components, which is
fine; but we won't be following that approach. Although routing and component templates
are inextricably linked together, which is the the likely reason that most books discuss
routing after components, understanding components is not at all a prerequisite for
understanding routing.
More generally, most programming books try and present all the material and concepts in
advance and then circle back at a later time to try and implement them in some fashion.
One of the problems with this approach is that it goes against the way our brains work
when assimilating and internalizing new information. It is usually better to immediately
use new information, in small incremental steps.
This book focuses on being as practical as possible, as soon as possible and in a way that
maximizes the retention and understanding of new material. So, in order to accomplish
this, we'll be building our example application together throughout the book, learning the
topics as we need them and not before. This means that we will often implement things
that haven't yet been fully explained. They will be explained to you as we implement them,
or immediately afterward-when your brain is primed and looking for patterns to forment
understanding.
Routing Chapter 4
[ 137 ]
So, don't worry about diving in head 1st-it's usually the best way. I'm your guide and I
am with you to all the way to the end of the book.
Here is what we'll be covering together in this chapter:
Defining what routing is, for Angular applications
Creating the shell of our application, as well as its 1st few components, using
the CLI
Configuring routing for our application
Taking a look at route redirection, parameterized routes and route guards
Completing the routing configuration for our application
Taking a look at routing strategies
There's quite a bit to cover (even for a small chapter such as this one), so let's get started!
What is routing in Angular?
Routing in Angular is simply a set of rules that map a requested URL to a component. This
tends to confuse people that are coming to Angular from another technology that has
routing, especially a technology that is not an SPA (that is, a single-page application)
framework. Let me explain this a bit.
Angular applications only have one page (hence, the term single-page application), as we'll
see in a moment when we create our Angular application. Angular components have
templates, which are standard HTML elements that are used to design the layout of the
structure for presentation. And as we'll see in Chapter 6, Building Angular Components, they
also have styles.
As was mentioned in the 1st chapter of the book, Angular applications can be thought of
as trees of components. This is to say that components can contain other components, and
this nesting of components can continue as much as is required for your application.
So, although components have templates (note: some web frameworks refer to web pages
as templates), Angular's routing maps URL paths to components, not to web pages or
templates. When the template of the component that the requested URL is rendered (and
we'll see how this happens in just a moment), not only is that component's template
rendered, but all nested components' templates are also rendered. The top-level component
that is mapped to by Angular's router may contain other child components, which in turn
can contain other child components and so forth. This is what is meant by a tree of
components.
Routing Chapter 4
[ 138 ]
For the most part, data in Angular applications flow from the parent components to their
immediate children. It does not flow from the parent component to its grandchild
component. Moreover, data does not flow upward. It is a unidirectional flow-parent to
child. I say for the most part, because there are techniques and libraries that change some of
this behavior-Np. components can talk to each other through an intermediary,
which we'll look at later on in the book. However, by design and without outside
intervention, data flows from parent to child.
You'll become familiar with all of this as we progress through the book. All you have to
understand at this point, to understand routing, is that URLs are mapped to components
instead of to pages, because Angular applications only have one page. The only page in
Angular apps is the index.html page, which is in the app directory. In Chapter 6, Building
Angular Components, we'll see how our default component gets loaded into the index.html
page. For now, let's get back to routing.
Creating our application's shell using the CLI
This is where it all starts. We have now reached the point where we are going to use the
CLI to create our application's starting point, as well as the 1st bunch of components we'll
need to connect them to our routing configuration. We've looked at how to install the CLI,
and we've even created our 1st Angular application together-although our todo
application was a tiny one, just to get our feet wet-back in Chapter 1, Quick Start.
If you haven't yet installed the CLI, you're definitely going to want to do that now. Once
you've done that (hopefully, you already have), fire up your CLI and let's begin!
The 1st order of business is to create a directory on your machine where you're going to
place all your Angular projects. Don't create a directory for our example application,
because the CLI will do that for you. Simply create a folder on your filesystem and navigate
to it from your command line (if your OS is Windows), or Terminal (if your OS is a Mac or
Linux). For brevity, from here on in, I'll be referring to it as your Terminal and the folders
as directories.
Next, we're going to use our CLI to create the skeleton of our application (that is, the root
directory) and all the accompanying files and sub-directories that the CLI creates for us
that are needed for an Angular application. Enter the following command:
ng new realtycarousel
Routing Chapter 4
[ 139 ]
Note: This will take about a minute to complete.
If you see Project realtycarousel successfully created. as the last line of output, you should
now have a directory named realtycarousel that will contain all our application files.
The output of the preceding command is displayed in the following screenshot:
Let's now test that we can run it. Navigate to your realtycarousel directory with the cd
command:
cd realtycarousel
Next, start our Angular application with the CLI's server command:
ng serve
You should see a bunch of lines output to your Terminal. If one of the lines is sth
similar to ** NG Live Development Server is listening on localhost:4200,
open your browser on http://localhost:4200/ ** and the last line is webpack:
Compiled successfully, then you should open a browser and point it to
http://localhost:4200.
Routing Chapter 4
[ 140 ]
If you see a page with the Angular logo, this means that everything was set up correctly.
You now have an empty Angular application.
You can press Ctrl + C to stop the CLI's development server.
Next, let's add several components, which we will reference in our routing configuration.
Again, don't worry about components for now. We will look at them in depth in Chapter 6,
Building Angular Components and Chapter 7, Templates, Directives and Pipes.
Run the following list of CLI commands, one at a time:
ng g c home
ng g c signup
ng g c login
ng g c logout
ng g c account
ng g c listings
ng g c createListing
ng g c editListing
ng g c previewListing
ng g c photos
ng g c uploadPhoto
ng g c editPhoto
ng g c previewPhoto
ng g c pageNotFound
The output of the 1st command is given in the following screenshot:
Routing Chapter 4
[ 141 ]
We should see a similar output when we create all the other components.
We now have the 1st set of components that we need. Although their templates are empty
for now, this will be good enough to enable us to configure routing for our application.
Since we'll be using Bootstrap for a few things in our application, such as its navigation bar
and its responsive grid, we need to install Bootstrap along with its dependencies. In
Chapter 3, Bootstrap - Grid Layout and Components, we simply referenced a few CDN URLs
in the header of our index.html page in order to be able to use Bootstrap. However, we
will now install Bootstrap differently-we'll be using npm.
You will need Node.js installed on your system in order to use the node
package manager (npm).
To install Bootstrap, jQuery and Popper, run the following command in your Terminal:
npm install bootstrap@4 jquery popper --save
We have installed the libraries and now it's time to include them in our config file so they
are available throughout the application.
Open up the angular.json file and include the stylesheet and JS files in the
respective sections, as shown in the following code snippet:
"styles": [
"styles.css",
"./node_modules/bootstrap/dist/css/bootstrap.min.css"
],
"scripts": [
"../node_modules/jquery/dist/jquery.min.js",
"./node_modules/bootstrap/dist/js/bootstrap.min.js"
]
Routing Chapter 4
[ 142 ]
The screenshot shows the edited angular.json file:
All set!
We now have the core files that we need to be able to set up routing for our application. We
also made sure to install Bootstrap because we're going to create our navigation bar for our
application in this chapter. Moreover, our navigation links will contain special tags that
Angular uses for routing, which is another reason why we needed to install Bootstrap at
this point.
Let's open our project using our IDE (again, it's easiest if you're using Visual Studio
Code-but you can use whichever IDE you prefer), so we can take a look at the project
structure. Additionally, in the next section, Completing our route configuration, we'll be
making changes to a couple of files for setting things up, so you'll want to have a way to
easily open and edit those files.
Routing Chapter 4
[ 143 ]
With the project now open in your IDE, navigate to the app directory, which is located
within the src directory. As Angular developers, we'll be spending the vast majority of our
time within the app directory. Inside the app directory, you will find a number of files that
all start with app. These files make up the root component (that is, the app component) in
our application and we're going to be examining what each of these files does when we
come to Chapter 6, Building Angular Components, where you will become very familiar with
Angular components. You will see many subdirectories in the app directory-one for each
component we created just a few moments ago, such as for about, account, home and so
on.
Remember, the language Angular applications are written in is TS, which is what
the .ts file extension stands for. Let's roll up our sleeves and configure routing for our
application.
1st things 1st - basic concepts
In this section, we will quickly touch base and get an overview of some of the basic
concepts before we start adding routing to our Angular apps. In the basic concepts, we will
learn about Base Href, RouterLink and RouterLinkActive, which we will need to
implement in our templates while working with Angular routing.
Base Href
Every Angular application, in order to compose the links inside the app, should have base
href defined at the parent level.
Open the application generated by the Angular CLI and look inside the index.html file.
We will see the base href defined to /, which resolves to be the root or top-level hierarchy.
Routing Chapter 4
[ 144 ]
The following screenshot shows the default base href configuration, as generated by the
Angular CLI:
RouterLink and RouterLinkActive
In Chapter 7, Templates, Directives and Pipes, we will learn in detail about components,
directives and templates. For now, just understand that, like the anchor element and href
attribute in HTML5, Angular provides a way to bind the links and the URL resource:
<nav>
<a routerLink="/home" routerLinkActive="active">Home</a>
<a routerLink="/listings" routerLinkActive="active">Listings</a>
</nav>
In the preceding code, we are adding two links. Notice that we have added the
routerLink attribute to the links, which will help us bind the value of /home and
/listings, respectively.
Also, notice that we have added the routerLinkActive attribute and assigned the value
as active. Whenever a user clicks on the link, the Angular router will know and make it
active. Some call it magic!
Routing Chapter 4
[ 145 ]
Configuring routes for our application
It's time to add Angular routing to our application.
We have two options for implementing routing:
We can use the Angular CLI to add routing during the creation of the project
Or we can add Angular routing manually into our applications
1st, let's explore the easy way, using the Angular CLI to add routing.
The Angular CLI provides us with an easy way to add routing capabilities to our Angular
application. While generating a new project, the Angular CLI will prompt us to select if we
want to add routing to our app.
The following screenshot shows the option displayed in the CLI for adding Angular
routing:
When we choose the option to add routing in our app, we are using the Angular CLI to
create files, import the required modules and create the route's rulesets.
Now, let's add routing to our project manually. Let's see how we can configure routing in
our app.
In order to configure our routing, we need to follow these steps:
1. Open the app.module.ts file
Routing Chapter 4
[ 146 ]
2. Add the following import statement to the import section at the top of the file:
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
RouterModule contains the router service and router directives.
The Routes module defiles the routes type (remember, TS adds
variable typing to JS).
3. Write a few routes and ruleset in the app-routing.module.ts file:
const appRoutes: Routes = [
{ path: 'home', component: HomeComponent },
...
{ path: '', redirectTo: '/home', pathMatch: 'full' },
{ path: '**', component: PageNotFoundComponent }
];
This code only shows 3 mappings:
Mapping for HomeComponent
Mapping for a redirection
Mapping for a wildcard, or catch-all, the URL request
The 1st mapping object is the simplest case. A URL path (that is, the part of the
URL that comes after the domain name) maps to one component, without any
parameters (note routes can be parameterized and we'll look at that in the
Parameterized routes section shortly). What this route does is instruct Angular to
render the HomeComponent template when the path in the requested URL ends
in the home.
The 2nd mapping object is an example of how to get one path to redirect to
another URL, and, thus, route. This is typically referred to as route redirection. In
our case, the path is an empty string, which means that when only the domain
name is entered into the browser location bar, Angular's routing mechanism will
redirect the request (that is, change the path in the URL) to /home. And since
there is a mapping object that deals with /home, it will get triggered, thus
rendering the HomeComponent template. This is a common practice for
websites-entering just the domain name typically brings the user to the home or
index web page. In our case, since we're building an SPA (which is what Angular
web applications are), there is no home page, but rather a home
component, meaning that the home component's template is rendered to simulate
a home page.
Routing Chapter 4
[ 147 ]
The 3rd mapping object is an example of a wildcard match and is placed as the
last mapping object. When Angular's routing mechanism parses the requested
URL, it compares it to the mapping objects from the top down. If the URL does
not match any of the mapping rulesets, this last mapping object is triggered. What
this means for our application is that, if there are no matches,
the PageNotFoundComponent template will be rendered.
4. Now it's time to import our appRoutes; this is how we tell Angular about our
routes. appRoutes is a constant that holds our route mapping, so let's create that
next:
imports: [
BrowserModule,
RouterModule.forRoot(appRoutes)
]
5. Finally, we will need to import the app-routing.module.ts file into
app.module.ts.
The complete code listing of the app-routing.module.ts file is in the
Completing our route configuration section later in this chapter.
We have added the routes directly into app.module.ts file. It's a good practice to always
separate out the route config file separately. Even better, always use the Angular CLI to add
routing directly when you create the project.
That's it; we have implemented routing in our project. In the next section, we will learn in
detail about adding more routes, adding parameters to our routes and creating child
routes.
Parameterized routes
Parameterized routes are routes that have a variable value as part of the URL path. For
instance, a common example of this is when we reference sth by its ID, as in the
following:
/listing/23 (shows property #23 in our realty site)
/listing/55 (shows property #55 in our realty site)
/listing/721 (shows property #721 in our realty site)
Routing Chapter 4
[ 148 ]
Clearly, having to configure potentially hundreds of routes would not only be tedious,
inefficient and error-prone, but the maintenance of these routes (that is, removing routes
and adding new ones as the inventory of property listings changed) would be troublesome.
Fortunately, Angular allows for parameterized routes, which solve issues such as these.
Take a look at the updated routes in the following code snippet:
const routes: Routes = [
{ path: 'home'},
{ path: 'listings/:id', component: ListingDetailsComponent },
{ path: '', redirectTo: '/home', pathMatch: 'full' },
{ path: '**', component: PageNotFoundComponent }
];
If you look carefully, in the preceding routes we have added one more route, which
captures the id of the listing and we are also mapping it to the
ListingDetailsComponent component.
In other words, we can also say that we have created a generic template for listings and,
based on the dynamic value passed during runtime, the respective data will be displayed
by the component.
That was easy. What if we have a more complex scenario that involves creating child
routes? Read on.
Child routes
The routes we have created so far are very easy and straightforward use cases. In complex
applications, we will need to use deep linking, which refers to hunting down a link into
many levels under.
Let's take a look at some examples:
/home/listings (shows listings inside home)
/listing/55/details (shows the details of listing #55)
/listing/721/facilities (shows the facilities of listing #721)
That's where child routes can be very handy for us to use.
Routing Chapter 4
[ 149 ]
In the following example, we are creating a child route inside the home route path:
const routes: Routes = [
{ path: 'home',
component: HomeComponent,
children: [
{ path: 'listings',
component: ListingsComponent}
]
},
{path: 'listings/:id', component: ListingDetailsComponent },
{path: '', redirectTo: '/home', pathMatch: 'full'}
];
In the preceding code, we are defining children for the home path and, again, we are
specifying the path and component, which will correspond to the child route path.
OK, fine. This is good stuff.
What if we want to add some validation before a user can access a particular route? like a
bouncer outside a club? That bouncer is called a route guard.
Route guards
As in most web applications, there are resources (that is, pages/component templates) that
are accessible to everyone (such as the Welcome page, Pricing page, About Us page, and
other informational pages) and there are other resources that are only meant to be accessed
by authorized users (such as a dashboard page and an account page). That's where route
guards come in, which are Angular's way to prevent unauthorized users from accessing
protected parts of our application. When someone tries to access a URL that is reserved for
authorized users, he will typically be redirected to the public home page of the application.
In traditional web applications, the checks and validations are implemented in the serverside
code and there is practically no option to validate whether the user can access the page
at the client side. But using the Angular route guard, we can implement the checks at the
client side without even hitting the backend services.
The following are the various types of guards available that we can use in our applications
to enhance security for authorization:
CanActivate: Helps to check whether the route can be activated or not
CanActivateChild: Helps to check whether the route can access child routes or
not
Routing Chapter 4
[ 150 ]
CanDeactivate: Helps to check whether the route can be deactivated or not
Resolve: Helps to retrieve route data before activation of any route
CanLoad: Verifies whether the user can activate the module that is being lazy
loaded
And before we jump into our hands-on exercise, I want to give you a quick overview of
Angular route guards, such as where to use them, how to use them, what's the return type,
and so on. Route guards are always injected as a service (that is, we have @injectable and
we will need to inject it). The guards always return a Boolean value, true or false. We can
make our route guards return the observables or promises, which internally get resolved
into a Boolean value.
We will continue to work on and expand the example we have created in the previous
section. We are going to add a new component and call it CRUD. As a user, when you try
to access the crud route, we will check when the route returns true. We will allow the user
to navigate and see the template; otherwise, the application will throw an error prompt.
Let's dig right into the code to implement route guards. Just as we learned how to generate
a component or a service, we can use the ng command and generate a route guard. In the
Terminal, run the following command:
ng generate g activateAdmin
We have just generated a new route guard named activateAdmin. The output of the
preceding command is displayed here:
Let's take a look at the files generated by the Angular CLI. Open the activateadmin.
guard.ts file in the editor. Take a look at the default code generated in the file:
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from
'@angular/router';
import { Observable } from 'rxjs';
@Injectable({
providedIn: 'root'
})
export class ActivateAdminGuard implements CanActivate {
canActivate(
Routing Chapter 4
[ 151 ]
next: ActivatedRouteSnapshot,
state: RouterStateSnapshot): Observable<boolean> | Promise<boolean>
| boolean {
return true;
}
}
The 1st few lines are just importing the required CanActivate,
ActivatedRouteSnapShot and RouterStateSnapshot modules from the Angular
router. Next, we know that since route guards are injectable, by using the @injectable
decorator, we are informing Angular to inject it inside the root. And we are creating a
class, ActivatedAdminGuard, that has a method already created inside it named
canActivate. Note that this method has to return a Boolean value, either true or
false. We have created our route guard, so now let's create a route now in our approuting.
module.ts file.
Take a look at the updated code of the app-routing.module.ts file:
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { CrudComponent } from './crud/crud.component';
import { LoginComponent } from './login/login.component';
import { RegisterComponent } from './register/register.component';
import {ActivateAdminGuard } from './activate-admin.guard';
const routes: Routes = [
{ path: 'login', component: LoginComponent },
{ path: 'register', component: RegisterComponent },
{ path: 'crud', component: CrudComponent,
canActivate:[ActivateAdminGuard] }
];
@NgModule({
imports: [RouterModule.forRoot(routes)],
exports: [RouterModule]
})
export class AppRoutingModule { }
Note that in the routes, we have added the canActivate interface and, for our crud path,
when we try to launch the crud route, since the canActivate method is returning
true, the user will be able to see the component template.
Now, go ahead and set the value to false and find out what happens.
Routing Chapter 4
[ 152 ]
If you see the application's routing go back to base href, don't be
surprised.
Completing our route configuration
As promised in previous sections, I will share the entire source code of AppModule,
including the route configurations. The following code may look lengthy or scary, but trust
me, it's actually very simple and straightforward.
During the course of learning this chapter, we have generated many components and
created their route paths. We are just importing the components and updating appRoutes
with their paths. That's it. I promise.
Here is the complete listing of the app.module.ts file:
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AppComponent } from './app.component';
import { HomeComponent } from './home/home.component';
import { SignupComponent } from './signup/signup.component';
import { LoginComponent } from './login/login.component';
import { ListingsComponent } from './listings/listings.component';
import {ListingDetailsComponent } from './listing-deatails/listingdetails.
component';
import { EditListingComponent } from './edit-listing/editlisting.
component';
import { PreviewListingComponent } from './preview-listing/previewlisting.
component';
import { PhotosComponent } from './photos/photos.component';
import { UploadPhotoComponent } from './upload-photo/uploadphoto.
component';
import { EditPhotoComponent } from './edit-photo/edit-photo.component';
import { PreviewPhotoComponent } from './preview-photo/previewphoto.
component';
import { PageNotFoundComponent } from './page-not-found/page-notfound.
component';
import { FeaturesComponent } from './features/features.component';
import { PricingComponent } from './pricing/pricing.component';
import { AboutComponent } from './about/about.component';
import { SupportComponent } from './support/support.component';
import { AccountComponent } from './account/account.component';
import { LogoutComponent } from './logout/logout.component';
Routing Chapter 4
[ 153 ]
const appRoutes: Routes = [
{ path: 'home', component: HomeComponent },
{ path: '', redirectTo: '/home', pathMatch: 'full' },
{ path: 'signup', component: SignupComponent },
{ path: 'login', component: LoginComponent },
{ path: 'logout', component: LogoutComponent },
{ path: 'account', component: AccountComponent },
{ path: 'features', component: FeaturesComponent },
{ path: 'pricing', component: PricingComponent },
{ path: 'about', component: AboutComponent },
{ path: 'support', component: SupportComponent },
{ path: 'listings', component: ListingsComponent },
{ path: 'listing/:id', component: ListingDetailsComponent },
{ path: 'listing/edit', component: EditListingComponent },
{ path: 'listing/preview', component: PreviewListingComponent },
{ path: 'photos', component: PhotosComponent },
{ path: 'photo/upload', component: UploadPhotoComponent },
{ path: 'photo/edit', component: EditPhotoComponent },
{ path: 'photo/preview', component: PreviewPhotoComponent },
{ path: '**', component: PageNotFoundComponent }
];
@NgModule({
declarations: [
AppComponent,
HomeComponent,
SignupComponent,
LoginComponent,
ListingsComponent,
CreateListingComponent,
EditListingComponent,
PreviewListingComponent,
PhotosComponent,
UploadPhotoComponent,
EditPhotoComponent,
PreviewPhotoComponent,
PageNotFoundComponent,
FeaturesComponent,
PricingComponent,
AboutComponent,
SupportComponent,
AccountComponent,
LogoutComponent
],
imports: [
BrowserModule,
RouterModule.forRoot(appRoutes)
],
providers: [],
Routing Chapter 4
[ 154 ]
bootstrap: [AppComponent]
})
export class AppModule { }
We have just created our routes, but we will need to update our template file by creating a
few links that will have the path to the aforementioned-defined routes.
One thing that's most important in any application is a well-designed menu, which helps
guide users and adds to a good user experience.
Using the Bootstrap nav component, we will design a menu for our application in the next
section.
Bootstrap navigation bar and router links
directives
Just before we cover a couple of routing strategies to wrap up this chapter, let's circle back
and create our Bootstrap navigation bar for our application. If you recall from the previous
chapter, Chapter 3, Bootstrap - Grid Layout and Components, I had mentioned, that we'll be
covering the Bootstrap navigation component in this chapter. The reason for this is that
we're going to be tying our navigation bar to our routing by using routing directives as the
menu links and so the best place to cover that is in this chapter, since it falls into the
domain of routing.
In the previous section, I gave you homework to enter the route path URL manually in the
browser bar to see the routes working, in this section, we will add all the route URLs to the
Bootstrap navbar component, so that the user can just click and navigate instead of typing
manually.
At the starting of the chapter, we briefly touched upon routerLink and
routerLinkActive. Now it's time to see them in action.
Let's take a look at the app.component.html file, which is the template of our app
component. If you are familiar with the notion of master pages in ASP.NET, or a layout
page in Rails, then you can consider the app component template as the equivalent for
Angular applications. This is because the app component is the top-level component in the
tree of components that will form our application. The reason I brought up the notion of a
master layout is that whatever HTML is inserted into it is preserved by the server by it
rendering the called page within the layout page. While this is not what happens in
Angular, since it's not a server-side technology, it does hold true in concept.
Routing Chapter 4
[ 155 ]
What I mean by this is that whatever HTML we insert into the app component's template, it
is generally still visible when other components are rendered within it. This makes the app
component template a perfect place to hold our navigation bar, since it'll always be visible
regardless of what component template is selected to be rendered by our routing rulesets
for a given URL that is requested by our users.
Here is the code listing for our app.component.html file:
<div>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">LISTCARO</a>
<button class="navbar-toggler" type="button" data-toggle="collapse"
data-target="#navbarSupportedContent"
aria-controls="navbarSupportedContent" aria-expanded="false"
aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li routerLinkActive="active" class="nav-item">
<a routerLink="/" class="nav-link">Home</a>
</li>
<li routerLinkActive="active" class="nav-item">
<a routerLink="photos" class="nav-link">Photos</a>
</li>
<li routerLinkActive="active" class="nav-item">
<a routerLink="listings" class="nav-link">Listings</a>
</li>
<li routerLinkActive="active" class="nav-item">
<a routerLink="features" class="nav-link">Features</a>
</li>
<li routerLinkActive="active" class="nav-item">
<a routerLink="pricing" class="nav-link">Pricing</a>
</li>
<li routerLinkActive="active" class="nav-item">
<a routerLink="about" class="nav-link">About</a>
</li>
<li routerLinkActive="active" class="nav-item">
<a routerLink="support" class="nav-link">Support</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown"
role="button" data-toggle="dropdown" aria-haspopup="true"
aria-expanded="false">
User name
</a>
<div class="dropdown-menu" aria-labelledby="navbarDropdown">
Routing Chapter 4
[ 156 ]
<a routerLink="account" class="dropdown-item">Account</a>
<div class="dropdown-divider"></div>
<a routerLink="logout" class="dropdown-item">Log out</a>
</div>
</li>
</ul>
<form class="form-inline my-2 my-lg-0">
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">
Log In</button>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">
Try Now</button>
</form>
</div>
</nav>
<br />
<router-outlet></router-outlet>
</div>
Take a deep breath and let's analyze the preceding lines of code. We are using both
Angular directives and attributes, along with Bootstrap built-in classes. So let's begin:
We are creating a menu navbar element, <nav>, provided in Bootstrap, and
assigning the built-in navbar classes, navbar-expand-lg navbar-light bglight.
We are also creating an element and placeholder for the logo of our application
using the navbar-brand class.
Using the navbar-nav class, we are defining a collection of links.
We are adding few links using the anchor tag, <a> and assigning the navlink
class, which will form the links in the menu section.
We are also creating a drop-down menu using the dropdown-menu class and
adding items to the menu using dropdown-item.
For Angular directives and attributes, we are using routerLink and
routerLinkActive and, as explained in the 1st thing 1st - basic concepts,
section, the routerLink attribute is used to bind the URL resource of the link.
To highlight the active link, we are using the routerLinkActive attribute. You
will notice that for all links, we have assigned the attribute value as active.
Angular at runtime will detect the link clicked and will highlight it.
Awesome, good job so far. We have implemented a nav menu for our application. We are
just one step away from seeing our application in action.
Routing Chapter 4
[ 157 ]
Specifying the location for rendering the
component templates
We need to tell Angular where we want the component templates, for the mapped
components in our routing rulesets, to be displayed. For our application, we want to have
the components that the router calls upon to be rendered under our navigation bar.
Angular has a directive for doing this, <router-outlet>, which is defined in
RouterModule.
Under the HTML we added for creating our Bootstrap navigation bar, add this following
line of HTML:
<router-outlet></router-outlet>
That's all that is needed to tell Angular where the components that are called upon by the
routing service should be rendered.
Running our application
Now that we have completed configuring routing for our application, let's take it for a
quick spin.
Do you remember how to build and start our Angular application? Right! Use the CLI and
issue the serve command like this:
ng serve
Make sure you are in the application's root folder when you do this.
A shortcut for starting the application and opening your browser to localhost in one fell
swoop, is issuing the ng server command with the open option, like this:
ng serve --open
Routing Chapter 4
[ 158 ]
What you should see is that the URL in the browser's location bar is pointing
to http://localhost:4200/home, which is Angular routing at work. The ng serve
command with the open option issued the http://localhost:4200 URL, but this
triggered the route redirection to /home. Pretty cool, huh?
When we run the application, we should see the output shown in the following screenshot:
In the next section, we will learn about some of the routing strategies we can implement in
our apps.
Routing strategies
There are two client-side routing strategies in Angular:
HashLocationStrategy (typically used for client-side purposes, such as anchor
tags)
PathLocationStrategy (this is the default)
To enable HashLocationStrategy, in the app.module.ts file, where we have
RouterModule.forRoot(appRoutes), append { useHash: true } as the 2nd
parameter in the forRoot method. This is what it should look like:
RouterModule.forRoot(appRoutes, { useHash: true })
URLs with HashLocationStrategy have a hash sign (#) in their path. Here is an example:
http:/ / madeuplistofpeople.com/ superheros#cloudman
The preceding URL represents a get request to http:/ / madeuplistofpeople.com/
superheros to the server.
Routing Chapter 4
[ 159 ]
Everything from the hash onward is not part of the request, because the
browser only sends everything in the browser's location bar, to the left of
the hash sign, to the server.
The #cloudman portion of the URL is used exclusively by the client, and, typically, this is
used by the browser to automatically scroll down to the anchor tag on the page (in this
case, to the anchor tag with a name attribute of cloudman).
One use of the HashLocationStrategy strategy is for using the hash sign to store
application state, which is convenient for implementing client-side routing for an SPA.
As an example, consider the following URLs:
http:/ / madeuplistofpeople.com/ #/ about
http://madeuplistofpeople.com/#/search
http:/ / madeuplistofpeople.com/ #/ contactus
This URL pattern is great for an SPA because the only request going to the server is http:/ /
madeuplistofpeople. com, which is essentially one page. The client side will handle the
different hash fragments (that is, from the hash sign to the end of the right-hand side of the
hash sign) in whichever way it was programmed to.
To wrap up this section, an important concept of PathLocationStrategy is that Angular
takes advantage of an HTML5 history API called pushstate. We can change the URL using
the pushstate API while suppressing the traditional default action by the browser to send
the new request (that is, the altered URL) to the server. This makes it possible to implement
client-side routing without resorting to using a hash sign (#). This is why it is the default
client-side routing strategy in Angular.
However, there is a downside. If the browser were to be refreshed, a request would be
made to the server, which would reset your application with whatever the server sent back.
In other words, your application would lose its state, unless you had implemented local
storage strategies.
Routing Chapter 4
[ 160 ]
Summary
This was a fairly short chapter, but we still covered a lot of ground. In this chapter, we
created the skeleton for our application, including creating the components that we had our
routes mapped to. We then went through a step-by-step process of configuring routing for
our application. This included importing the two required modules (that is,
RoutingModule and Routes), coding up routing rulesets in the form of mapping objects,
and specifying where the routed components were to be rendered.
We also installed and integrated Bootstrap into our application and created our Bootstrap
navigation bar in our root component's template. We then took a look at how to make
Angular aware of installed node packages, Bootstrap and jQuery in particular, since that is
how we installed Bootstrap and its dependencies (that is, jQuery and Popper).
Although we didn't make use of parameterized routes and route guards in this chapter, we
mentioned them here because we'll be making use of them later in the book-in Chapter
12, Integrating Backend Data Services and Chapter 14, Advanced Angular Topics-and in the
spirit of the book, discussing things at the time we need them and not before, we are
deferring their demonstration until the appropriate times.
And to wrap this chapter up, we took a look at the two client-side routing strategies that
Angular lets us choose from.
We've mentioned the word components over and over again in this chapter, since routing
maps URL paths to components. We've even created several components using the CLI, but
we've spent no time understanding components. That's perfectly fine because, as was
mentioned, you didn't need to understand components in order to understand routing.
Now that we have routing under our belt, we'll be looking at components in the chapters
ahead. But just before we do that, there is another short chapter, Chapter 5, Flex-layout -
Angular's Responsive Layout Engine, that we're going to quickly cover. It's a bit of an odd-ball
chapter because Flex-layout is an alternative to Bootstrap's responsive grid and, as such, it
is not at all required to build an Angular application. However, I thought it may be of
interest to you. With that said, let's turn our attention to Flex-layout.

5 Flex-Layout - Angular's
Responsive Layout Engine
Flex-Layout is a TS-based layout engine for Angular. It is an alternative to using
Bootstrap's grid for laying out your components in your Angular projects. Flex-Layout
evolved from AngularJS Material, a UI Component Framework, which was created by a
team at Google led by Thomas Burleson-a well-known speaker at Angular conferences.
I've not yet had the chance to attend an Angular conference, such as ng-conf or
AngularMix, but I will. Maybe I'll see you there! There are many conferences on Angular
spanning the globe-so you know that you're spending your time wisely studying a
technology that is in high demand and is here to stay. I don't think I've said this to you yet,
so I will now. Congratulations! Congratulations on selecting such a great technology to use
in your projects, or maybe even as the cornerstone technology on which to build your
career.
I can't help but get excited when I discover technologies that transform the way I create
software for my clients and for myself and now I get to share my excitement with you! So,
pardon the slight tangent from the material at hand.
OK, let's now take a look at what we'll be covering in this chapter.
Why this chapter was included in the book
The four available techniques for the layout of our components
Why FlexBox CSS is probably the best option
What is Flex-Layout and why should you consider using it?
Integrating Flex-Layout
The Flex-Layout API
Design strategies when using Flex-Layout
Associating our wireframes and components with the chapters and topics in this
book
Implementing our selected wireframes
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 162 ]
Why this chapter was included in the book
This is a very short chapter. In fact, it's probably the shortest in the book. However, I
wanted to include it to give you options, particularly in terms of having an alternative
technology to Bootstrap. Within reason, the more options you have, the better off you are.
Additionally, some developers enjoy using Bootstrap, while others don't. I suspect that the
reason for this is that Bootstrap's layout system is a grid. I don't know many developers
who like being sandboxed into sth like that. Don't get me wrong, I'm not knocking
Bootstrap (Bootstrap is a great technology and the name is even in the title of this book!),
but Flex-Layout definitely feels like it is less rigid. Another reason that some developers
would prefer working with sth like Flex-Layout is that it feels more developerfriendly.
Np. instead of using DIV elements with special attributes, you use
dedicated elements. This is sometimes referred to as taking a declarative approach, which
sometimes simply feels more natural to developers. This may or may not make sense to you
at the moment, but it will by the end of the chapter.
The four available techniques for the layout of
our components
As web developers and unless you're privileged to have a web designer on your team, we
necessarily find ourselves needing to spend time with the layout of the components on our
pages.
As a quick aside, let's put some terminology in place for our discussions moving forward.
I've used the terms component and pages interchangeably in the 1st few chapters, but it is
now time to get more precise. As you know, Angular applications are SPAs by default and
thus only have one page. I've mentioned a few times in the book that an Angular
application is like a tree of components and it all starts with the root component.
Components are composable, which is to say that a component can be made of other
components. What's the result of this? Well, we need a web page in order to have our root
component rendered-and from that moment forth, our root component brings in other
components, which, in turn, bring in yet other components. The end result is that our
components recursively render themselves to give the illusion that we have multiple pages.
Of course, we don't have multiple pages. We have a single web page and the way in which
we're architecting our application is that we have a main encompassing component for each
page in our application. All that means is that when you see me mention page, instead of
component, I'm really referring to the main component on that page.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 163 ]
Take a look back at the code we wrote for Chapter 4, Routing and it should all start to be
making sense to you. Specifically, a given URL maps to a component. With more traditional
web applications that are not SPAs, the URLs are mapped to views, or "pages". OK, let's
return our focus to considerations and available options as to layout strategies.
Laying out the components in our application includes the following four necessities:
Laying out our components within their containers (that is, parent component
and child component(s))
Sizing our components
Positioning our components relative to each other
Styling the components
I don't profess to be an expert in styling or CSS. I can barely color coordinate the clothes I
wear. While we have seen some CSS in Chapter 3, Bootstrap - Grid Layout and Components,
in our SASS crash course (and we'll certainly see more CSS in the chapters ahead), this is
not a book about design and styling. Packt Publishing offers a few excellent books on CSS.
In this chapter, we'll only concern ourselves with laying out our components within their
containers. To that end, we have four techniques that we can choose from: tables, float and
clear, FlexBox CSS and CSS Grid.
Yes, of course, Flex-Layout is also an option for us because we've chosen Angular (big
smile). However, the four layout techniques I've listed apply to web development in
general-regardless of a frontend framework, library, or just plain old HTML and CSS. As
we have seen in Chapter 3, Bootstrap - Grid Layout and Components, Bootstrap is a CSS
framework built on top of FlexBox CSS and so also applies to web development in general.
Getting back to our discussion of layout techniques, let's contrast the four that are generally
available to web developers and see whether there is a clear winner. From there, we'll
move on to the nitty-gritty of this chapter and take a look at what Flex-Layout is and why
we should use it.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 164 ]
Table
Every web developer (born before the year 2000) has heard of and has likely used the
TABLE tag. Where did this come from? Well, a long time ago, in a galaxy far, far away, a
team of alien programmers invented HTML table tags. These aliens soon grew weary of
using this layout technique, so they banned its use and banished all the web development
books that taught table tags their planet. Meanwhile, somewhere on Earth, circa 1994, a web
developer who was frustrated with layout issues was hit on the head with what seemed
like a technical book. Its markings appeared to be some form of hieroglyphics-all
indecipherable to the young techie, except the distinctly familiar markup language. The
1st chapter's heading was simply, <TABLE>.
Kidding aside, while tables were tremendously helpful in the early days of web
development, they are now an ancient layout technique that is often frowned upon. Here
are some reasons why tables are no longer the default method for laying out page elements:
They tend to clutter up the markup in our web pages and components
They are a maintenance nightmare, since moving things around is extremely
tedious using tables
They are rigid-more so than a grid, to the extent that we sometimes had to
resort to having nested tables, which, of course, exacerbate the 1st two bullet
points
However, despite these negatives, using tables is still a valid option and is why I've listed it
here as one of the main four.
Positioning using float and clear
CSS has some pretty cool features. Among my favorites were a couple of its declarations
that deal with positioning. Specifically, the two CSS declarations I'm referring to are float
and clear. These declarations can be applied to block elements, such as <div>, as well as
inline elements, such as <img>. Block-level elements are elements that occupy 100% of the
parent element's space, whereas inline elements are happy to share the horizontal space
they reside within their parent element.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 165 ]
The notion of floating an element (such as a <div>) is that it relinquishes its demand to take
up the entire horizontal line. In short, it collapses its space to only consume what it
needs-instead of being greedy with the horizontal real estate available-and other
elements can now reside beside it, instead of being pushed below it. This is true for when
the element being floated does not take up the entire space. Elements that are floated beside
it, when there is not enough room horizontally, will wrap down to the next line. With that
being said, you can start to see how you can achieve some degree of responsive design by
using the CSS float declaration to float elements.
The purpose of clearing is to control how the float takes effect. When you use the CSS
declaration of clear on an element, you are basically instructing that element to not float up
to the higher horizontal space-even if there is space to float up in. Remember, floating
elements means that the element will take the highest vertical space it can take, provided
that there is room and that its adjoining elements have also been floated (especially for
block-level elements that want to consume the entire horizontal space on their own). When
there isn't sufficient space, it'll wrap down to the next highest available spot and if there is
enough space, it'll float up to be beside the other element. The exception to this is if you
apply the clear declaration to it in its style or class, in which it will always behave as it
wraps down-even when there's room higher up. Are we good on this? Cool.
Positioning elements via float and clear definitely works and you can create some fairly
sophisticated layouts by using them. But their effects may not always be what you want to
see happen, as the viewport size gets smaller. In the world of responsive layout, having as
much control as possible over your layout is paramount and being limited to just floating
and clearing can often make it a bit of a challenge to have your layout rearrange itself, given
a wide array of viewport sizes-at least with as much precision as the next two options give
you. Another thing that you need to get used to with floating elements is that you need to
reorder the listing of elements on your page, depending on whether you're floating the
elements to the left or to the right.
The reason I took a little more time here on float and clear is that it's an area where too many
developers don't take the time to let it sink in. The takeaway point here is that you can get
very far with just this layout technique, and, depending on the nature of the project and its
requirements, it may be what the doctor ordered. Of course, there's more to say about float
and clear in terms of design strategies, but that is a whole other book. As always, I
recommend playing around with this layout technique/strategy.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 166 ]
FlexBox CSS
FlexBox CSS is a layout technique that came into being with CSS3. It's a very powerful
thing and this is why other frameworks, such as Bootstrap and Flex-Layout, are built on
top of it. But the best thing about FlexBox CSS is that it's understood by nearly all of the
browsers in general use today. With FlexBox we get the best of both worlds - tremendous
browser outreach and admirable layout flexibility for your application.
I won't say much more than this for FlexBox CSS because chances are that you will not use
it-at least not directly. There are 3 reasons why I can probably safely make that
assumption:
Bootstrap is built on top of FlexBox CSS and you're probably more likely to use
the Bootstrap grid as opposed to using FlexBox CSS directly
The same thing holds true with Flex-Layout, since it basically wraps FlexBox CSS
in a nice API, making it easier to use
CSS Grid
CSS Grid FlexBox CSS is a layout technique that comes into being with CSS4. It's also a very
powerful thing and it makes some things easier to do than with FlexBox CSS, but, at the
same time, some things are harder to implement than doing it with FlexBox CSS. Being a
relatively new addition to the world of CSS, it is not as widely integrated into browsers that
are generally in use.
Why FlexBox CSS is probably the best option
After reading the few preceding paragraphs in the previous section, who the winner is
should come as no surprise to you. It's definitely FlexBox CSS. Let's summarize this with a
list of factors that should be considered when selecting a layout option:
Browser reach: As developers, we care deeply about the reach of our web
applications.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 167 ]
Ease of use: This one is a bit of a stretch, I know-both Bootstrap's grid and Flex-
Layout are built on top of it, making it easier to use. But once you get your head
around FlexBox CSS, most layout requirements can be handled fairly easily.
Ease of maintenance: This one follows from the previous bullet point. But
sth that most developers are surprised by is the fact that, during the
lifespan of a typical application, 20% of the time that developers are involved
with it is in building it, whereas 80% of developer time with the application is in
maintaining it-and so this last bullet point cannot be overemphasized.
Again, we're not considering Bootstrap and Flex-Layout to be layout techniques because
they are tools/frameworks superimposed on top of the underlying layout techniques.
What is Flex-Layout and why should you
use it?
We covered why the best option for us from the four for laying out our components is
FlexBox CSS, but this is a chapter on Flex-Layout and so I now need to introduce it to you.
So let's do that now and then I'll list a few reasons why you should consider using it
instead of using FlexBox CSS directly (again since Flex-Layout is built on top of FlexBox
CSS).
Flex-Layout's home can be found here: https://www. github.com/ angular/ flex- layout.
Here are a few bullet points detailing what Flex-Layout is:
It's a standalone library.
It's Angular-native (and is a TS implementation).
It's integrated with the CLI.
It has static APIs, which are for the containers and other static APIs, which are
for the container children. These APIs have the following characteristics:
They are declarative
They support data binding and change detection
They are directives used in HTML
There's no CSS for us to write since it's dynamically injected for us
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 168 ]
Some advantages of using it instead of FlexBox CSS and following from the preceding
bullet points, are as follows:
You don't have to be a CSS expert (in fact, as you'll soon see, we won't even be
using a CSS style sheet)
It fits Angular perfectly (in fact, it's Angular-native)
There are APIs which helps developers in faster application development
Another nice thing to know is that since Flex-Layout is a standalone (that is, self-contained)
library, it can be used with or without Angular Material. We'll be taking a look at Angular
Material in Chapter 9, Working with Angular Material, where we'll be utilizing a couple of its
components. Again, these components can be used as replacements for, or in conjunction
with, ng-Bootstrap. We'll be taking a look at ng-Bootstrap in Chapter 8, Working with NG
Bootstrap.
I've mentioned in the preceding bullet list that Flex-Layout has static APIs. What I have not
mentioned is that it also has responsive APIs. We'll be covering Flex-Layout's static APIs in
an upcoming section, The Flex-Layout API, but I leave the reading of its responsive API to
you (I have included links to the Flex-Layout documentation at the end of that section).
However, I would like to say a quick word on responsive APIs. Responsive APIs are there
so that you can create an adaptive UX (that is, an adaptive user experience to have a
slightly different layout for various viewport sizes). In order to do that, you need to also
leverage MediaQueries-not only FlexBox CSS. Now, yes, this is a chapter on Flex-Layout,
so why am I mentioning that you need to leverage MediaQueries in conjunction with
FlexBox CSS? I mention this to point out the fact that the Flex-Layout team has us covered
in this space (that is, responsive UX, not just layout) as well. And they have done this by
providing extensions to the static APIs to abstract the MediaQueries away from us. This
means that we don't have to handcraft tedious rule sets-and since they created extensions
on the static APIs, we can leverage what we learn there and apply the extensions to create
the adaptive UX right in our HTML. It's really quite brilliant!
Integrating Flex-Layout
The Flex-Layout library comes as one self-contained module and so we only need to
import it in one place. It is more straightforward to integrate than routing was in the
previous chapter.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 169 ]
Now let's add Flex-Layout to our project. The 1st thing we need to do is to install the
library. In your Terminal, navigate to the root folder of the realtycarousel application
that we started creating in Chapter 4, Routing and type the following:
npm install --save @angular/flex-layout
This will install the library, so we can later import it into any of our Angular applications.
Note: If your CLI outputs a warning, such as sth along the lines
of "@angular/flex-layout@5.0.0-beta.14 requires a peer of @angular/cdk@^5.0.0
but none is installed. You must install peer dependencies yourself" (which is what
happened to me), just install it the same way as anything else, as follows:
npm install --save @angular/cdk@^5.0.0
Next, we need to import it into our RealtyCarousel application. To do this, we need to
add a couple of things to our application's main module. Open your RealtyCarousel
project in your IDE and then open the app.module.ts file from within the src/app
directory. At the top of the file within our other import statements, add the following
import statement:
import { FlexLayoutModule } from '@angular/flex-layout';
(Just underneath the import statement , that we added for the RouterModule will be just
fine.)
We also need to include the FlexLayoutModule in the imports array within the
@NgModule section, like this: (just underneath the
statement RouterModule.forRoot(appRoutes), we had added for the RouterModule
would be just fine.)
With that, we're done. We now have the power of Flex-Layout at our disposal. Virtually
anything else we'll do with Flex-Layout gets done in our HTML.
Let's take a look at the Flex-Layout API next-which is how we'll be leveraging Flex-Layout
in our pages (that is, component templates).
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 170 ]
The Flex-Layout API
What makes Flex-Layout easier to work with than FlexBox CSS is the fact that it has APIs
that abstract the CSS away for us. We still need CSS (remember, browsers only understand
HTML, JS and CSS), but what I mean by the face that CSS will be abstracted away
for us is that when our application is transpiled, Angular Flex-Layout will inject the CSS for
us. As I've mentioned, Flex-Layout doesn't even have a CSS style sheet and we don't have
to write any CSS.
The following is a table of the Flex-Layout APIs, detailing what they are used for, together
with a quick syntactical example:
Type API Used for Example
Static
(for
container)
fxLayout
Defines the direction
of the flow (that is,
flex-direction).
<div
fxLayout="row" fxLayout.xs="column">
</div>
Static
(for
container)
fxLayoutAlign Defines the alignment
of the elements.
<div fxLayoutAlign="start stretch">
</div>
Static
(for
container)
fxLayoutWrap
Defines whether the
elements should
wrap.
<div fxLayoutWrap>
</div>
Static
(for
container)
fxLayoutGap Sets the spacing
between elements.
<div fxLayoutGap="15px">
</div>
Static
(for
children)
fxFlex
Specifies resizing of
the host element
within its container
flow layout.
<div fxFlex="1 2 calc(15em + 20px)">
</div>
Static
(for
children)
fxFlexOrder Defines the order of a
FlexBox item.
<div fxFlexOrder="2">
</div>
Static
(for
children)
fxFlexOffset
Offsets a FlexBox item
within its container
flow layout.
<div fxFlexOffset="20px">
</div>
Static
(for
children)
fxFlexAlign
Similar
to fxLayoutAlign,
but for a specific
FlexBox item (not all).
<div fxFlexAlign="center">
</div>
Static
(for
children)
fxFlexFill
Maximizes
dimensions of the
element to that of its
parent container.
<div fxFlexFill>
</div>
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 171 ]
These APIs have options and defaults. Np. the fxLayout API defaults to row, but
also has column, as well as row-reverse and column-reverse.
Also, the .xs in the example for the fxLayout API has a similar notion as the Bootstrap
grid in that it provides a way to allow for different viewport sizes. So, in the 1st example
in the preceding table, the layout for regular viewports will be that elements flow from left
to right within the row, and, for small viewports, the elements will be stacked in a single
column.
Another interesting thing to point out in the examples in the preceding table is where there
is a calculation made in the fxFlex API. This is a little like what we looked at in the SASS
crash course in Chapter 3, Bootstrap - Grid Layout and Components, although SASS was
compiled by Ruby, whereas Flex-Layout is compiled by TS.
I won't enumerate all the options here because you didn't purchase this book to read
documentation, any more than I wrote this book to just copy documentation. Of course, I
will point you to the place to look up the documentation for Flex-Layout. You can find it at
their official website: https://github.com/ angular/ flex- layout/ wiki/ APIDocumentation.
Fortunately, the Flex-Layout team has done a fantastic job with the documentation. Their
wiki also includes several live layout demos that you can take a look at. Here is the direct
link: https://tburleson- layouts- demos. firebaseapp.com/ #/ docs.
Design strategies when using FlexBox
Since Flex-Layout is more of a flowing kind of thing, as opposed to being a grid, it's often
easier to think of vertical sections of your application and assign them their own container.
This is because the sections within your containers will automatically wrap downward as
the viewport size gets smaller. Elements within the container should be thought of as
belonging together. Contrasting this with a grid system, such as Bootstrap, the thinking is
different; the cells in the grid mark the physical boundaries of the elements. The elements
within the cells don't automatically wrap because when you are thinking of the
design/layout, you insert elements in specific cells. Another way to conceptualize the
differences between a grid and FlexBox is to think of a grid as being two-dimensional (that
is, rows and columns-much like a spreadsheet) and FlexBox as being one-dimensional (in
that it either flows horizontally, or it flows vertically).
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 172 ]
Once you have your vertical containers in mind, you can then think about sub-containers
flowing from left to right and the sub-container then wrapping downward as the viewport
size gets smaller-and when it does wrap downward, all the elements with that subcontainer
go along for the ride. Bear in mind, when I mention sub-containers, that I'm
referring to the fact that FlexBox containers can be nested-which is what gives much of the
layout control to the developer. When laying out your page, think of the flows as outside-in.
This is to say that you should break up your page into large vertical sections-such as a
header, main body and footer-and then dive into each of the sections to add your subcontainers,
which will flow from left to right.
It's difficult to describe flow in words and so the best thing to do, as always, is to
experiment with your containers and elements and study the behavior of their flow as you
adjust your viewport size. This chapter includes code listings for 3 of our component
templates (that is, pages) as well as their wireframes. You'll see exactly how I've designed
the layouts for these component templates. Along the way, I'll also tell you why I've made
some of the decisions I've made.
Associating our components with the chapters and
topics in this book
Up until now, we haven't discussed where and when we'll be implementing our
components. Part of the reason was that we didn't even start writing any Angular code
until Chapter 4, Routing-with the sole exception being our to-do list mini-application in
Chapter 1, Quick Start. However, now that we have started writing Angular code, it's time
to do that now.
A good place to start the discussion is to select which component templates we'll be laying
out with Flex-Layout. Since this book focuses more on Bootstrap than it does with Flex-
Layout, we'll be using Bootstrap's grid for the rest of our component templates, which is the
majority of them.
The 1st thing we'll do is to list our wireframes, as a reference,which represent our
application's pages (that is, component templates) and we'll select 3 of them, which we
will implement in the following section, Implementing our selected wireframes. And then, we'll
look at the table that follows, which will show you which component templates we will
implement and which chapters and, specifically, which topics we're pairing them up with.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 173 ]
The following is a list of our 13 wireframes from Chapter 1, Quick Start:
Home
Sign Up
Log In
Edit Profile (excluded from coverage in the book)
Property Listing (excluded from coverage in the book)
Create Listing
Edit Listing
Preview Listing
Property Details (excluded from coverage in the book)
Photo Listing
Upload Photo / Create Card
Edit Photo (excluded from coverage in the book)
Preview Photo
The following is a table of the wireframes that we will implement together in this book,
along with a list of their associated chapters and topics. You can use this as a kind of
roadmap in conceptually piecing together our application in your mind-meaning, at a
high level, you'll know in which chapter we'll be implementing various parts of the
component templates in our application:
Wireframe /component template Associated
chapters Associated topics
Home 3 Bootstrap grid
Sign Up 3, 8, 10 Modal dialog, ng-Bootstrap (input boxes), Forms
Log In 14 Authentication
Create Listing 5, 14 Flex-Layout, Custom validation
Edit Listing 5, 10 Flex-Layout, Forms
Preview Listing 5, 6, 9 Flex-Layout, Components, Angular Material (chips)
Photo Listing 6, 7 Components, Templates
Upload Photo / Create Photo
Card 10 Forms
Preview Photo 6, 9 Components, Angular Material (card)
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 174 ]
The preceding table shows us topics from which chapters we will be implementing in our
wireframes (that is, component templates). Np. by taking a look at the fourth row
from the top, we can see that when we implement our Create Listing wireframe (that is, our
CreateListingComponent), we'll be using Flex-Layout from this chapter and Custom
Validation from Chapter 14, Advanced Angular Topics.
Keep in mind that every wireframe will require components-despite not listing Chapter
6, Building Angular Components, in the associated chapters column and components in the
associated topics column. The reason I did this for some of the wireframes, such as Photo
Listing and Preview Photo, is that we're going to discuss components a little more than we
will, say, for the Sign-Up or Edit Listing wireframes. Also, certain wireframes will have us
focusing much more on other topics. Np. u can see for the Upload Photo
wireframe that we'll be focusing on forms, from Chapter 10, Working with Forms.
Since we won't be jumping from chapter to chapter, this means that we'll be revisiting the
majority of our pages (that is, component templates) two, three, or even four times, as we
progress through the book.
Implementing our selected wireframes
The 3 wireframes (that is, component templates) that I've selected to implement with
you in this chapter are the following:
Create Listing (included because there are many sections and elements within the
view)
Edit Listing (included for the same reason as Create Listing)
Preview Listing (included because there are very few elements within the view)
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 175 ]
In the listing of the aforementioned wireframes , you may have noticed that there are three
wireframes that have been marked as excluded from coverage in the book. Here is the
wireframe exclusion list, along with the reason for its exclusion:
Edit Profile: This has been excluded because it is just another edit form (much
like the Edit Listing screen)
Property Listing: This has been excluded because it is just another listing screen
(much like the Photo Listing screen)
Property Details: This has been excluded because it is a static screen that is
uninteresting to us, from an Angular perspective
Edit Photo: This has been excluded because it's yet again just another edit form
However, don't fret. All the code for the application that we'll be building together
throughout the remaining pages, including the code for the four wireframes that we won't
be implemented in the book, as well as the non-UI-based code (such as the Python-based
APIs in Chapter 12, Integrating Backend Data Services and more), are being made available
to you as a download. I have you covered.
One last noteworthy point and then we'll get on with some Flex-Layout coding. You can
tell that our application will require some wireframes to be revisited more than once so that
we can complete it-that is, we'll be building our application in pieces and in what seems
like a chaotic back and forth fashion. This is not because the author is off his rocker-as
some of his friends would love to tell you stories that make a strong case for just the
opposite-but rather, it is by design. Remember, the philosophy of this book is to maximize
your effectiveness of the absorption of the material, so you embark on the journey to
becoming an Angular guru as quickly as possible. To the extent possible, we will
immediately implement what material we cover so that it makes immediate sense, and
sticks. That's the goal-and is also why I wanted to include the preceding table (that is,
associating the wireframes with the chapters and topics).
There's typically a method to my madness (wink). Let's now turn our attention to the
implementation of the 3 wireframes for this chapter.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 176 ]
The Create Listing wireframe
In this section, we will bring all our knowledge and understanding together and learn to
create our application pages for the Create Listing page. Take a look at the following
wireframe, which we will convert into code using Flex-Layout:
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 177 ]
The other wireframe shows that we will need a header section and a two-column layout to
hold the form and input elements.
We will 1st create a new component in our application and call it Create Listing. In the
component template file, let's add the following sample code to the template:
<h1>Create Listing</h1>
<div fxLayout="row" fxLayoutAlign="space-between">
Logo Here
</div>
<div class="bounds">
<div class="content" fxLayout="row" class="menu">
<div fxFlexOrder="1">Manage Listings</div>
<div fxFlexOrder="2">Manage Photos</div>
<div fxFlexOrder="3">Manage eCard</div>
<div fxFlexOrder="4">Business Opportunity</div>
</div>
<div class="content"
fxLayout="row"
fxLayout.xs="column"
fxFlexFill >
<div fxFlex="60" class="sec1" fxFlex.xs="55">
<form action="/action_page.php">
<label for="lprice">Listing Price</label>
<input type="text" id="lprice" name="lprice"
placeholder="Listing price">
<label for="country">Property Type</label>
<select id="country" name="country">
<option value="australia">USA</option>
<option value="canada">UK</option>
<option value="usa">UAE</option>
</select>
<label for="laddress">Street Address</label>
<input type="text" id="laddress" name="laddress"
placeholder="Street Address">
<label for="city">City</label>
<input type="text" id="city" name="city" placeholder="City">
<label for="state">State/Province</label>
<select id="state" name="state">
<option value="New York">Australia</option>
<option value="New Jersey">Canada</option>
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 178 ]
<option value="Texas">USA</option>
</select>
<label for="pcode">Postal Code</label>
<input type="text" id="pcode" name="pcode"
placeholder="postal code">
<label for="sfoot">Square Foot</label>
<input type="text" id="sfoot" name="sfoot"
placeholder="Square Foot">
<label for="bedrooms"># Bedrooms</label>
<input type="text" id="bedrooms" name="bedrooms"
placeholder="Bedrooms">
<label for="bathrooms"># Bathrooms</label>
<input type="text" id="bathrooms" name="bathrooms"
placeholder="bathrooms">
<input type="submit" value="Submit">
</form>
</div>
<div fxFlex="40" class="sec2" >
<label for="ldescription">Listing Description</label>
<textarea id="ldescription" name="ldescription"
placeholder="Listing price"></textarea>
</div>
</div>
</div>
In the preceding code, we are creating a row using the fxLayout to create a placeholder for
our logo. Next, we are creating the menu links and, using fxFlexOrder, we are sorting the
menu links. Now, we will need to create a two-column layout, so we are now creating child
elements inside the fxLayout row with two divisions, each fxFlex for 60 and 40,
respectively. Inside the two columns, we will place our form input elements to create the
form, as shown in the wireframe. Run the app and we should see the output, as shown in
the following screenshot:
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 179 ]
We have got our layout ready for the Create Listing page. If you look closely, our labels are
not exactly next to the input fields. What needs to be updated? That's right; we need to
create a child column inside the main column. Try it out by way of your homework. Now,
on similar lines, we can easily implement our Edit Listing page.
The Edit Listing wireframe
In the previous section, we have created our Create Listing page. In this section, we will
learn to implement the page layout for our Edit Listing page. Take a look at the example we
will implement. Does it not look exactly the same as the Create Listing page? That's correct.
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 180 ]
The layout of the Create and Edit Listing pages will mostly be the same, except for the fact
that there is data loaded when we launch the Edit page, whereas in the Create screen, there
will be no data loaded initially:
Now, it's time for some code action. We will create a new component in our Angular
project named edit-listing and, in the component template file, we will reuse the same code
to create the layout from the Create Listing page to quickly get the Edit Listing page ready:
<h1>Edit Listing</h1>
<div fxLayout="row" fxLayoutAlign="space-between">
Logo Here
</div>
<div class="bounds">
<div class="content"
fxLayout="row" class="menu">
<div fxFlexOrder="1">Manage Listings</div>
<div fxFlexOrder="2">Manage Photos</div>
<div fxFlexOrder="3">Manage eCard</div>
<div fxFlexOrder="4">Business Opportunity</div>
</div>
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 181 ]
<div class="content"
fxLayout="row"
fxLayout.xs="column"
fxFlexFill >
<div fxFlex="60" class="sec1" fxFlex.xs="55">
<form action="/action_page.php">
<label for="lprice">Listing Price</label>
<input type="text" id="lprice" name="lprice"
placeholder="Listing price">
<label for="country">Property Type</label>
<select id="country" name="country">
<option value="australia">USA</option>
<option value="canada">UK</option>
<option value="usa">UAE</option>
</select>
<label for="laddress">Street Address</label>
<input type="text" id="laddress" name="laddress"
placeholder="Street Address">
<label for="city">City</label>
<input type="text" id="city" name="city"
placeholder="City">
<label for="state">State/Province</label>
<select id="state" name="state">
<option value="New York">Australia</option>
<option value="New Jersey">Canada</option>
<option value="Texas">USA</option>
</select>
<label for="pcode">Postal Code</label>
<input type="text" id="pcode" name="pcode"
placeholder="postal code">
<label for="sfoot">Square Foot</label>
<input type="text" id="sfoot" name="sfoot"
placeholder="Square Foot">
<label for="bedrooms"># Bedrooms</label>
<input type="text" id="bedrooms" name="bedrooms"
placeholder="Bedrooms">
<label for="bathrooms"># Bathrooms</label>
<input type="text" id="bathrooms" name="bathrooms"
placeholder="bathrooms">
<input type="submit" value="Submit">
</form>
</div>
<div fxFlex="40" class="sec2" >
Flex-Layout - Angular's Responsive Layout Engine Chapter 5
[ 182 ]
<label for="ldescription">Listing Description</label>
<textarea id="ldescription" name="ldescription"
placeholder="Listing price"></textarea>
</div>
</div>
In the preceding code, we are creating two rows, one for the header section and the other
for the content row. Inside the content row, we are creating two child columns using
fxRow, which will be populated with the form input field elements. The output will be
exactly the same as that of the Create Listing page.
Summary
This chapter provided a quick tour of exciting technology. Of course, a small book can be
written that is exclusively dedicated to FlexBox CSS and Flex-Layout, so covering it in just a
few pages does not do it the justice it deserves. If there is an industry that changes rapidly,
it is ours and so alternative technologies should be mentioned-and, if the technology was
exciting enough, maybe even get its own chapter-regardless of which tech book and
which technologies. This was precisely the case for Flex-Layout and this book. I wanted to
introduce Flex-Layout to you, in some depth.
We started the chapter with a quick review of the four options for the layout techniques,
explaining why FlexBox CSS is the best choice of the four. I then introduced Flex-Layout to
you and presented a few compelling reasons for why you should consider using it instead
of using FlexBox. Next, we saw how to integrate Flex-Layout into our Angular project, and
took a look at a few of its APIs. Lastly, we circled back to our wireframes (that is,
components) and associated each of them with the chapters in this book and then
implemented the components that were associated with this chapter.
I hope you enjoyed this chapter and will make it a point to experiment with Flex-Layout in
at least one of your web development projects. My prediction is that many Angular
developers will choose Flex-Layout as their tool of choice for laying out their components. I
was already leaning toward using Flex-Layout instead of Bootstrap's grid for my next
project, for all component templates.
In the next chapter, we are going to learn all about the building blocks of any Angular
applications - components. We will deep-dive to learn and create some cool stuff with
Angular components. Happy Reading.
6 Building Angular Components
Since the whole of Angular is composed of several interrelated parts, it's virtually
impossible to select one part of Angular as being more important than another. The
removal of any one of these parts renders the whole compromised-maybe even useless.
Having said that, if I had to pick one part that was really important, I'd pick components.
There are several really cool things about components, such as how when we build
components, we are basically also extending HTML, since we're creating custom HTML
tags. Components are TS classes and as we'll see a bit later on in this chapter, the
way we link our code to our custom HTML tag is via the @Component annotation. I'll also
explain what annotations are later in this chapter.
A quick word on the terminology used from this point forward: I've used the word parts
instead of the word components in order to avoid confusion, since the word component is an
overloaded word-it has different meanings in different contexts. Additionally, I use the
word page from a classical web application perspective, as opposed to the literal sense,
when talking about a view (that is, a screen).
Angular applications contain a single root component. However, when discussing an
application's screens or views, it is necessary to mention other components that act as root
components for that view. Np. the sign-up screen has a root component.
Here's a bullet point list of topics that we're going to cover together:
An Angular application as a tree of components
The @Component annotation
Properties of the @Component annotation
Content projection
Life cycle hooks
Component interface
Components that are needed to implement the 3 wireframes that are
associated with this chapter
Building Angular Components Chapter 6
[ 184 ]
Angular application architecture - a tree of
components
An Angular application is basically a tree of components. As we've learned in previous
chapters, Angular is an SPA framework and thus has a single page to leverage for
displaying its tree of components. We've seen that Angular has a single top-level
component, called the root component and depending on what we'd like our application to
do in response to our user's actions, we have that root component load up other
components. These other components (let's refer to them as 2ndary root components for
now) in turn recursively render additional components. The way in which we've wired up
our router in Chapter 4, Routing, is that we've mapped URLs to our 2ndary root
components-one per page, which springs into view when our users click on the navigational
(that is, menu) links.
What makes all this possible is that components are composable. This is to say that our
components are made up of other components and are thus nested. We can nest our
components in an arbitrarily deep component hierarchy, hence the statement at the very
beginning of this section, An Angular application is basically a tree of components.
The Angular framework takes care of recursively loading and rendering our components
for us.
Architecting an Angular application
Just as is the case with most engineering projects, software projects also need to have a
process for designing and architecting applications. The typical way to start is to break
down whatever you're building into separate chunks of work. In Angular's vernacular, this
means that we need to break down our application into separate components, each of
which is responsible for certain things, such as displaying the result of a calculation, or
accepting user input.
Once we have a list of components that we need to use (whether they are 3rd-party
components or custom components), we need to treat them as black boxes-or
mathematical functions. Let me explain what I mean by this.
When I say we need to treat our components as black boxes, I'm suggesting that we should
not let our mind be consumed with their implementation at this stage (that is, when we are
simply listing them). We'll concern ourselves with building our components a little later in
the chapter, but for now, treating them as black boxes is all we need to do.
Building Angular Components Chapter 6
[ 185 ]
When I say we need to treat our components as mathematical functions, I'm merely
suggesting that we think about what the output is going to be and what inputs are needed
for the function (that is, our component). The inputs and outputs of our components make
up their public interfaces. We'll be taking a closer look at component interfaces a bit later in
this chapter.
Breaking up your components into sub-components
The number of components in an application, or even per page, for that matter, varies
greatly. It can range from just a few to several hundred-or maybe even more. However,
there is a good rule of thumb for how far you should go in breaking up a component (such
as a sub-component that is the top-level component for that specific page) into subcomponents.
If you keep component reusability in mind, all you need to ask yourself as
you break down the component into sub-components is this: "Are there two or more parts
to this component that I can reuse elsewhere?" If the answer is yes, you can probably
benefit from breaking it down further. If the answer is no, then you're done-no more
breaking down of the component is necessary.
Let's consider a quick example, just to make this a bit less abstract. Assume that you have a
listing of items on a page-one row per item-and the item is a component. Let's also
assume that each item has a thumbnail image for whatever that item is. If the thumbnail
can be used elsewhere, maybe on the checkout page, or on the item detail page, then that
thumbnail should be its own component and a sub-component of the item component.
Zooming out a bit from the item listing example and starting from the page view, you may
take this approach to help you get started when planning your components:
Your page header is a component
You may have a quick-links section on the right-hand side of your page, which
would be another component
You have your main content section, taking up the majority of your screen real
estate, which would also be a component
Your page footer is also a component
From the preceding components, all of them are likely to be reusable, except for the main
content section. You may desire your page header and page footer, to be on every page
within your application-and you may want to re-display the quick-links section on
various pages. For these reasons, those components are probably fine as they are. No
further breakdown is required. The reason you will want to break down your main content
component is that it's not reusable because you're not likely to have two copies of the same
page!
Building Angular Components Chapter 6
[ 186 ]
Component responsibilities
Angular applications that are architected will have components that are not only reusable
but have well-defined boundaries. This is to say that they have a separation of concerns.
Each component does one thing and does it well. The components should be abstracted
away from one another and they should not know about each other's details (that is,
implementation). The one thing that they should know about each other is how to
communicate with each other. This is accomplished via their public interfaces and we'll
look at this shortly.
For now, all you need to know is that when you plan your application's components, you
should list their responsibilities. That is, write down what they will be doing. Astute
readers will probably see the connection between the use case diagrams and the lists of
component responsibilities, since components are how users will be interacting with the
application.
Annotations
Annotations are a new feature of TS. They are symbols, prefixed with the @ sign,
that we add to our code (that is, used to decorate our classes). Annotations can appear at
the top of our class declaration, or at the top of our functions, or even on top of our class
properties. What annotations do, generally speaking, is inject boilerplate code where they
are attached (that is, our class, function, or properties). While we don't need annotations,
since we can choose to write the boilerplate code ourselves, we're better off leveraging them
because the boilerplate code shouldn't have to be written over and over again.
Additionally, by using annotations instead of handwriting the boilerplate code, not only is
the drudgery removed, but we don't have error-prone code to contend with. We'll see more
annotations in various chapters of the book, but let's focus on the @Component and
@NgModule decorators for this chapter.
@Component
While annotations can appear at the top of our class declaration, or at the top of our
functions, or even on top of our class properties, the @Component annotation will always
appear at the top of our component's class declaration.
In order for the @Component annotation to become available to us, we have to import it like
this:
import { Component } from '@angular/core';
Building Angular Components Chapter 6
[ 187 ]
Let's look at that line of code for just a moment. It is JS-specifically, ES6. If you
recall from Chapter 2, ECMAScript and TS Crash Course, the part of the curly braces
of the statement is a new construct in ES6 called destructuring. Also, there is no explicit path
to the @angular/core module. We leave it to the CLI and TS compiler to figure
out where the module is and exactly how it should be loaded and made available to the
code in our class.
Properties of the @Component decorator
The @Component decorator provides us with a number of properties for the purposes of
configuring our components. Let's take a look at them.
selector
The selector is a property of the @Component annotation and its value (of type string) is
what gives the name to our custom HTML tag. I like cars, so here's an example car
component in code, showing its annotation, selector and class name:
@Component({
selector: 'car'
})
class CarComponent {
}
When Angular sees our custom HTML tags, <car></car>, it creates an instance of our
CarComponent and will replace our custom tags with some HTML that the browser
actually understands. OK, but where in our component class do we add stuff to give our
component sth more than a ghostly aura? The next section is the answer (that is, the
template property).
template and templateUrl
Our poor little car component has no visible body just yet. This is because Angular needs
to know what browser-friendly HTML to add when it renders our car component and we
just haven't provided that for Angular yet. The way to provide that is to use the template
property (of type string) to hold the HTML that Angular will render for us after it creates
the instance of the CarComponent class (any time it sees our custom tags, <car></car>).
Let's rectify this by beefing up our preceding @Component annotation:
@Component({
selector: 'car',
template: '<h3>What production car has the fastest acceleration
Building Angular Components Chapter 6
[ 188 ]
time from 0 to 60?</h3><p>Tesla </p>'
})
class CarComponent {
}
What would happen if our component required a lot of HTML? Well, this is why we have
another property that we can use, templateUrl. The templateUrl property provides us
with a way to externalize our component's HTML from our component class and have it in
a separate file. Your template property would look sth like this:
template: 'car.html'
styles and stylesUrls
The styles property is used for what you expect it to be used for-to add styling to our
component template. Just like the template property, the value is of type string. Also,
because it's easiest to read CSS when spaced over multiple lines, we'll be using the back-tick
character (new in ES6 and thus also available in TS), which enables us to create
what is known as template literals. Let's add the styles parameter to our CarComponent
class to see how this may look:
@Component({
selector: 'car',
template: '<h3>What production car has the fastest acceleration
time from 0 to 60?</h3><p>Tesla </p>',
styles: [`
.car {
color: #008000;
font-weight: bold;
}
`]
})
class CarComponent {
}
That's all there is to the styles property. I bet you can guess what the styleUrls
property does. Yup-it works just like the templateUrl property. It provides us with a
way to externalize our component's CSS from our component class and having it in
externalized style sheets. Note that I mentioned files, as in the plural of file. The styleUrls
property takes a value of an array of strings (as opposed to being of type String as what the
value of the templateUrl property is)-thus, we can pass multiple style sheets to it if we
wanted to.
Building Angular Components Chapter 6
[ 189 ]
So, by using a combination of the template, templateUrl, styles and styleUrls
properties, we can encapsulate the HTML (that is, our component template) and the CSS
we'd like to apply to our template, within our component class-thanks to the properties
that the @Component annotation makes available to us. And thanks to the selector
property, we can use custom HTML tags in our components' parent templates. Are you
starting to get a good feel for how all these things fit together? If not, no worries-you soon
will, when we start to implement our example application's views.
View encapsulation
View encapsulation is sth that is extremely convenient and very cool-as most
things in Angular are-and is used to configure the scope of our CSS.
Typically, when we create (or change) a CSS class, the style is applied throughout our
application and is not confined to a specific page, component and so on. Angular gives us a
level of control over this by allowing us to encapsulate (that is, restrict, or contain) our
styles to the components that contain the given style sheets/CSS. This is done
through another property of the @Component annotation, named encapsulation.
We can set the encapsulation of our component's styles to one of the following three
possible values:
ViewEncapsulation.Emulated: This is the default value and the effect is that
our styles will remain contained to just our component. They will not affect
anything else on our page(s). However, our component will still inherit, or have
access to, styles that are globally accessible to our application.
ViewEncapsulation.Native: This is basically the same thing
as ViewEncapsulation.Emulated, except that we are asking Angular to block,
or shield, our component from any globally defined styles. The effect is that our
component will be immune from any styles that are not assigned to our
@Component annotation's styles or styleUrls properties.
ViewEncapsulation.None: This is the setting that we would use if we didn't
want to control the level of CSS isolation at all. In other words, if we wanted to
let our component's CSS affect other page assets and also wanted our component
to inherit globally defined CSS rulesets, this is the setting that we would use.
Is this cool or what? What a feature! If you think about it, this is one of the things that make
code reuse, even between applications, not just within the same application, possible. If we
want to guarantee that our component will look the same across Angular applications,
regardless of any given application's styles, we can set our component's encapsulation
property to ViewEncapsulation.Native and we're good to go.
Building Angular Components Chapter 6
[ 190 ]
Module vs. NgModule
Terminology is everything because it is easy to confuse things due to their semantics. This
is especially true when the language/terms in the topics in question contain overloaded
words-as with Angular as the topic. Np. we've seen that we have to be pretty
specific about what we mean by the words component and page. The same thing applies to
the word module and so I'd like to clear sth up at this point before we continue on.
As we've seen in Chapter 2, ECMAScript and TS Crash Course, the notion of modules
is new in ES6. In JS, when we talk about a module, we are usually referring to a
code file that we can then import into the context of our executing script, making its
encapsulated functions available to our script. An Angular module, or NgModule, is a
module consisting of more than one file-hence, it's often referred to as a package. Because
we treat this NgModule, or package, in much the same way as a JS module-by
importing it-we often think of them as being equivalent, but they are not.
This chapter's focus is on components, but we will also take a look at constructing our own
NgModules in Chapter 11, Dependency Injection and Services, when we encapsulate our calls
to our backend APIs in one cohesive package.
Before we leave our discussion on NgModule, deferring further discussion to a later
chapter, I'd like to at least touch upon a couple of its parameters, since @NgModule is
another annotation that I had mentioned existed.
Properties of the @NgModule decorator
If you take a look at the app.module.ts file in the example application that we started
building in Chapter 4, Routing, you can see that there are four parameters in the
@NgModule annotation on our AppModule class. Let's take a quick look at these four and
what we use them for:
Declarations: This is where we list the components and directives that we will
need to package in this NgModule.
Imports: These make the exported declarations of other modules available to
our NgModule.
Providers: This is where we list services and values so that they become known
to dependency injection (DI). They are added to the root scope and are injected
to other services or directives that have them as a dependency. We're going to
cover DI in Chapter 12, Integrating Backend Data Services.
Building Angular Components Chapter 6
[ 191 ]
Bootstrap: This is where we list the component that we want Angular to
Bootstrap upon application startup.
There can only be one NgModule in our application where we make use of the Bootstrap
parameter-since the bootstrapping process starts with only one module.
Content projection
The notion of content projection provides component developers with a mechanism that
can increase their reusability. In particular, I'm referring to the way in which their data is
displayed (that is, rendered).
What this means is that instead of trying to create a component that has properties for each
possible way, its template can be altered (which is nearly impossible) so that the developers
that consume the component can vary the values of these properties to customize how it's
rendered. Content projection provides a way to accomplish this with much less ceremony.
The mechanism we use is a pair of ng-content tags, like this: <ng-content></ngcontent>.
We'll see this in practice in the Photo Listing page, but let me show you a contrived
example for now. Let's modify the template in our CarComponent to the following code
snippet (adding the pair of ng-content tags):
template: '<h3>What production car has the fastest acceleration time from 0
to 60?</h3><ng-content></ng-content>'
What this does is to enable the CarComponent's parent component to project content into
the CarComponent's template, thereby altering the template as desired. Let's assume that
instead of just showing the maker of the car in regular text, within a set of <p> tags, we'd
like to show the make of the car in a set of <strong> tags.
Here is what the parent component would look like:
<car>
<strong>Tesla</strong>
</car>
It would look like the preceding instead of the following:
<car></car>
Building Angular Components Chapter 6
[ 192 ]
Again, this was a contrived example. Also, the whole point of Angular is to have dynamic
data but we haven't done that here. Np. we'd have the car question and answer
data bound to elements within the component template, instead of having it hardcoded (to
What production car has the fastest acceleration time from 0 to 60? and Tesla, in this case.)
However, our simplified hardcoded code illustrates the notion of content projection in the
most straightforward way possible-by not dynamizing the data, as we'll be doing a bit
later in the book.
Projecting multiple sections
It is possible to include more than a single pair of ng-content tags. However, since
Angular will not be able to tell which projected content has replaced which set of ngcontent
tags, we need to label the ng-content tags in some fashion to disambiguate them
from one another.
A simple way to label, or mark, the ng-content tags so that the intended projected content
replaces the desired set of ng-content tags is to identify the elements by class names. We
label the tags by using an attribute of ng-content, named select. Let's extend our
contrived CarComponent example to see how this may look with two pairs of ngcontent
tags:
template: '<ng-content select=".question"></ng-content><ng-content
select=".answer"></ng-content>'
Here is what the parent component would look like:
<car>
<h3 class="question">What production car has the fastest acceleration
time from 0 to 60?</h3>
<span select="answer"><strong>Tesla</strong></span>
</car>
By using ng-content tags and its select attribute, if you have multiple content
projection targets, you can create components that are customizable by developers that
consume them.
Building Angular Components Chapter 6
[ 193 ]
Life cycle hooks
As with almost everything that is alive, from the stars in our solar system to the flowers
you may have bought to decorate your dining room table, Angular components also have a
life cycle-the different stages, or phases, they go through from the moment they spring
into existence to the moment they cease to exist.
We can hook into these different stages to run any code that we may want to have Angular
run for us as our component moves through them. This is made possible because Angular
provides us with special methods, one for each phase of the component life cycle, which
Angular calls for us. All we have to do is provide the code that we want Angular to
run-and the way we do that is to add functions, bearing the same name as the life cycle
hooks, to our component class.
There's a set of life cycle hooks for the component and there's also a set of life cycle hooks
for its children (that is, child components). The following table enumerates the most
common ones:
Life cycle hook Type Invoked when...
constructor Component Angular creates a component as a result of new being called on a
class.
ngOnInit Component A component has been fully initialized.
ngOnChanges Component A change has happened to an input property (called once per
chance).
ngOnDestroy Component Angular is about to destroy the component.
ngAfterContentInit Child After content projection occurs for the component.
ngAfterContentChecked Child Angular runs its change detection algorithm on the content.
ngAfterViewInit Child A component's view has been fully initialized.
ngAfterViewChecked Child Angular runs its change detection algorithm on the view.
Most common life cycle hooks
From the preceding eight life cycle hooks, you're most likely to use only 3 of them (in
most cases). All 3 fall into the component type of life cycle hook:
ngOnInit: Our initialization logic for our component will go here. You may
think that the constructor is the place to add the initialization logic,
but ngOnInit is preferable because any binding of data via our interface (that is,
input properties) will have been done. This isn't the case with the constructor
phase.
ngOnChanges: When we want to know what input properties have changed, and
to what they were changed to, this is the place to look.
Building Angular Components Chapter 6
[ 194 ]
ngOnDestroy: This is where we insert our cleanup logic for our component (if
we have any things we'd like to clean up-otherwise, we don't use it).
Here is an example of how we hook into the ngOnInit life cycle hook (we'll just write out
some output to our console):
class CarComponent {
ngOnInit() {
console.log('An instance of our CarComponent has
been fully initialized.');
}
}
Component interface - inputs and outputs, and
the flow of data
If you were to create a diagram of your components on a particular screen (that is,
view/page), drawing arrows between them to indicate the flow of data, the arrows would
point from one component's outputs to another component's inputs.
In code, as we'll see later in our implementations, the ways in which we bind outputs and
inputs are in our component templates (that is, in the HTML). But to have binding in
HTML, we need to create our components in code and we need to give them interfaces.
Let's take a quick look at a concrete example-it'll show how a parent component could
pass data to its child component. To demonstrate this, let's 1st create our two components.
Here is our DadComponent, which will be the parent component:
import {Component } from '@angular/core';
@Component({
selector: 'dad',
template: `<h1>Hello. {{message}}.</h1> <br/>
<son *ngFor="let name of arrSonNames"
[Name]="name">
</son>
`,
})
export class DadComponent {
message : string = "I'm a Dad";
arrSonNames = ['Justin','','Brendan'];
}
Building Angular Components Chapter 6
[ 195 ]
Here is our SonComponent, which will be the child component:
import { Component, Input, OnInit } from '@angular/core';
@Component({
selector: 'son',
template: `<h2>Hi. I'm a son and my name is {{_name}}.</h2>`
})
export class SonComponent implements OnInit {
_name: string;
constructor() {
console.log("The son component was just instantiated.");
}
ngOnInit(){
console.log("The son component is now fully initialized.");
}
@Input()
set Name(name : string ) {
this._name = (name && name.trim()) || "I am a son.";
}
get Name() {
return this._name;
}
}
There's a lot going on in this little bit of code. I won't describe what's going on in the
previous code blocks. Rather, I'd like for you to study it for a few minutes and see if you
can figure out what's going on. You should have enough information from previous
chapters, along with with some basic knowledge of JS/TS and an
understanding of getters and setters (as many languages have). I know you can do it-give
it a try. I'll give you two hints: 1) @Input() is a decorator and in this case, it creates the
public interface of SonComponent; 2) DadComponent will end up creating 3 instances
of SonComponent. Two of the sons will know their own name and unfortunately, one of
the sons won't know his name. What does he say? What are the names of the sons that do
know their name? Can you see why 3 sons are created? Can you guess what would be
written to the console and how many times it would be written?
We're going to see a lot of this pattern throughout our implementations, so don't worry if it
looks strange, or seems a bit complicated and you can't answer all of the questions I've
asked. This stuff should become 2nd nature to you after a while. And yes, I will be
explaining our implementation code from now on-not in excruciating detail, but in
enough detail for you to understand the material at hand. For now, I just wanted you to get
a feel for what this passing of data via component interfaces looks like.
Building Angular Components Chapter 6
[ 196 ]
Our implementation of the components for our
three pages
We now have enough knowledge to implement (that is, create in code) the components that
we will need for the following 3 pages of our example application:
Preview Listing
Photo Listing
Preview Photo
To generate those components, we will make use of the Angular CLI schematics. Run the
following commands and we should expect the components and required files to be autogenerated:
ng generate component photo-listing
ng generate component preview-listing
ng generate component preview-photo
Once the commands run successfully, we should see the output, as shown in the following
screenshot:
Building Angular Components Chapter 6
[ 197 ]
In the preceding screenshot, we can notice that the corresponding files have been generated
for the component and the app.module.ts file has been updated with the latest
components generated.
The final project structure of our application with components generated so far is as
follows:
Summary
We've covered a lot of ground in this chapter. You may have not completely understood
some of the code in the last section and this is OK because you will get good at this stuff as
we implement our pages for our example application together. Since this chapter was on
components, I just wanted to show you the general structure for how to set up parent and
child components and how to pass data from the parent to the child via the child's public
interface. However, you should now have a pretty good understanding of how an Angular
application is just a tree of components. What the rule of thumb is for breaking up your
components into sub-components and what are annotations and decorators.
We also studied what the @Component annotation/decorator is, what it's properties are, and
how to configure them. We then moved on to the @NgModule decorator is and what some
of its properties are and what purpose they serve. We then studied what content projection
is and how to use it to allow other developers that consume your components to customize
of their rendering.
Building Angular Components Chapter 6
[ 198 ]
Lastly we studied what life cycle hooks are, how to use them and reasons why you'd want
to use them. We then moved on to component interfaces are and how to create them.
Finally, we studies the implementation of the components we need for our 3 pages
(Preview Listing, Photo Listing and Preview Photo)
In the next chapter, Chapter 7, Templates, Directives and Pipes, we're going to zoom into the
template portion of components, since that's where all the data binding and rendering take
place-bringing our Angular application from a bunch of 0s and 1s to life on our screens.
Angular provides many tools, in the form of directives and pipes, for us to leverage, so we
can tell it how to paint on our canvas. So, turn the page over and let's learn about how we
can get Angular to start putting our component paint on our application canvas to bring
our application to life-which is where we'll place our components onto our 3 pages
(Preview Listing, Photo Listing and Preview Photo).
7 Templates, Directives, and
Pipes
Templates define how your components are displayed and laid out on your web pages.
Angular provides several built-in directives that provide developers control over the
display of their components-from whether to display or hide the component, to rendering
it multiple times on the page. Built-in directives also provide a mechanism for binding
classes and styles to your components.
In Chapter 6, Building Angular Components, we looked at the structure of a component and
how to break down our application into a tree of components.
In this chapter, you'll learn how to have command over the display of your components
within their parents' templates. Specifically, at a high level, here's what we're going to be
covering together:
Templates
Directives
Pipes
Templates
In the previous chapter, we've seen what component templates are and how to create them.
However, so far, we've only seen static HTML. In this section, I'd like to zoom in a little and
take a look at some template syntax with you that allows us to create dynamic HTML,
which, of course, is one of the main goals of Angular.
Templates, Directives and Pipes Chapter 7
[ 200 ]
Templating syntax in Angular provides us with a mechanism to make our HTML
dynamic-specifically, for data binding, property binding and event binding. We'll be
taking a look at these 3 types of binding in this chapter. The way in which Angular
gives us the power to create templates that produce dynamic HTML, or to manipulate the
DOM (more on this in just a little bit), is through a set of symbols.
Here are the six basic symbols that we can use:
{{ }} for string interpolation and 1-way data binding
[( )] for 2-way data binding
# for variable declaration
( ) for event binding
[ ] for property binding
* prepends structural directives, such as ngFor, as we'll see
Directives
The 3 types of the directives are: components, attribute directives and structural
directives. However we're really only going to cover two of the 3 types of directives-
attribute directives and structural directives. The reason for this is because we've already
spent an entire chapter covering the 1st type of directive and that was components. That's
right! Components are actually directives under cover! Specifically and stated another way
(which illustrates how components are differentiated from attribute and structural
directives), components are directives that have a template. Of course, this must mean that
attribute and structural directives do not have templates.
OK, so what exactly are directives, then? Let's give the term directives a distinct definition to
get rid of any possible confusion that this terminology may be causing before we move on
to discuss the the next two types of directives. The definition we'll be using is this: Angular
directives are constructs that provide specific DOM manipulation operations. DOM (or HTML
DOM) is an acronym for Document Object Model and is not an Angular thing-it is a
browser thing. All modern browsers create a DOM whenever a web page is loaded, which
is a tree of objects that is accessible by JS. Without the DOM, Angular (and any
other web framework that manipulates the DOM) would not exist.
Components, as we've seen in Chapter 6, Building Angular Components, fit our definition of
directives because they are indeed constructs that provide specific DOM operations. Not
only are their templates injected into our page (replacing their custom HTML tags), but
they themselves contain data, property and event bindings, which further manipulate the
DOM.
Templates, Directives and Pipes Chapter 7
[ 201 ]
We've now fully explained components in various ways and we'll see them in action
during the implementation of our wireframes throughout the rest of the chapters that
follow.
The remaining two types of directives do not inject any HTML templates in our pages or
views because they do not have any templates. However, they do manipulate the DOM-as
mandated by our previous definition of directives. Let's now look at what each of these
types of directives do.
Attribute directives
Attribute directives manipulate the DOM by changing the appearance or the behavior of
specific DOM elements. These types of directives are surrounded by brackets and are
attributes of an HTML element. The brackets are symbols (one of the five types of symbols
we listed at the beginning of this chapter) and they signal to Angular that it may need to
change either the appearance or the behavior of the element for which the directive is an
attribute of.
That last sentence was a mouthful, so let's take a look at a code example of the attribute
directive you're most likely to use. The directive I'm referring to is named hidden and will
cause Angular to either show or hide its element:
<div [hidden]="usertype != 'admin'">
This element and its contents, will be hidden for all users that are not
Admins.
</div>
In the previous code, we've hidden the div element and any embedded HTML from all
user types that are not admins. Here, usertype and admin are, of course, applicationcontextual
things and are only used as an example to illustrate what Angular can do.
More generally, the hidden attribute directive is associated with an expression to be
evaluated. The expression must evaluate to a Boolean (that is, true or false). If the
expression evaluates to true, Angular will hide the element from the view. Conversely, if
the expression evaluates to false, Angular will leave it alone and it will be displayed in
the view.
As I did in previous chapters, I will make sure to point you to the official documentation
online. As you know by now, I'm not a fan of the approach that a lot of other IT books take,
which is to regurgitate documentation. While it's unavoidable to some extent, some books
fill most of their pages with it. So, I will continue to stay away from that trap and will
continue to add all the value I can in better ways.
Templates, Directives and Pipes Chapter 7
[ 202 ]
That being said, the official online documentation for attribute directives can be found
at https://angular. io/ guide/ attribute- directives.
Structural directives
Structural directives manipulate the DOM by adding or removing specific DOM elements.
Just as we have syntax we can use to signal to Angular that we have an attribute directive
to which it needs pay attention to, with the brackets symbol, we have the equivalent for
structural directives.
The syntax we use to signal to Angular that we have a structural directive it needs to pay
attention to is the asterisk (*). Structural directives are prefixed with an asterisk, which
signals to Angular that it may need to add or remove elements from the DOM. As I
enumerated at the beginning of the chapter, the asterisk is another one of the symbols we
can use in our template syntax.
NgFor
Just as we look at a code example of the attribute directive you are most likely to use, let's
now take a look at a code example of the structural directive you will probably use most
often-NgFor:
<ul>
<li *ngFor='let car of [{"make":"Porsche", "model":"Carrera"},
{"make":"Ferrari", "model":"488 Spider"}]'>
{{ car.make }}: {{ car.model }}
</li>
</ul>
The previous ngFor code example prints out the following:
Porsche: Carrera
Ferrari: 488 Spider
There are a few things I'd like to point out in the previous code; 1stly, the *ngFor
structural directive. Let's take a look at these in bullet-point form:
ngFor takes an iterable and loops through it, adding elements to the DOM
The general form of the directive's syntax is *ngFor="let <value> of
<collection>"
NgFor (note the capital N) refers to the class that defines the directive
Templates, Directives and Pipes Chapter 7
[ 203 ]
ngFor (note the lower case n) refers to both the attribute name, as well as it being
an instance of the NgFor class
The rest of the structural directives follow the same casing convention as NgFor
(see the previous two bullet points)
We can nest ngFor (in much the same way that we can have nested for each...i
n loops)
Next, the collection I've provided to the ngFor directive is not indicative of how we would
normally pass data to the directive. I've coded it this way for brevity. The way we'd
normally do this is to have the data (that is, our collection) defined within our component
class and assigned to a variable and then use that variable in the statement attached to the
directive.
Accessing the index value of the iteration
We'll often be interested in having access to the index value of the iteration-maybe to grab
every nth object, or to group things in numbers of x, or maybe we want to implement some
kind of custom pagination. Whatever the need to read the current index value of the
iteration, we can use the index keyword to set the index to a variable within our
expression.
Here's some example code demonstrating this:
<ul>
<li *ngFor="let car of cars; let i = index">
Car #{{ i + 1 }}: {{ car.model }}
</li>
</ul>
In the previous code sample, let's just assume that the cars collection was populated
elsewhere-such as in the component class.
Also, Angular takes care of updating the index value with each iteration for us-and all we
have to do is to reference it.
Note that we use {{ i + 1 }} to output the car number. This is because, as with most
arrays or iterables (in most languages, but certainly in JS and TS), the index
is zero-based. Also, note that the expression within the double curly braces, i + 1, is not
just a variable. In Angular, whatever is inserted within the double curly braces is evaluated.
We could even insert function calls there if we wanted to.
The official online documentation for structural directives is available at https://angular.
io/ guide/ structural- directives.
Templates, Directives and Pipes Chapter 7
[ 204 ]
Built-in directives
There are a few built-in directives that we have at our disposal. Let's take a peek at these in
the sections that follow:
NgFor (we've already covered this one, as the 1st example of a structural
directive)
NgIf
NgSwitch, NgCase and NgDefault
NgStyle
NgClass
NgNonBindable
NgIf
When we want to either display or remove an element from the DOM, we use the NgIf
directive. We pass an expression to the directive and it must evaluate to a Boolean. If it
evaluates to true, the element will be displayed on the view. Conversely, if the expression
evaluates to false, the element will be removed from the DOM.
Note that we can also bind to the hidden property (property binding will be described as
follows) to achieve the same thing, visually, but there is a difference between the property
binding method and using the NgIf directive. The difference is that using property
binding on hidden just hides the element, whereas using the NgIf directive physically
removes the element from the DOM.
Here is what NgIf looks like in code (in the context of our car example, assume we had a
horsepower property):
<ul *ngFor="let car of cars">
<li *ngIf="car.horsepower > 350">
The {{ car.make }} {{ car.model }} is over 350 HP.
</li>
</ul>
In most traditional programming languages when there are alternate things to check for in
sequence, as in a series of traditional if, then and else statements, it sometimes makes
more sense to use a switch statement (if the language supports one). Java, JS, and
TS are examples of languages (and there are, of course, many others) that support
this conditional construct. Angular gives this power to us as well, so we can be more
expressive and efficient with our code.
Templates, Directives and Pipes Chapter 7
[ 205 ]
Let's take a look at how this is accomplished in Angular in the next section.
NgSwitch, NgCase and NgDefault
In several programming languages, such as Java, JS and TS, the switch
statement does not work in isolation. It works in concert with other statements and
keywords-namely, case and default. Angular's NgSwitch directive works exactly the
same way, in that NgSwitch works in concert with NgCase and NgDefault.
Let's flesh out a slightly larger example here by creating a component that will contain our
car data, our styling and our template, which makes use of NgSwitch, with NgCase and
NgDefault:
@Component({
selector: 'car-hp',
template: `
<h3>Cars styled by their HP range</h3>
<ul *ngFor="let car of cars" [ngSwitch]="car.horsepower">
<li *ngSwitchCase="car.horsepower >= 375" class="super-car">
{{ car.make }} {{ car.model }}
</li>
<li *ngSwitchCase="car.horsepower >= 200 && car.horsepower
< 375" class="sports-car">
{{ car.make }} {{ car.model }}
</li>
<li *ngSwitchDefault class="grandma-car">
{{ car.make }} {{ car.model }}
</li>
</ul>
`,
styles: [`
.super-car {
color:#fff;
background-color:#ff0000;
},
.sports-car {
color:#000;
background-color:#ffa500;
},
.grandma-car {
color:#000;
background-color:#ffff00;
}
`],
encapsulation: ViewEncapsulation.Native
})
Templates, Directives and Pipes Chapter 7
[ 206 ]
class CarHorsepowerComponent {
cars: any[] = [
{
"make": "Ferrari",
"model": "Testerosa",
"horsepower": 390
},
{
"make": "Buick",
"model": "Regal",
"horsepower": 182
},
{
"make": "Porsche",
"model": "Boxter",
"horsepower": 320
},
{
"make": "Lamborghini",
"model": "Diablo",
"horsepower": 485
}
];
}
In the preceding code, we've constructed a complete component named
CarHorsepowerComponent. Within the parent component template, Angular will replace
instances of our custom HTML element, <car-hp>, with the template we've created in
our CarHorsepowerComponent (this is because we assigned car-hp to the selector
property of the component annotation of our CarHorsepowerComponent class).
We've also included the data for the collection we're passing to the NgFor directive within
our component class, as opposed to it being inline within the expression assigned to the
NgFor directive, as we did in a previous example.
This was a simple example whose template iterates through our cars collection and applies
one of 3 styles to the make and model of the cars based on the current car's
horsepower-and this is accomplished via the NgSwitch, NgCase and NgDefault
directives. Specifically, here's the result:
If the car's horsepower is equal to or greater than 375 HP, we're going to consider
it to be a supercar and will have the car's make and model rendered in white font
with a red background
Templates, Directives and Pipes Chapter 7
[ 207 ]
If the car's horsepower is equal to or greater than 200 HP, but less than 375 HP,
we're going to consider it to only be a sports car and will have the car's make and
model rendered in black font with an orange background
If the car's horsepower is anything under 200 HP, which is our default (or catchall)
case, we're going to consider it to be a car that is suitably safe for a
grandmother to drive and will have the car's make and model rendered in black
font with a yellow background-because most grandmothers find the color
scheme of honey bees to be attractive
Of course, the grandmother comment was for entertainment value only and I'm not trying
to intentionally offend anyone who drives a car that takes a full 8 seconds, or more, to
accelerate from 0 to 60 MPH (wink). Truth be told, one of my cars (a 2016 Honda Civic)
only has 158 HP-and believe me, I've been passed on the road going uphill by a
grandmother driving an Infinity Q50. That's why I bought sth more powerful
within the next couple of days after that horrible experience (big smile).
One last thing I wanted to point out in this previous example is the way in which the
NgSwitch directive was used. You'll note that I wrote it in a different format,
namely [ngSwitch]="car.horsepower", instead of *ngSwitch="car.horsepower".
This is because there is a rule that Angular imposes on us when it comes to structural
directives, which is that we cannot have more than one structural directive using the
asterisk symbol prepending the directive's name. To work around this, we used the
property binding symbol, [ ] (a pair of square brackets).
NgStyle
The NgStyle directive is used for setting an element's style properties. Let's rework our
previous CarHorsepowerComponent example, which used to demonstrate NgSwitch,
NgCase and NgDefault, in order to show how the same desired outcome (that is,
conditionally styling elements) can be better done using NgStyle:
@Component({
selector: 'car-hp',
template: `
<h3>Cars styled by their HP range</h3>
<ul *ngFor="let car of cars">
<li [ngStyle]="{ getCarTextStyle(car.horsepower) }" >
{{ car.make }} {{ car.model }}
</li>
</ul>
`,
encapsulation: ViewEncapsulation.Native
Templates, Directives and Pipes Chapter 7
[ 208 ]
})
class CarHorsepowerComponent {
getCarTextStyle(horsepower) {
switch (horsepower) {
case (horsepower >= 375):
return 'color:#fff; background-color:#ff0000;';
case (horsepower >= 200 && horsepower < 375):
return 'color:#000; background-color:#ffa500;';
default:
return 'color:#000; background-color:#ffff00;';
}
}
cars: any[] = [
{
"make": "Ferrari",
"model": "Testerosa",
"horsepower": 390
},
{
"make": "Buick",
"model": "Regal",
"horsepower": 182
},
{
"make": "Porsche",
"model": "Boxter",
"horsepower": 320
},
{
"make": "Lamborghini",
"model": "Diablo",
"horsepower": 485
}
];
}
In our reworking of the original CarHorsepowerComponent class, we've lightened up our
component template by moving the logic into a function within the class. We've removed
the styles property of the component annotation and instead created a function (that is,
getCarTextStyle) to return the style text to the calling function so that we can set the
correct style.
Though this is a cleaner approach, we can do even better. Since we're setting a style for the
car text, we can just change the style class altogether, as opposed to passing the actual style
rulesets via text.
Templates, Directives and Pipes Chapter 7
[ 209 ]
In the next section, on NgClass, we'll rework our code one more time to see how this is
done.
NgClass
The NgClass directive is similar to the NgStyle directive, but is used to set the style class
(from the CSS rulesets with the styles property of the component annotation), instead of
setting the style via the raw CSS rulesets.
The following code example is the best choice of the last 3 code examples in order to
achieve what we want to do:
@Component({
selector: 'car-hp',
template: `
<h3>Cars styled by their HP range</h3>
<ul *ngFor="let car of cars">
<li [ngClass]=" getCarTextStyle(car.horsepower) " >
{{ car.make }} {{ car.model }}
</li>
</ul>
`,
styles: [`
.super-car {
color:#fff;
background-color:#ff0000;
},
.sports-car {
color:#000;
background-color:#ffa500;
},
.grandmas-car {
color:#000;
background-color:#ffff00;
}
`],
encapsulation: ViewEncapsulation.Native
})
class CarHorsepowerComponent {
getCarTextStyle() {
switch (horsepower) {
case (horsepower >= 375):
return 'super-car';
case (horsepower >= 200 && horsepower < 375):
return 'sports-car';
default:
Templates, Directives and Pipes Chapter 7
[ 210 ]
return 'grandmas-car';
}
}
cars: any[] = [
{
"make": "Ferrari",
"model": "Testerosa",
"horsepower": 390
},
{
"make": "Buick",
"model": "Regal",
"horsepower": 182
},
{
"make": "Porsche",
"model": "Boxter",
"horsepower": 320
},
{
"make": "Lamborghini",
"model": "Diablo",
"horsepower": 485
}
];
}
Here, we've kept our styles property for our component annotation, we've kept the
template light and clean and our function just returns the name of the CSS class to be
assigned to our NgClass directive.
NgNonBindable
The last directive in our list to cover is the NgNonBindable directive. NgNonBindable is
used when we want Angular to ignore the special symbols in our template syntax. Why
would we want to do this? Well, let's say that you and I decided to create an online Angular
tutorial and the website itself was to be coded using Angular. If we wanted to render the
text {{ my_value }} to the view, Angular would try to find the my_value variable within
its current scope to bind the value and then insert the text in its place. Since this is not what
we'd want Angular to do, we need a way to instruct Angular, Hey, by the way, do not try and
evaluate and string interpolate anything right now-just render the symbols as you would with any
other normal text.
Templates, Directives and Pipes Chapter 7
[ 211 ]
Here is what this looks like for, say, a span element:
<p>
To have Angular perform 1-way binding and render the value of my_value
onto the view, we use the double curly braces symbol like this: <span
ngNonBindable>{{ my_value }}</span>
</p>
Note the placement of the NgNonBindable directive within the opening <span> tag. When
Angular sees ngNonBindable, it will disregard the double curly braces and will not oneway
bind anything. Instead, it will let the raw text be rendered to the view.
Data binding using the NgModel directive
We've seen an example of 1-way data binding within our example that demonstrated
how to use the NgFor directive. Namely, 1-way data binding is done using the double
curly braces symbol, {{ }}. The variable that we enclose within the double curly braces
(such as car.make and car.model from the example) is bound 1-way (that is, from the
component class to the template), converted to a string and rendered to the view. It does
not allow for binding any changes back to the component class.
In order for us to implement 2-way data binding, thereby also allowing the binding of
changes within the view back to the component class, we have to use the NgModel
directive.
We're going to see this in action when we implement our wireframes, but let me show you
what this looks like for now. In order to use NgModel, we have to 1st import an Angular
module named FormsModule from the forms package, like this:
import { FormsModule } from '@angular/forms';
Then, to use this directive, we'd have sth like this:
<div [(ngModel)]="my_content"></div>
Having this code in place would not only cause the view template to display the value of
my_content in the component class, but any changes to this div within the view template
would be then be bound back to the component class.
Templates, Directives and Pipes Chapter 7
[ 212 ]
Event binding
We're going to see a lot of event binding during our implementation of the example
application's wireframes. To bind an event that we're interested in listening for on an
element, we enclose the event name within parentheses (which are one of our special
symbols that we can use in our template syntax). To do so, we assign a statement to be run
when the event is triggered.
Here is an example of a JS alert that will be triggered when someone clicks within
the <span> element:
<span (click)="alert('This is an example of event binding in
Angular');"></span>
In the preceding code, we have attached a click event and we invoke an alert box with the
message.
Property binding
We've seen property binding in previous examples, but for completeness, I will very briefly
give another example here:
<p class="card-text" [hidden]="true">This text will not show.</p>
In this previous example, we enclose the property we want to set within square brackets
(which are one of the special symbols that we can use in our template syntax). Of course,
this is not that useful in this example, because I've hardcoded the Boolean to true instead
of using an expression that is to be evaluated-but the point of this example was to focus
on the [hidden] part.
Custom directives
Angular is extensible. Not only can we easily create our own custom components (so that
we're not restricted to using ready-made components from 3rd parties), but we can also
create our own attribute directives so that we're not restricted to what Angular gives us out
of the box.
Templates, Directives and Pipes Chapter 7
[ 213 ]
I'll leave some of the custom things we can do in Angular, such as custom attribute
directives, custom pipes (we'll see what pipes are in the next section) and custom form
validation, until Chapter 14, Advanced Angular Topics. We'll be taking a look at form
validation in Chapter 10, Working with Forms. There's a good reason why I chose to lump
all of the advanced stuff that is covered in this book into one chapter-to give you time to
digest the basic stuff 1st. By the time the advanced chapter comes along, near the end of
the book, you'll be ready and primed to more easily absorb that information.
Pipes
Pipes are used for formatting the data in our template views. Pipes will take data as input
and transform it into our desired format for displaying it to end user. We can use the pipe
property (|) in any Angular template or view in our project.
Let me give you a quick rundown before we jump into creating our examples. Let's say
that, from the backend service, we get the price of a product as 100 and based on the user's
country or preference, we may want to display the value as $100 if the user is from the
USA, or INR 100 if the user is from India. So, we are able to transform the way that we
display the price without any major complexity. This is thanks to the currency pipe
operator.
Angular provides a lot of built-in pipes ready to use directly in our templates. Additionally,
we can also create our own custom pipes to extend our application's functionality.
Here's the list of all the built-in pipes that Angular provides:
Lowercase pipe
Uppercase pipe
Date pipe
Currency pipe
JSON pipe
Percent pipe
Decimal pipe
Slice pipe
We will learn about each of the available built-in pipes by doing some fun, practical
examples. We can make use of any of the existing template files that we have created in our
Angular project so far.
Templates, Directives and Pipes Chapter 7
[ 214 ]
We will need some data that we want to process and transform using our pipes. I am going
to quickly create a dataset in our app.component.ts file:
products: any[] = [
{
"code": "p100",
"name": "Moto",
"price": 390.56
},
{
"code": "p200",
"name": "Micro",
"price": 240.89
},
{
"code": "p300",
"name": "Mini",
"price": 300.43
}
];
We have created a sample dataset for products in our app component. Great, now we are
good to apply our pipes in our app.component.html file. We are going to keep it simple
in our template. We will just create a table and bind the values in the table. If you are
feeling a little adventurous today, go ahead create a layout for our application using Flex-
Layout, which we learned in Chapter 5, Flex-Layout - Angular's Responsive Layout Engine:
<h4>Learning Angular Pipes</h4>
<table>
<tr>
<td>Product Code</td>
<td>Product Name</td>
<td>Product Price</td>
</tr>
<tr *ngFor="let product of products">
<td>{{product.code}}</td>
<td>{{product.name}}</td>
<td>{{product.price}}</td>
</tr>
</table>
Templates, Directives and Pipes Chapter 7
[ 215 ]
In the preceding sample code, we have created a table and, using the data binding, we have
bound the data in our template. Now it's time to use the pipe operator in our template. To
apply any pipe, we will have to add the pipe operator against the data, as shown in the
following syntax:
{{ data | <pipe name> }}
We can easily transform our product name into uppercase by applying the uppercase pipe,
as follows:
<td>{{product.name | uppercase }}</td>
Similarly, we can apply the lowercase pipe as well, which will make all characters
lowercase:
<td>{{product.name | lowercase }}</td>
That was very simple, you might say? So it is! Let's keep rolling. In a similar way, we will
use the number pipe operator to show or hide the decimal points.
For displaying product prices, we want to add the currency; no problem, we will use the
currency pipe:
<td>{{product.price | currency }}</td>
In the preceding example, we have transformed the product price by adding the currency
pipe. The remaining pipe operators I am leaving to you as homework.
By default, $ currency is added when we use the currency pipe.
We can customize it by parameterizing the currency pipe. We will learn how to pass
parameters to the pipe operators. We will have to extend the syntax of the pipe operator by
passing the parameters as follows:
{{ data | pipe : <parameter1 : parameter2> }}
The preceding syntax looks similar to how we learned to define a pipe operator, except that
now it has two parameters. We can define a pipe operator with any number of parameters
based on our requirements. We have used the currency operator in the previous example,
so let's pass parameters to extend the currency pipe operator:
<td>{{ product.price | currency: 'INR' }}</td>
Templates, Directives and Pipes Chapter 7
[ 216 ]
We are passing the INR parameter to our currency pipe operator. Now, the output of the
currency pipe operator will not be $ anymore; instead, it will be as shown in
the following screenshot:
We have learned to use built-in pipe operators in this section. Now, we'll learn about
creating our own custom pipes. .
Custom pipes
Angular is extensible in this area of custom pipes as well as well as custom directives.
However, I'm deferring our discussion of custom pipes until Chapter 14, Advanced Angular
Topics. I've included this section here as a placeholder and a reminder of later coverage, as
well as for completeness.
Summary
In this chapter, we zoomed in on component templates and on what template syntax was
available to us for creating them. Our template syntax included symbols, directives, and
pipes.
We've seen that directives are just templateless components and they come in two main
flavors-attribute directives and structural directives. Whatever their flavor or category,
we associate (or attach) directives to HTML elements by adding them as attributes of those
elements.
We've gone over the following special symbols that we can use in our template
syntax. We've also covered the built-in directives that we can use in our template syntax.
Next, we covered event binding, as well as property binding and finally, we covered pipes,
which provide us with the means to format our data so that it can be rendered to our views
in the way we desire.
Templates, Directives and Pipes Chapter 7
[ 217 ]
We know that Angular is extensible and that it provides us with mechanisms to create
custom directives, as well as custom pipes-but we are deferring our discussion of
anything custom to Chapter 14, Advanced Angular Topics.
In the next chapter, Chapter 8, Working with NG Bootstrap, we're going to put our
component hats back on our heads so that we can explore what ng-bootstrap brings to
the table for us in building our Angular applications.
8 Working with NG Bootstrap
Bootstrap is one of the most popular CSS frameworks around-and Angular is one of the
most popular web application frameworks around. NG Bootstrap is a collection of widgets
(that is, components) that are built from Bootstrap 4 CSS. They are tailor-made to be used as
Angular components and are intended to be a complete replacement of Bootstrap
components, which are powered by JS. A few examples of JS-powered
Bootstrap components include the following:
Carousel
Collapse
Modal
Popovers
Tooltips
In this chapter, we're going to continue our exploration of components, but will focus on
ng-bootstrap, which is a 3rd-party Angular component library, as opposed to being a part
of the Angular code base. This chapter and Chapter 9, Working with Angular Material, are
relatively short chapters, but I wanted to include them in this book for the same reason I
mentioned for having included Chapter 5, Flex-Layout - Angular's Responsive Layout
Engine-and that is to give you choices. In the context of this chapter, that means having
choices of ready-made components that you can leverage for your Angular applications.
ng-bootstrap doesn't have an official acronym, but for the purposes of convenience, in this
chapter, I'm going to give it one. We'll be referring to NG Bootstrap as NGB-which, as it
turns out, is also a fun thing to type on the keyboard (since the letters are so closely placed
together). Try it.
Working with NG Bootstrap Chapter 8
[ 219 ]
As in all the other chapters in this book, I will not consume page upon page to simply
regurgitate NGB's official documentation, which is freely available online, just to make the
book seem formidable. I'd rather give you a 300-to 400-page book filled with hand-selected
goodness that keeps you reading, rather than a 500-600-page book that can be used as a
sleep narcotic, for your hard-earned money. That being said, NGB's official online
documentation can be found here:
https://ng- bootstrap. github. io.
One last thing I wanted to mention really quickly is that this chapter and the following one
(Chapter 8, Working with NG Bootstrap) will be a lot more visual than the other chapters in
the book. This is because we're now getting into the actual meat of our example application,
and we're going to start building things out visually.
With the housekeeping matters now out of the way, here's what we're going to be covering
together in this chapter:
Integrating NGB
NGB widgets (specifically, collapse, modal and carousel)
Design rules of thumb that we should think about to help avoid overuse of
widgets
Integrating NGB
NGB's purpose in life is to be a complete replacement for Bootstrap's components that
require JS (such as the components listed at the beginning of the chapter). In fact,
on the very 1st page of the Getting Started section on their official website, they go further
and say that you shouldn't be using any JS-based components at all-or even their
dependencies, such as jQuery or Popper.js. This can be found at: https://ng- bootstrap.
github. io/ #/ getting- started.
Installing NBG
1st things 1st: before we take a look at a caveat that we need to be aware of when using
NGB, let's add it to our project-and I'll also show you how to fix the conflicting libraries
that you may encounter (by showing you my package.json file).
Working with NG Bootstrap Chapter 8
[ 220 ]
Installing NGB is straightforward using npm. But, like other modules, we also need to
import it and list it in our root module (that is, app.module.ts). Here are the steps:
1. Run npm install: npm install --save @ng-bootstrap/ng-bootstrap
2. Import NGB into our root module: import {NgbModule} from '@ngbootstrap/
ng-bootstrap';
3. List NgbModule in the imports array (as a parameter to the root
module's @NgModule decorator) like this: NgbModule.forRoot()
If you create an Angular module that uses NGB, you'll have to import NGB into it as well.
The syntax for importing NGB into other modules is the exact same as the one just outlined
for importing it into our root module, but the syntax for listing the NGB module as a
parameter to the module's @NgModule decorator is slightly different. It's just listed in the
imports array as NgbModule, as opposed to NgbModule.forRoot(), as we have to list it in
our root module.
So, how are we going to take a look at a few of their components without unintentionally
messing up the NGB portions of our example application? There's only one way-we're
going to make sure that we do not directly or indirectly load jQuery or Popper.js into our
example application, by not using the Bootstrap components (make sure you understand
that Bootstrap and NGB are two different libraries).
Let me clarify sth real quick. We have jQuery and Popper.js installed in our example
application and you can verify this by taking a look at our package.json file. In it, you
will see entries for jQuery and Popper.js listed in the dependencies section. We are not
going to be uninstalling these libraries. They are harmless to our use of NGB as long as we
don't load them by also using Bootstrap. To put it another way, NGB components and
Bootstrap components should not coexist in our Angular applications. We can use one or
the other without issue-but never both. Does that make sense? OK, good.
If you try to remove jQuery and / or Popper.js from the project, you will likely get several
compile warnings whenever you run the project. While warnings may not prevent the
project from running, always try to strive for clean builds.
Working with NG Bootstrap Chapter 8
[ 221 ]
The chore of ensuring you get a clean build can sometimes be a pain in the neck, because
you need to pay attention to the versions of your libraries. The code listing that follows is
my package.json file. I consistently get a clean install compilation when I run npm
install and then npm start. If you're not getting a clean compilation, you may want to
compare your package.json against mine, as shown here:
{
"name": "listcaro",
"version": "0.0.0",
"license": "MIT",
"scripts": {
"ng": "ng",
"start": "ng serve -o",
"build": "ng build --prod",
"test": "ng test",
"lint": "ng lint",
"e2e": "ng e2e"
},
"private": true,
"dependencies": {
"@angular/animations": "^6.0.4",
"@angular/cdk": "^6.2.1",
"@angular/common": "^6.0.4",
"@angular/compiler": "^6.0.4",
"@angular/core": "^6.0.4",
"@angular/flex-layout": "^6.0.0-beta.16",
"@angular/forms": "^6.0.4",
"@angular/http": "^6.0.4",
"@angular/platform-browser": "^6.0.4",
"@angular/platform-browser-dynamic": "^6.0.4",
"@angular/router": "^6.0.4",
"@angular/material": "^6.2.1",
"@ng-bootstrap/ng-bootstrap": "^2.1.0",
"bootstrap": "^4.0.0",
"core-js": "^2.4.1",
"jquery": "^3.3.1",
"npm": "^6.1.0",
"popper": "^1.0.1",
"popper.js": "^1.14.3",
"rxjs": "^6.0.0",
"save": "^2.3.2",
"zone.js": "^0.8.26"
},
"devDependencies": {
"TS": "2.7.2",
"@angular/cli": "~1.7.4",
"@angular/compiler-cli": "^6.0.4",
Working with NG Bootstrap Chapter 8
[ 222 ]
"@angular/language-service": "^5.2.0",
"@types/jasmine": "~2.8.3",
"@types/jasminewd2": "~2.0.2",
"@types/node": "~6.0.60",
"codelyzer": "^4.0.1",
"jasmine-core": "~2.8.0",
"jasmine-spec-reporter": "~4.2.1",
"karma": "~2.0.0",
"karma-chrome-launcher": "~2.2.0",
"karma-coverage-istanbul-reporter": "^1.2.1",
"karma-jasmine": "~1.1.0",
"karma-jasmine-html-reporter": "^0.2.2",
"protractor": "~5.1.2",
"ts-node": "~4.1.0",
"tslint": "~5.9.1"
}
}
You can take a look at the list of available Angular modules and their
latest version numbers, that you can install with npm at: https://www.
npmjs.com/ ~angular.
Why use NGB?
With the restrictions of not being able to have JS-based components, nor directly
using JS libraries such as jQuery or Popper.js, you may be asking, why use NGB at
all?
That's a good question. Here's the short answer, in point form:
Angular does not depend on jQuery. It uses its own implementation of jQuery,
called jQLite, which is a subset of jQuery.
We don't lose out on being able to use any Bootstrap components that are
powered by JS (such as modal or carousel) because they are re-done for
Angular in NGB. Again, NGB's sole purpose in life is to completely replace any
JS-powered Bootstrap components.
Working with NG Bootstrap Chapter 8
[ 223 ]
A rule of thumb when building Angular applications is to try to only use
Angular-specific components; that is to say, components that are specifically
made for Angular-such as NGB widgets and components from Angular
Material. This, of course, includes creating your own custom Angular
components. Though you can work around this by jerry-rigging non-Angularspecific
components, it's not recommended. Angular is full featured and as
we've learned, it's also extremely extensible. It would be very difficult to think of
a use case where sticking to Angular-specific components, modules, directives,
pipes, services and so on would prevent you from doing what you needed to do.
NGB is a solid Angular-centric component library and works well when you
don't try to create workarounds that are discouraged.
Creating our playground for NGB (and Angular
Material and more)
There are only two dependencies for NGB (Angular and Bootstrap CSS) and luckily our,
example application already has these two things in place-one by default (since our
example application is an Angular application) and the other from our having installed
Bootstrap during Chapter 3, Bootstrap - Grid Layout and Components. However, we are
going to add sth to our example application so that we can experiment with using
NGB components-a playground view.
A long-standing traditional thing I do when building web applications of any technology
stack and not just for Angular applications, is to add a page as a place where I can
experiment with stuff within the context of the application that I'm building at the time. I
refer to that as a playground. In our case, our playground will be a component whose
template will act as our experimental canvas as we explore a few NGB components. We're
also going to hook it up to our menu so that we can access it easily.
We'll hang on to our playground view throughout the rest of the book, only deleting it in
Chapter 15, Deploying Angular Applications, where we'll learn how to deploy our
application and won't want our playground to go along for the ride.
So, let's do that now. It has been a while since we've added components to our example
application that we created in Chapter 4, Routing and so I wanted to take this opportunity
to enumerate the steps to do this (within their own sections that follow) using the addition
of the playground as the example. Note that this is the manual way of adding a component
to our project-unlike using the CLI to add it for us, as we did a few chapters ago.
Working with NG Bootstrap Chapter 8
[ 224 ]
Creating a playground directory
The 1st thing we need to do is to create a directory that will hold the files we'll need for
our playground component. Each of our components has its own directory and are all
subdirectories the app directory-which is itself a subdirectory of the src directory within
the project root directory.
Since we're adding a new component, we'll follow our convention and create a directory for
it. In your IDE, right-click the app directory, select New Folder and enter playground as
the name-which follows our convention that we've used so far. Once that is done, we'll
have a place to insert the files that will collectively make up our component.
Creating the playground component class
We now need to create our playground component class. In your IDE, right-click the newly
created playground directory and select New File and
enter playground.component.ts as the name. The playground.component.ts file our
component class. Enter the following code in this file:
import { Component, OnInit } from '@angular/core';
@Component({
selector: 'playground',
templateUrl: './playground.component.html',
styleUrls: ['./playground.component.css']
})
export class PlaygroundComponent implements OnInit {
constructor() { }
ngOnInit() { }
pageTitle: string = "Playground";
}
By looking at our playground Component class file, you'll notice a few things:
We're importing OnInit, in addition to the component from
the @angular/core module. This is because we're giving ourselves a place to set
up some variables if we need to-such as for passing in any child components.
Working with NG Bootstrap Chapter 8
[ 225 ]
We've included a constructor for our class. Whether we use it or not, it provides
us with a mechanism to tap into our component's life cycle to trigger some code
if we wanted to. We won't use this right now, but I wanted to show you that our
components function as traditional object-oriented classes and thus have a
constructor that we can leverage.
We've set up our component to use external files for its template and its style, as
opposed to having them inline. So, the next piece of business is to create these
two files (see the following two sections).
We have a single property (that is, pageTitle) declared in our class as a string,
and we've assigned the name of our view to it. Our template in the following
section displays this property using the 1-way binding syntax.
Creating the playground template file
We now need to create the template file for our playground component, which will be our
component's visual interface. In your IDE, right-click the playground directory, select New
File and enter playground.component.html. The playground.component.html file
is required because we've passed it into our component decorator as one of the parameters.
Enter the following code in this file:
<h3>
{{ pageTitle }}
</h3>
<hr>
There's not much in this file yet-but this is where we'll be adding the NGB components so
that we can experiment with them. Experimenting, of course, is the very best way to learn
any technology that may be new to you. The only thing our template does for now is to
display our page name-by binding to our class's pageTitle property.
Creating the playground CSS file
The final file we need to create for our playground component is that which will house its
styles. In your IDE, right-click the playground directory, select New File, and
enter playground.component.css as the name. The playground.component.css file is
also required because we've passed it into our component decorator as one of the
parameters. Enter the following code in this file:
/* Nothing here yet. This is a placeholder file that we may use later. */
Working with NG Bootstrap Chapter 8
[ 226 ]
The preceding code is self-explanatory. We don't have any styles in this file yet-but it's
good to create at least one CSS file for every component that you create.
Creating the playground menu item
OK. So, after from following the directions in the preceding sections, you should now have
a playground component that you can use as a sandbox for experimenting with almost
anything you want. In our immediate case, we'll be using it for experimenting with NGB
widgets (that is, components), but we'll also be using this sandbox during Chapter 9,
Working with Angular Material.
Before we move on to inserting the 1st NGB widget, we'll be taking a look at. It's a good
idea to create a temporary menu link for our playground view so that we can get to it easily
from within our application. Let's do this now.
In your IDE, open your app.component.html file. This is the main, or starting, a template
that is loaded for your Angular application during the bootstrapping process. It is also
where we created our menu in Chapter 4, Routing. In this file, insert the following code
after the listings menu item:
<li routerLinkActive="active" class="nav-item">
<a routerLink="playground" class="nav-link">Playground</a>
</li>
All this small HTML code snippet does is to add a playground navigation link in our
menu and instruct Angular's routing system to load the playground component (and thus
the playground template and then recursively load any child components) when it is
clicked.
OK, good-we're now all set up and ready to take a look at our 1st NGB widget.
NGB widgets
As previously mentioned, NGB widgets are 3rd-party Angular components that are
designed to replace the JS-driven Bootstrap CSS components. NGB has many
widgets available, but we're only going to be looking at 3 of them in the following
sections.
You can find the entire list of NGB widgets, along with their documentation, at: https:/ /
ng- bootstrap. github. io/ #/ components/ .
Working with NG Bootstrap Chapter 8
[ 227 ]
Collapse
The collapse component is a useful thing to use to preserve screen real estate. Our use case
for the use of this component will be for toggling instructions to be either displayed or
hidden. The state of the component would initially be collapsed when its parent
component's template is rendered, but the user would be able to toggle the instructions to
be shown and re-collapse them as needed.
Let's take a look at a quick example in the code that we can try out in our playground
which toggles the display of a section of the page on and off-in our case, this content will
be hypothetical instructions (for now).
We need to modify 3 files to make this work. The use of other NGB components (and
even the Angular Material components that we'll be looking at in the next chapter) work
similarly, so I'll take the time to explain things after each code listing because this is the
very 1st 3rd-party component that we're looking at together. When looking at similar
components later on, any explanations will given if they differ substantially from these
ones.
Our parent component
For this chapter, as well as Chapter 8, Working with NG Bootstrap, our parent component
will always be our playground component.
Modify your playground component template (which is playground.component.html
file) so that it looks as follows:
<h3>
{{ pageTitle }}
</h3>
<hr>
<ngb-collapse></ngb-collapse>
<br />
This is our page's main content
The only new thing we've added that is of any importance to our playground template
is <ngb-collapse></ngb-collapse>, which is our custom directive that will instruct
Angular to insert our child component's template there. ngb-collapse is the selector in
our component class's metadata (that is, the object we passed to the component decorator).
Let's take a look at that file next.
Working with NG Bootstrap Chapter 8
[ 228 ]
Our NGB collapse component class
We've named our component class (which leverages NGB's collapse component)
NgbCollapseComponent-but where does this code live? Well, we need to create a new
directory and two new files within that directory just like we did when we created our
playground component. Yes-we created 3 files for our playground component, but
we'll be skipping the CSS file for NgbCollapseComponent.
1st, create a directory called ngb-collapse. Within that new directory, create a file
named ngb-collapse.component.ts and add the following code in it:
import { Component } from '@angular/core';
@Component({
selector: 'ngb-collapse',
templateUrl: './ngb-collapse.component.html'
})
export class NgbCollapseComponent {
public isCollapsed = true;
}
As you can see, we've not defined a styleUrls array, which is why we don't require a file
for it (which we would have named sth like ngb-collapse.component.css if we
wanted this component to have styling). For the purposes of experimenting with the NBG
collapse component, we only care about creating a component class file and its template
file.
The other thing of interest to us in our component class file is the isCollapsed property.
We can, of course, name it whatever we want, but the important thing is that it is declared
and is initially set to true. We're going to use this property by binding its value to the
ngbCollapse attribute within our template file. Doing so will cause a part of our
component template to be either collapsed (hidden) or expanded (displayed). Note that I
emphasized that our targeted content within our component will either be hidden or
displayed, as opposed to being either added to or removed from the DOM. If our content is
hidden (that is, non-visible), it is still in the DOM. This is because the NGB collapse widget
does not function as a structural directive. It achieves its hide/show functionality via
attribute binding.
Let's now take a look at the 3rd file, the component template for our
NgbCollapseComponent class.
Working with NG Bootstrap Chapter 8
[ 229 ]
Our NGB collapse component template
Create another file within the ngb-collapse directory, name it ngbcollapse.
component.ts and add the following code in it:
<p>
<button type="button" class="btn btn-outline-primary"
(click)="isCollapsed = !isCollapsed">
{{ isCollapsed ? 'Show' : 'Hide' }} Instructions
</button>
</p>
<div id="collapseExample" [ngbCollapse]="isCollapsed">
<div class="card">
<div class="card-body">
These are the hypothetical instructions for sth.
</div>
</div>
</div>
Let's look at this code together. The 1st thing of interest to us is the binding of the click
event to the expression, which basically toggles our isCollapsed variable, defined in our
component class, between true and false:
(click)="isCollapsed = !isCollapsed"
The text for our toggle button is always set to one of two values. When the instructions are
displayed, the button text reads Hide Instructions. When the instructions are hidden, the
button text reads Show Instructions. This is, of course, the behavior we want, but at 1st
glance, you may assume that it takes an if .. else construct to make it all work.
Surprisingly, thanks to Angular's interpolation template syntax, it only takes a tiny amount
of code to alter the button's text depending on the value of our isCollapsed variable.
Let's take a moment to see the tiny code snippet responsible for determining what the
button text should be and how it renders it for us:
{{ isCollapsed ? 'Show' : 'Hide' }} Instructions
In Chapter 7, Templates, Directives and Pipes, we took a look at all the symbols that we can
use in our template syntax-such as interpolation, 2-way binding and so on. The symbol
that works its magic for us, in this case, is the interpolation symbol (that is, the set of double
curly braces). The reason I call it magical is that not only does it serve as a string
interpolation, but it is also smart enough to handle expressions and even function calls. So,
we're not restricted to just having a variable name being treated as a simple string
interpolation.
Working with NG Bootstrap Chapter 8
[ 230 ]
To determine what our button text should be, we use JS's ternary operator syntax to
render (or interpolate) the text to one of two values, Show or Hide, based on the value of
our isCollapsed variable. Of course, whatever the Boolean value is, the Instructions text
will always be rendered, resulting in the button text being either Show Instructions, or
Hide Instructions. This is all done succinctly and inline. Pretty cool, isn't it?
Importations and declarations
If you try and run the project at this point, you'll get a few errors. This is because we
haven't set up our imports and declarations in our app.module.ts file for this component
yet. Let's do this now.
Add this import line after the import line we added for our playground component:
import { NgbCollapseComponent } from './ngb-collapse/ngbcollapse.
component';
And add NgbCollapseComponent to the declarations array.
With the preceding import and addition of our component class to the declarations array in
the app.module.ts file, our project should build and run just fine.
Good job. Let's now move on to our modal component.
Modal
Modal dialog windows have been around since the early days of the Windows OS on
desktops (pre-internet) and have become popular for websites as well-this is especially
true since jQuery came onto the scene. Modal windows are used for interacting with the
user-typically, to get information from them. Moreover, they help the designers focus the
users' attention to where it should be by dimming the background for contrast, as well as
disabling any interaction anywhere outside the modal area. One of our use cases for the use
of a modal window will be for displaying the login form.
Let's take a look at a quick example in the code that we can try out in our playground, to
display a modal window. Since the integration of NGB widgets all follow the same pattern,
I won't cover it in as much detail as the collapse NGB widget, but I'll point the important
areas.
Working with NG Bootstrap Chapter 8
[ 231 ]
Our components all start off the same way. We need to create a folder for our component
(let's name it ngb-modal) and we need to create our two files-one for our component
class and the other for our component template. Let's name them ngbmodal.
component.ts and ngb-modal.component.html, respectively.
In the sections that follow are the two code listings for our NGB modal component,
followed by the necessary imports and declarations-just like we did for our collapse
component.
Our NGB modal component class
In our component class, we 1st import the necessary classes from the appropriate
modules and we then decorate our class with the @Component decorator, so we can link it
to a template and set up our selector (that is, our custom HTML tag that we'll add to our
playground template).
Next, we add a constructor so we can inject the NgbModal service (note: we'll be covering
dependency injection in Chapter 12, Integrating Backend Data Services).
Our class has a variable named closeResult, which is populated with a string (by the
private method named getDismissReason), describing how the modal dialog is dismissed
by the user.
We also have an open method that is responsible for causing the modal dialog to render. As
we'll see in the code listing in the next section (on our component template), the open
method is triggered by a button click from within our playground.
You'll notice that the open method takes a parameter (named content in this example).
Our component's template wraps the content that is to be displayed in our modal dialog
within its ng-template tags and as you'll see, these tags have the #content template
variable associated with them. If you remember from Chapter 7, Templates, Directives, and
Pipes, the hash symbol (that is, #) in template syntax is used to denote a variable:
import {Component} from '@angular/core';
import {NgbModal, ModalDismissReasons} from '@ng-bootstrap/ng-bootstrap';
@Component({
selector: 'ngb-test-modal',
templateUrl: './ngb-modal.component.html'
})
export class NgbModalComponent {
closeResult: string;
Working with NG Bootstrap Chapter 8
[ 232 ]
constructor(private modalService: NgbModal) {}
open(content) {
this.modalService.open(content).result.then((result) => {
this.closeResult = `Closed with: ${result}`;
}, (reason) => {
this.closeResult = `Dismissed ${this.getDismissReason(reason)}`;
});
}
private getDismissReason(reason: any): string {
if (reason === ModalDismissReasons.ESC) {
return 'by pressing ESC';
} else if (reason === ModalDismissReasons.BACKDROP_CLICK) {
return 'by clicking on a backdrop';
} else {
return `with: ${reason}`;
}
}
}
Let's now take a look at our component template, ngb-modal.component.html.
Our NGB modal component template
Our component template is not only responsible for supplying our view with the content to
be displayed in the modal dialog, but will also supply us with the visual element that our
users will use (in this case, a button) to trigger the modal dialog.
The following HTML code is our component template, which we will use later for our login
form (note: we will be covering forms in Chapter 10, Working with Forms):
<ng-template #content let-c="close" let-d="dismiss">
<div class="modal-header">
<h4 class="modal-title">Log In</h4>
<button type="button" class="close" aria-label="Close"
(click)="d('Cross click')">
<span aria-hidden="true">&times;</span>
</button>
</div>
<div class="modal-body">
<form>
<div class="form-group">
<input id="username" class="form-control" placeholder="username" >
<br>
<input id="password" type="password" class="form-control"
Working with NG Bootstrap Chapter 8
[ 233 ]
placeholder="password" >
</div>
</form>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-outline-dark" (click)="c('Save
click')">submit</button>
</div>
</ng-template>
<button class="btn btn-lg btn-outline-primary"
(click)="open(content)">Launch test modal</button>
Now that we have our component class and our component template, we have to tell our
application's root module about them-and we'll do just that in the next section.
Importations and declarations
Just as with our collapse component, if you try and run the project at this point, you'll get a
few errors-and for the same reasons-since we've not set up our imports and declarations
in our app.module.ts file for this component. You know the drill.
Add this import line after the import line we had added for our playground and collapse
components:
import { NgbModalComponent } from './ngb-modal/ngb-modal.component';
And add NgbModalComponent to the declarations array.
I know you're getting the hang of this. Let's get some more practice with this by integrating
one more NGB widget to our playground view-and as a bonus, we'll take a sneak preview
of Angular's HttpClient module. We'll be using the HttpClient module to fetch the
images for our carousel and we'll also be using the HttpClient module to call our APIs in
Chapter 11, Dependency Injection and Services.
So let's stretch our legs and arms, fill up our cups with coffee and move on to one of the
more interesting components (and what will be the start of the show in our example
application), the NGB carousel.
Working with NG Bootstrap Chapter 8
[ 234 ]
Carousel
The carousel component is most notably known as the tool (that is, the widget or
component) to use for displaying a series of images in a predesignated order-much like
flipping through a photo album. Our use case will be precisely that: giving the user the
ability to flip through photos of the property.
Let's take a look at a quick example in the code that we can try out in our playground to
display 3 images. We'll start with the component class and then move on to the
component template. These code listings are straight out of the carousel example on the
NGB website, found at: https://ng- bootstrap. github. io/ #/ components/ carousel/
examples.
I leave the wiring up of the class, using the import statement and so on, to you as an
exercise. Hint: it's exactly the same process that we previously covered when adding the
collapse and modal components to our playground (in their respective Importations and
declarations sections). However, I will make mention of a few things after each code listing.
Our NGB carousel component class
In this section, we will implement the ngb-carousel component class. The following is the
updated component class. We will analyze the code in a bit:
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
@Component({
selector: 'ngb-test-carousel',
templateUrl: './ngb-carousel.component.html',
styles: [`
.carousel {
width: 500px;
}
`]
})
export class NgbCarouselComponent implements OnInit {
images: Array<string>;
constructor(private _http: HttpClient) {}
ngOnInit() {
this._http.get('https://picsum.photos/list')
.pipe(map((images: Array<{id: number}>) =>
Working with NG Bootstrap Chapter 8
[ 235 ]
this._randomImageUrls(images)))
.subscribe(images => this.images = images);
}
private _randomImageUrls(images: Array<{id: number}>): Array<string> {
return [1, 2, 3].map(() => {
const randomId = images[Math.floor(Math.random() *
images.length)].id;
return `https://picsum.photos/900/500?image=${randomId}`;
});
}
}
There are a few things going on in our component class, ngb-carousel.component.ts.
We're importing the HttpClient class from Angular's http module and we're also
importing the map class from the rxjs/operators module. The HttpClient class, which
we'll be looking at more closely in Chapter 11, Dependency Injection and Services, is used to
fetch a JSON list of image objects from https://picsum. photos, a free service that serves
up images as placeholders, providing, as their site says, The Lorem Ipsum for photos.
The map class is used to randomly map 3 of the many image objects that are returned
from the GET request of HttpClient to our string array variable, named images.
The fetching of the image objects from the API happens when our component is initialized
because the GET request happens within the ngOnInit() component's life cycle hook.
Our NGB carousel component template
In this section, we will implement our ngb-carousel component template file:
<ngb-carousel *ngIf="images" class="carousel">
<ng-template ngbSlide>
<img [src]="images[0]" alt="Random 1st slide">
<div class="carousel-caption">
<h3>1st slide label</h3>
<p>Nulla vitae elit libero, a pharetra augue mollis interdum.</p>
</div>
</ng-template>
<ng-template ngbSlide>
<img [src]="images[1]" alt="Random 2nd slide">
<div class="carousel-caption">
<h3>2nd slide label</h3>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
</div>
</ng-template>
<ng-template ngbSlide>
Working with NG Bootstrap Chapter 8
[ 236 ]
<img [src]="images[2]" alt="Random 3rd slide">
<div class="carousel-caption">
<h3>3rd slide label</h3>
<p>Praesent commodo cursus magna, vel scelerisque nisl
consectetur.</p>
</div>
</ng-template>
</ngb-carousel>
This template is straightforward. Everything about it is hardcoded, except for the src
property of the img HTML elements. Using square brackets around the HTML img src
attribute is an example of property binding (as we learned in Chapter 7, Templates,
Directives and Pipes). In this case, the number of images in the carousel was known to be
three. In practice and as we will do in our example application, the template would
normally make use of the *ngFor structural directive to iterate through an array of items of
variable lengths.
Having gone through a few examples of integrating NGB widgets into our playground, we
can now implement them in our application for real.
Implementing NGB into our example
application
In the preceding section, NGBwidgets, we covered few components that are available in
NGB. Of course, you know by now why I would never cover any more than a small
number of the available components-right? If you said, yes Aki, I know why. If you covered
all the components, you'd basically just be duplicating documentation that is readily available
elsewhere, you'd be correct! Covering 3 out of 16 is plenty-it's almost 19% (which is
practically the same as duplicating one out of every five pages of documentation!).
But there's also another reason. We're only going to implement two of the 3 NGB
components that we covered-namely, the modal component and the carousel
component-and so there is no need to cover too much more than those. OK, let's continue
by putting our new found knowledge to practical use.
Working with NG Bootstrap Chapter 8
[ 237 ]
We learned about implementing the modal, carousel and collapse components in earlier
sections. We created selectors for each of the components. For the modal component, we
created a selector named ngb-test-modal; for the carousel component, we created a
selector named ngb-test-carousel; and last, but not least, for the collapse component,
we created a selector named ngb-collapse. We now need to use these selectors in the
playground.component.html file so that the widgets will be visible in the page.
The following is the updated code of the playground component template file:
<p>
{{pageTitle}}
</p>
<app-ngb-collapse></app-ngb-collapse>
<app-ngb-modal></app-ngb-modal>
<app-ngb-carousel></app-ngb-carousel>
We added the directives using the selectors for each of the components. Run the app using
the ng serve command in the command line and we should see the output, as shown in
the following screenshot:
Working with NG Bootstrap Chapter 8
[ 238 ]
Our application has the widgets integrated, but surely we can do a much better job with the
design. In the next few sections, we will learn about some of the design principles and best
practices that we will be implementing in the chapters to come.
UX design rules of thumb
There are rules of thumb for just about everything and web design isn't any different.
There are do's and don'ts in web design-and since we're now really starting to dive into
our templates, it's a good time to review some of these design tenets.
There are probably several dozen design principals, but I'm not an expert on ,
user experience (UX) and thus you'd be better served to pick up a good book that is
focused on UX and GUI/interface design (I know that there are titles from Packt that you
can look into). However, since we are building an application and our application is made
up of several components, It would be remiss if I didn't cover the fundamental 3 design
principals.
Not only will we cover them in the following 3 short sections, but we will be adhering
to them as we build our example application's templates. The reason we have things such
as UX design principals essentially comes down to one thing-we want to have happy
users!
Keep it clean
UX rule of thumb #1: Keep it clean.
Nothing gives users a headache faster than an overly busy (that is, cluttered) user interface.
You may have heard of the expression less is more-and this expression certainly applies to
UX design.
People feel like they have no time to do anything-and if doing sth makes them feel
like they are wasting their precious resource (that is, time), they become unhappy faster
than you can count to 10. How does this relate to this 1st UX design principal? If there is a
lot to look at on your page, they don't know where to start looking-and if they can't make
sense of what they're looking at in short order, then you guessed it: they become unhappy.
Working with NG Bootstrap Chapter 8
[ 239 ]
Clutter is almost never a good thing. Think of your bedroom or kitchen. Are you happier
when it's tidy and everything has a place and purpose and you can easily and quickly find
what you're looking for? Or are you happier when you waste 5 minutes looking for that
spatula to cook your breakfast that you barely have time to eat? The answer, I hope, is
obvious. Visitors to websites think the same way.
Keep it functional
UX rule of thumb #2: Keep it functional.
This UX rule of thumb is related to the 1st one, in that it is the same as saying that nearly
everything on our view should have a function. The days of having a million bells and
other objects on the screen that are nothing but eye candy are over. Do you remember the
way websites looked in the late 1990s? Flash was all the rage. Web pages looked like snow
globes, or had large animated buttons that pulsated and read Click Here Now. These are
no longer tolerated. Chances are excellent that if you have any such things on your web
page, your visitor is going to leave your website as fast as they possibly can. If there is
sth on the screen, it had better have a purpose.
If you'd like to see an extreme example of a website that pays attention to the 1st and
2nd (and the upcoming 3rd) UX design principals, just take a look at Google's home
page, at: https://www. google.com/ .
Keep it obvious
UX rule of thumb #3: Keep it obvious.
Nothing frustrates users more than forcing them to use a large portion of their brain power,
time and detective skills just to find out what they need to do next, or how to do a specific
task they'd like to perform in a web application.
Users of your web application are users for a reason and that is that they need a tool to get
sth done. Whether the task that they want to get done is for pleasure or for work, it
doesn't matter. Whatever it is they'd like to get done, they don't want to spend any more
time than what is reasonable. If they need to spend too much time figuring things out,
guess what? Yes! They become unhappy!
This 3rd UX design principle is perhaps the most difficult one to adhere to, but it is our
responsibility as application builders to give it the attention it deserves.
Working with NG Bootstrap Chapter 8
[ 240 ]
Summary
In this chapter, we explored NG Bootstrap-the 1st of the two 3rd-party component
libraries that are freely available to us for use in our Angular applications. We'll be
exploring the 2nd one, Angular Material, in the next chapter.
We took a look at how to install NGB and then we created a playground within our
application so we can have a place to play (that is, experiment) with these 3rd-party
components-including temporarily wiring the playground up to our menu via routing for
easy navigational access to our playground. While we could have created a separate project
altogether for playing around with components before integrating them into our
application for their intended purposes, it is usually more convenient to create a
playground within our existing infrastructure. Of course, when the comes for us to deploy
our application, we can easily remove the playground and the menu option with its
accompanying route.
With our playground all set up, we then dove in and took a look at how to integrate three
of NGB's widgets: collapse, modal and carousel.
Finally, to wrap the chapter up, since we're in the component and layout part of the book
(as opposed to the backend data integration and services part of the book), it was a good
time to cover a few design principle as well. So, we briefly covered 3 of the top tenants
of good design: keeping it clean, functional and obvious. We'll be adhering to these design
principle as best we can throughout the remainder of the book.
Now then, keep your component hat firmly on your head, turn the page and let's take a
look at the gorgeously designed components that the Angular team cooked up for our use.
Leveraging the Angular Material components in the right proportions and places will help
boost our example application's usability and aesthetics. And fortunately, Angular Material
plays nicely with Bootstrap, so there's no problem with having both libraries in the same
Angular project.
9 Working with Angular Material
Welcome to the chapter on Angular Material. I must say, I'm impressed. Statistics show that
most of the people who buy tech books don't get very far into them. You are a little more
than halfway through the book-a job well done, Angular Jedi!
This will be a short chapter for a couple of reasons. 1st, this book is heavily intended to be
used for building applications, primarily using Angular and Bootstrap. So think of this
chapter as an added bonus for us. The other reason is this chapter is only intended to be an
introduction to an alternative user interface (UI) component library, to Bootstrap when
working with Angular. There should be a separate book on Angular Material alone, but this
chapter will cover a lot of ground in terms of showing you the capabilities and components
that the library offers.
We will learn about navigation and menu components, layout components, form field
elements, buttons, dialog and pop-up components and lots of fun elements that you will
definitely appreciate and possibly consider for the framework in your next project.
By summarizing, the topics we will be covering in this chapter are:
What is Angular Material?
Installing Angular Material
Categories of components
Okay, let's get right to it by starting with the description of what Angular Material is.
Working with Angular Material Chapter 9
[ 242 ]
What is Angular Material?
Angular Material is a rich collection of components, which can be easily plugged into
Angular applications and also works on web, mobile and desktop applications. Material
Design comes from Google, the makers of Angular, which essentially means that there is a
lot of native support, optimization and performance tuning done for the components, as
well as for the new ones that will be rolled out in future. The following list shows some of
the benefits we get when we consider using Material Design in our applications:
The UI components are ready to be used right away, without any extra
development efforts
We can selectively choose to use the components individually, rather than being
forced to import all the modules in one go
The rendering of the components is extremely fast
It is easy to plug data into components via a 2-way or 1-way data binding
functionality, which is an extremely powerful feature of Angular
The components have the same look, feel and behavior across web, mobile, and
desktop applications, which solves a lot of cross-browser and cross-device issues
The performance is tuned and optimized for integration with Angular
applications
You can find all the required documentation about Angular Material on
the official website at: http:/ / material. angular. com.
Before we proceed any further in this chapter, let's quickly generate the application where
we will implement all of the Angular Material components. Run the following ng
command in order to generate a new application named AngularMaterial:
ng new AngularMaterial
Working with Angular Material Chapter 9
[ 243 ]
Once the command has been successfully executed, we should see the output shown in the
following screenshot:
Now that our application has been generated, let's learn how to install the Angular Material
library in our project.
Installing Angular Material
By now, you will have a strong gut feeling that when we want to install anything in
Angular applications, we have a powerful command-line interface (CLI) tool. We will
continue to use the same CLI and with the help of npm, we will install Angular Material.
You can also choose to install Angular Material via the YARN
command-different packaging systems, same outcome.
Working with Angular Material Chapter 9
[ 244 ]
Angular Material has a core dependency and prerequisite to install two packages-CDK
and Animations. So, let's install these 1st and then we will install Angular Material:
npm i @angular/cdk --save
npm i @angular/animations --save
npm i @angular/material --save
After successfully running the preceding commands, we should see the output shown in
the following screenshot:
Open the package.json file; we should see the packages that have been installed and the
corresponding version numbers listed alongside them. If you see the 3 packages that
we have recently installed, it means we are ready to start creating some awesome UI
screens using Angular Material.
Working with Angular Material Chapter 9
[ 245 ]
Once we have installed Angular Material, we will need to import all the required modules
into our app.module.ts file. There are a lot of modules provided by Material, each for a
specific purpose. Np. we will need to import MatCardModule if we plan to use
Material cards. Similarly, we need to import MatChipsModule if we want to use Material
chips in our application. While we can definitely import only the required modules into
AppModule, in most applications using Material UI, we will need all the modules. Now,
let's quickly learn how to import all the modules in one go. We can import all the modules
into a generic module and then use the newly created generic module in
the app.module.ts file. 1st, let's create a file in our project structure and name it
material-module.ts, then we can add the following code to in order import all the
modules into this file:
import {A11yModule} from '@angular/cdk/a11y';
import {DragDropModule} from '@angular/cdk/drag-drop';
import {ScrollingModule} from '@angular/cdk/scrolling';
import {CdkStepperModule} from '@angular/cdk/stepper';
import {CdkTableModule} from '@angular/cdk/table';
import {CdkTreeModule} from '@angular/cdk/tree';
import {NgModule} from '@angular/core';
import {
MatAutocompleteModule,
MatBadgeModule,
MatBottomSheetModule,
MatButtonModule,
MatButtonToggleModule,
MatCardModule,
MatCheckboxModule,
MatChipsModule,
MatDatepickerModule,
MatDialogModule,
MatDividerModule,
MatExpansionModule,
MatGridListModule,
MatIconModule,
MatInputModule,
MatListModule,
MatMenuModule,
MatNativeDateModule,
MatPaginatorModule,
MatProgressBarModule,
MatProgressSpinnerModule,
MatRadioModule,
MatRippleModule,
MatSelectModule,
MatSidenavModule,
MatSliderModule,
Working with Angular Material Chapter 9
[ 246 ]
MatSlideToggleModule,
MatSnackBarModule,
MatSortModule,
MatStepperModule,
MatTableModule,
MatTabsModule,
MatToolbarModule,
MatTooltipModule,
MatTreeModule,
} from '@angular/material';
@NgModule({
exports: [
A11yModule,
CdkStepperModule,
CdkTableModule,
CdkTreeModule,
DragDropModule,
MatAutocompleteModule,
MatBadgeModule,
MatBottomSheetModule,
MatButtonModule,
MatButtonToggleModule,
MatCardModule,
MatCheckboxModule,
MatChipsModule,
MatStepperModule,
MatDatepickerModule,
MatDialogModule,
MatDividerModule,
MatExpansionModule,
MatGridListModule,
MatIconModule,
MatInputModule,
MatListModule,
MatMenuModule,
MatNativeDateModule,
MatPaginatorModule,
MatProgressBarModule,
MatProgressSpinnerModule,
MatRadioModule,
MatRippleModule,
MatSelectModule,
MatSidenavModule,
MatSliderModule,
MatSlideToggleModule,
MatSnackBarModule,
MatSortModule,
Working with Angular Material Chapter 9
[ 247 ]
MatTableModule,
MatTabsModule,
MatToolbarModule,
MatTooltipModule,
MatTreeModule,
ScrollingModule,
]
})
export class MaterialModule {}
In the preceding code, we imported all the required modules into the file. Don't worry
about categorizing the previously listed modules just yet. We learn about the modules
when we learn about the components that are provided by Material. The next step is pretty
obvious-we will need to import this newly created module into our app.module.ts file:
import {MaterialModule} from './material-module';
Once we have imported the module, don't forget to add it to the imports of AppModule.
That's it. We are all set to start learning and implementing the components that are
provided by Angular Material.
Did you know? Google has also released a lightweight CSS- and
JS-based, Lite library, Material Design Lite, which starts by using
the components in the same way as in any other UI library. However,
there may be some components that do not have full support. Learn more
about it at https://getmdl. io/ .
Let's jump right into learning about the components of Angular Material.
Categories of components
As a frontend developer, you will have used a lot of UI components, or even better, you
might have created your own custom components in past projects. As previously
mentioned, Angular Material provides a lot of components that can be readily and easily
used in our applications. The UI components provided by Angular Material can be
categorized under the following categories:
Layouts
Material cards
Form controls
Navigation
Working with Angular Material Chapter 9
[ 248 ]
Buttons and indicators
Modals and popups
Tables
It's a good idea to generate components for each of these categories, so that the
placeholders will be available when we start implementing our application. These
components will host all the components in a clearly categorized manner and they will
become your one-stop components that you can use to refer to any of the component
implementations in the Material library.
1st, let's generate the components for our categories. Run the following ng commands one
after another:
ng g component MaterialLayouts
ng g component MaterialCards
ng g component MaterialForm
ng g component MaterialNavigation
ng g component MaterialButtons
ng g component MaterialModals
ng g component MaterialTable
Following the successful running of the commands, we should see that the components are
generated and added to our project structure, as shown in the following screenshot:
Working with Angular Material Chapter 9
[ 249 ]
Great. We have generated our application; we have installed Angular Material. We have
also imported all the required modules into our AppModule file and finally, we have
generated the components for each category in the UI components of Material. The last
thing we need to do before we start implementing the Material components is to add the
routes for each of the previously listed categories. Open the app-routing.module.ts file,
import all the newly created components and add the routes to the file:
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { MaterialFormComponent } from './material-form/materialform.
component';
import { MaterialNavigationComponent } from './materialnavigation/
material-navigation.component';
import { MaterialCardsComponent } from './material-cards/materialcards.
component';
import { MaterialLayoutComponent } from './material-layout/materiallayout.
component';
import { MaterialTableComponent } from './material-table/materialtable.
component';
import { MaterialModalsComponent } from './material-modals/materialmodals.
component';
import { MaterialButtonsComponent } from './material-buttons/materialbuttons.
component';
const routes: Routes = [
{ path: 'material-forms', component: MaterialFormComponent },
{ path: 'material-tables', component: MaterialTableComponent },
{ path: 'material-cards', component: MaterialCardsComponent},
{ path: 'material-layouts', component: MaterialLayoutComponent},
{ path: 'material-modals', component: MaterialModalsComponent },
{ path: 'material-buttons', component: MaterialButtonsComponent },
{ path: 'material-navigation', component: MaterialNavigationComponent }
];
@NgModule({
imports: [RouterModule.forRoot(routes)],
exports: [RouterModule]
})
export class AppRoutingModule { }
In the preceding code, we imported all the newly created components and created route
paths for each of the them. So far, so good. Now, the big stage is all set and ready to be
rocked. Let's start with our layouts 1st.
Working with Angular Material Chapter 9
[ 250 ]
Navigation
One of the most common and basic necessities of any web application is a navigational
menu or toolbar. Angular Material provides us with multiple options, with which we can
choose the type of menu that is most suitable for our application.
Navigation components using schematics
We will start with the simplest and fastest way to get the navigation added to our apps by
using schematics. That's right, we are just a command away from getting our menu up and
running. Angular CLI provides schematics in order to get a wide range of components. To
install the navigation menu in our app, run the following command in the Angular CLI
command prompt:
ng generate @angular/material:nav myMenu
In the preceding command, we used schematics to generate a new menu component called
myMenu. Upon the successful running of the command, we should see the output shown in
the following screenshot:
Run the app using the ng serve command and we should see the output shown in the
following screenshot:
Working with Angular Material Chapter 9
[ 251 ]
Isn't that a really cool navigation menu? It comes with a top header toolbar and a sidebar
menu that is collapsible . This component is autogenerated by the schematics. If you are not
a big fan of autogenerated components, it's okay, we developers can be picky about these
things. Let's see how we can create our own menu.
Custom Material menus and navigation
Angular Material provides a MatMenuModule module, which provides directives, <matmenu>,
and MatToolBarModule. Also provided is <mat-toolbar>, which will be used to
implement the menu and the header in our application. Open the materialnavigation.
component.html file and add the following code:
<mat-toolbar id="appToolbar" color="primary">
<h1 class="component-title">
<a class="title-link">Angular Material</a>
</h1>
<span class="toolbar-filler"></span>
<a href="#">Login</a>
<a href="#">Logout</a>
</mat-toolbar>
In the preceding code, we implemented the toolbar directive using <mat-toolbar> as a
wrapper and we added a heading title using <h1>. We also added some links to the header
sections. Run the app using ng serve and we should see the output shown in the
following screenshot:
Working with Angular Material Chapter 9
[ 252 ]
That's wonderful. Let's enhance it a little more. We want to add a drop-down menu our
header toolbar. Remember I told you that we have the <mat-menu> directive provided by
the MatMenuModule module? Let's add the menu directive to the header toolbar in the
preceding code as follows:
<mat-toolbar id="appToolbar" color="primary">
<button md-icon-button (click)="sidenav.toggle()" class="md-icon-button
sidenav-toggle-button" [hidden]="sidenav.opened">
<mat-icon aria-label="Menu" class="material-icons">menu</mat-icon>
</button>
<h1 class="component-title">
<a class="title-link">Angular Material</a>
</h1>
<span class="toolbar-filler"></span>
<button mat-button [matMenuTriggerFor]="menu"
color="2ndary">Menu</button>
<mat-menu #menu="matMenu" >
<button mat-menu-item>Item 1</button>
<button mat-menu-item>Item 2</button>
</mat-menu>
<a href="#">Login</a>
<a href="#">Logout</a>
</mat-toolbar>
Notice that we have added a button using the mat-button attribute and we are binding
the matMenuTriggerFor attribute. This will show the drop-down menu defined with
<mat-menu> directives. Now let's run the app using the ng serve command and we
should see the output as follows:
Working with Angular Material Chapter 9
[ 253 ]
Custom sidebar menus
Awesome. So, now we have our custom-made menu ready to use. I know you want more,
don't you? You want to add a sidebar too? Let's do it. To add the sidebar to our application,
Angular Material provides us with a MatSidenavModule module, which provides the
<mat-sidenav> directive that we can use in our application. So, let's continue to modify
the preceding code as follows:
<mat-sidenav-container fullscreen>
<mat-sidenav #sidenav mode="push" class="app-sidenav">
<mat-toolbar color="primary">
<span class="toolbar-filler"></span>
<button md-icon-button (click)="sidenav.toggle()" class="md-icon-button
sidenav-toggle-button" [hidden]="!sidenav.opened">
</button>
</mat-toolbar>
</mat-sidenav>
<mat-toolbar id="appToolbar" color="primary">
<button md-icon-button (click)="sidenav.toggle()" class="md-icon-button
sidenav-toggle-button" [hidden]="sidenav.opened">
<mat-icon aria-label="Menu" class="material-icons">menu</mat-icon>
</button>
<h1 class="component-title">
<a class="title-link">Angular Material</a>
</h1>
<span class="toolbar-filler"></span>
<button mat-button [matMenuTriggerFor]="menu"
color="2ndary">Menu</button>
<mat-menu #menu="matMenu" >
<button mat-menu-item>Item 1</button>
<button mat-menu-item>Item 2</button>
</mat-menu>
<a href="#">Login</a>
<a href="#">Logout</a>
</mat-toolbar>
</mat-sidenav-container>
Working with Angular Material Chapter 9
[ 254 ]
Don't get scared by looking at the number of lines of code. We have just made a few
changes, such as adding the <mat-sidenav> directive, which will contain the content of
the sidebar. Finally, we are wrapping the entire content inside the <mat-sidenavcontainer>
directive; this is important, as the sidebar will overlay on the content. Run the
app using the ng serve command and we should see the output shown in the following
screenshot:
If you see the output shown in the preceding screenshot, give yourself a pat on the back.
Kudos! You are doing absolutely wonderfully. So, we have learned two ways to implement
the navigation and the menu in our applications. We can either use schematics to generate
the navigation component, or we can write a custom menu navigation component. Either
way, user experience (UX) wins!
Now that we have our navigational menu component, let's learn about the other
components of the Angular Material library.
Cards and layout
In this section, we will learn about Angular Material cards and layouts. The basic layout
component of Angular Material is a card. The card wrapper layout component can also
include lists, accordions or expansion panels, tabs, steppers and so on.
Working with Angular Material Chapter 9
[ 255 ]
Material cards
A card is a content container for text, images, links and actions that are used to group the
data of a single subject. Cards can have a header, a body, an image, or links, which can be
displayed to the user based on their availability and functionality. Angular Material
provides a module named MatCardModule, which provides the <mat-card> directive. We
will use this to group the content of our application.
A basic example of creating a card is given as follows:
<mat-card class="z-depth" >
<mat-card-title><a href="" primary >Packt Books</a></mat-card-title>
<mat-card-subtitle>Family of wonderful Authors and Readers
</mat-card-subtitle>
<mat-card-content>
We are learning to create wonderful cards. Each card has some specific
data to be displayed to users.
</mat-card-content>
<mat-card-actions> <button mat-raised-button>Tweet This</button>
<button mat-raised-button>Share</button></mat-card-actions>
</mat-card>
In the preceding code, we made use of the directives provided by MatCardModule. We will
use <mat-card> as a wrapper directive in order to group the content. By using the <matcard-
title> directive, we are setting the title of the card. We are setting a subtitle by
using the <mat-card-subtitle> directive inside the <mat-card> directive. Inside <matcard-
content>, we place all the content that we need to display to the user. Each card
may have the actions that we want the user to perform, such as sharing, editing, approving,
and so on. We can display the card actions using the <mat-card-actions> directive.
Run the app using the ng serve command and we should see the output shown in the
following screenshot:
Working with Angular Material Chapter 9
[ 256 ]
Notice that we have added some content inside the Angular Material card. Are you
wondering what kind of content can be displayed inside the cards? You name it and we
can use it. We can add links, images, lists, accordions, steppers and more. In the next
section, we will learn how to add lists to our cards.
Lists
Lists are collections of items grouped together. We can have either ordered list, or
unordered in our applications. In this section, we will learn how to add different types of
lists inside the cards. Take a look at the following sample code:
<mat-card class="z-depth" >
<mat-card-title>Material Lists</mat-card-title>
<mat-card-content>
<mat-list>
<mat-list-item> New York City</mat-list-item>
<mat-list-item> London</mat-list-item>
<mat-list-item> Dallas</mat-list-item>
</mat-list>
</mat-card-content>
</mat-card>
In the preceding code, we added a list of a few cities. We used the <mat-list> and <matlist-
item> directives provided inside MatListModule, in order to create and display the
list of cities inside the cards. The output of the preceding code is as follows:
Working with Angular Material Chapter 9
[ 257 ]
Lists with dividers
We can also easily add a divider class for the list items in order to visually separate them
into rows. We need to add the <mat-divider> directive in order to achieve that
functionality. Take a look at the updated code as follows:
<mat-card class="z-depth" >
<mat-card-title>Material Lists with Divider</mat-card-title>
<mat-card-content>
<mat-list>
<mat-list-item> Home </mat-list-item>
<mat-divider></mat-divider>
<mat-list-item> About </mat-list-item>
<mat-divider></mat-divider>
<mat-list-item> Contact </mat-list-item>
<mat-divider></mat-divider>
</mat-list>
</mat-card-content>
</mat-card>
Navigation lists
We can extend the lists to make them clickable and therefore make them into navigational
links. To make the list items clickable, we will need to use the <mat-nav-list> directive.
Take a look at the sample code as follows:
<mat-card class="z-depth" >
<mat-card-title>Material Navigational Lists</mat-card-title>
<mat-card-content>
<mat-nav-list>
<a mat-list-item href="#" *ngFor="let nav of menuLinks"> {{ nav }} </a>
</mat-nav-list>
</mat-card-content>
</mat-card>
Working with Angular Material Chapter 9
[ 258 ]
In the preceding code, we created a navigation type of list and the list items inside our
cards, using the <mat-nav-list> and <mat-list-item> directives that are provided in
the MatListModule module. The output of the preceding code is given as follows:
Accordions and expansion panels
One other very cool UI component is accordions, or expansion panels. It's very handy to
use when we need to group data together. We will need to use <mat-accordion> and
<mat-expansion-panel>, which are provided in the MatExpansionModule module, to
implement the accordion functionality in our application. Take a look at the
following sample code:
<mat-card class="z-depth" >
<mat-card-title>Material Expansion Panels</mat-card-title>
<mat-card-content>
<mat-accordion>
<mat-expansion-panel>
<mat-expansion-panel-header>
<mat-panel-title>
Personal Details
</mat-panel-title>
</mat-expansion-panel-header>
</mat-expansion-panel>
<mat-expansion-panel >
<mat-expansion-panel-header>
<mat-panel-title>
Professional Details
</mat-panel-title>
<mat-panel-description>
</mat-panel-description>
</mat-expansion-panel-header>
<p>I'm visible because I am open</p>
Working with Angular Material Chapter 9
[ 259 ]
</mat-expansion-panel>
</mat-accordion>
</mat-card-content>
</mat-card>
Each <mat-expansion-panel> will have a <mat-expansion-panel-header>, where we
can provide the title and description for the expansion panel and we place the content
inside the <mat-expansion-panel> directive itself. The output of the preceding code is as
follows:
There will be use cases where we need to walk the user through a series of steps. That's
where our next component comes into the picture. It's called a stepper. As the name
suggests, this will be used to design steps either horizontally or vertically and will group a
series of steps that the user can navigate to.
Working with Angular Material Chapter 9
[ 260 ]
Steppers
Similar to what we learned in the Accordions and expansion panels section, we will need to
add a wrapper and a <mat-horizontal-stepper> directive and inside that, we will
create <mat-step> directives. For each step that we want to add, we will need to create a
new <mat-step> directive for our application. We can also create a vertical stepper. For
that, the wrapper class we will use is the <mat-vertical-stepper> directive. Take a look
at the following code; we are creating a horizontal stepper:
<mat-card class="z-depth" >
<mat-card-title>Material Stepper</mat-card-title>
<mat-card-content>
<mat-horizontal-stepper [linear]="isLinear" #stepper>
<mat-step label="Personal Details">
Step #1
</mat-step>
<mat-step label="Professional Details">
Step #2
</mat-step>
<mat-step>
<ng-template matStepLabel>Done</ng-template>
You are now done.
<div>
<button mat-button matStepperPrevious>Back</button>
<button mat-button (click)="stepper.reset()">Reset</button>
</div>
</mat-step>
</mat-horizontal-stepper>
</mat-card-content>
</mat-card>
In the preceding code, we created a horizontal stepper with 3 steps. To define the
stepper, we have used <mat-horizontal-stepper> and for defining the actual steps, we
have used the <mat-step> directive. The output of the preceding code is given as follows:
Working with Angular Material Chapter 9
[ 261 ]
Tabs
The last layout component that we are going to learn about is tabs. Angular Material
provides a module called MatTabsModule, which provides the <mat-tab-group> and
<mat-tab> directives so that we can easily create a tabs component in our application.
Take a look at the following sample code:
<mat-card class="z-depth" >
<mat-card-title>Material Tabs</mat-card-title>
<mat-card-content>
<mat-tab-group>
<mat-tab label="Personal"> This is a Personal Tab </mat-tab>
<mat-tab label="Professional"> This is a Professional tab </mat-tab>
<mat-tab label="Contact"> This is Contacts Tab </mat-tab>
</mat-tab-group>
</mat-card-content>
</mat-card>
In the preceding code, we used the <mat-tab-group> wrapper directive and inside this,
we use the <mat-tab> directive for each specific tab. Each tab will have a label that will be
displayed at the top of the tab. Inside <mat-tab>, we will display the content of each tab.
Take a look at the output of the preceding code in the following screenshot:
In the next section, we will learn about Angular Material forms. Read on.
Form controls
Forms are the main ingredient in any interactive and dynamic application. Angular
Material natively supports forms and form controls that can easily be integrated into our
applications. In this section, we will learn how to put together forms using Angular
Material.
Working with Angular Material Chapter 9
[ 262 ]
Forms, in general, have evolved a lot in terms of UX/UI. Angular Material supports basic
form field elements that involve text fields, textareas, drop-down select options, radio
buttons and checkbox elements. Angular Material also provides advanced form elements,
such as autocomplete, the datepicker, slide toggles and so on. We will learn how to add all
of this to our form as we work through our hands-on examples.
Angular Material provides a lot of modules that are related to forms and form field
elements, including the following listed modules:
MatFormFieldModule
MatInputField
MatRadioModule
MatChipModule
MatProgressBarModule
MatSelectModule
MatSlideModule
MatSlideToggleModule
MatListModule
MatDatePickerModule
MatAutocompleteModule
MatCheckboxModule
As previously mentioned, we can import these individually, or all in one go, as we did in
the previous section in our MaterialModule file. We have our modules imported in
AppModule; we are good to start implementing the form fields into our form. We will wrap
each of the input and textarea form elements in a <mat-form-field> wrapper
directive. To implement the input textbox, we will make use of the matInput attribute,
along with our HTML input tag:
<mat-form-field>
<input matInput placeholder="Enter Email Address" value="">
</mat-form-field>
That was very simple and straightforward, right? You bet it is. Now, similarly, we can
easily add a textarea field to our form:
<mat-form-field class="example-full-width">
<textarea matInput placeholder="Enter your comments here"></textarea>
</mat-form-field>
Working with Angular Material Chapter 9
[ 263 ]
Okay, so it wasn't rocket science to add the Input and Textarea form elements. Next, we
are going to implement a radio button and checkbox field element:
<mat-radio-group>
<p>Select your Gender</p>
<mat-radio-button>Male</mat-radio-button>
<mat-radio-button>Female</mat-radio-button>
</mat-radio-group>
To implement a radio button in our form, we will use the <mat-radiobutton>
directive. In most cases, we will also use multiple radio buttons in order to
provide different options. That's where we will use a <mat-radio-group> wrapper
directive. Similar to the radio button, Material provides a directive that we can easily use to
integrate checkboxes into our application. We will make use of the <mat-checkbox>
directive as follows:
<mat-checkbox>
Agree to Terms and Conditions
</mat-checkbox>
The directive is provided by the MatCheckboxModule module and provides a lot of
properties that can we use to extend or process the data.
To implement the drop-down options in our form, we will need to use the HTML
<select> and <option> tags. The Material library provides directives that we can easily
use to extend the is capability in our form:
<mat-form-field>
Select City
<mat-select matNativeControl required>
<mat-option value="newyork">New York City</mat-option>
<mat-option value="london">London</mat-option>
<mat-option value="bangalore">Bangalore</mat-option>
<mat-option value="dallas">Dallas</mat-option>
</mat-select>
</mat-form-field>
Working with Angular Material Chapter 9
[ 264 ]
In the preceding code, for using the <select> and <option> tags, we'll be using the
<mat-select> and <mat-option> directives. We are making very good progress here.
Let's keep the momentum going. The next form field element that we are going to
implement is a slider component.
Sliders can be really helpful when the user wants to specify a start value and an end value.
It improves the user's experience when they can just start scrolling through the range, and
the data gets filtered based on the selected range. To add a slider to our form, we will need
to add the <mat-slider> directive:
<mat-form-field>
Select Range
<mat-slider></mat-slider>
</mat-form-field>
That was very simple. The MatSliderModule API provides a lot of options to extend and
use the directive in many useful ways. We can specify maximum and minimum ranges. We
can set interval values and much more. Talking about slider functionality in the UI, there is
a component that we can use, called a slide toggle. We can implement a slide toggle using
the <mat-slide-toggle> directive:
<mat-slide-toggle>Save Preferences</mat-slide-toggle>
We made use of the <mat-slide-toggle> directive that was provided by the
MatSlideToggleModule module. The API provides a lot of properties, such as
dragChange, toggleChange, setting color or validation as required and so on.
Now that we have put together all of the preceding form field elements in our template file,
let's run the app to see the output. Run the app using the ng serve command and we
should see the output shown in the following screenshot:
Working with Angular Material Chapter 9
[ 265 ]
In the next section, we will learn about the buttons and indicator components that are
provided by Angular Material.
Buttons and indicators
A quick bit of trivia here-ave you seen any website or application without any sort of
buttons? If you have, please write to me.
As far as my experience goes, buttons are an integral part of web applications. In this
section, we will learn all about buttons, button groups and indicators.
Angular Material provides a lot of useful and easy attributes that we can attach to the
button tags, and, voila. Magic happens. The simplest way to start using an Angular
Material button is by adding a mat-button attribute to the <button> tag:
<div>
<button mat-button>Simple Button</button>
<button mat-button color="primary">Primary Button</button>
<button mat-button color="accent">Accent Button</button>
Working with Angular Material Chapter 9
[ 266 ]
<button mat-button color="warn">Warn Button</button>
<button mat-button disabled>Disabled</button>
<a mat-button routerLink=".">Link</a>
</div>
In the preceding code, we added the mat-button attribute to all the buttons that we have
added to our material-button.component.html template file. We also customized the
look, feel and the behavior of the buttons using properties such as color and disabled.
The output of the preceding code is displayed as follows:
The buttons in the preceding screenshot appear more like links and not buttons, right? Let's
customize them to make them look more like buttons. We can easily do this by adding the
mat-raised-button attribute. Notice that in the previous example, we used the matbutton
attribute and in this example, we are adding mat-raised-button. The updated
code is as follows:
<div>
<button mat-raised-button>Basic Button</button>
<button mat-raised-button color="primary">Primary Button</button>
<button mat-raised-button color="accent">Accent Button</button>
<button mat-raised-button color="warn">Warn Button</button>
<button mat-raised-button disabled>Disabled Button</button>
<a mat-raised-button routerLink=".">Link</a>
</div>
Working with Angular Material Chapter 9
[ 267 ]
The output of the preceding code is as follows. Notice the difference in the look and feel of
the buttons now that the new attribute has been added:
They are pretty buttons! Using the predefined attributes allows us to maintain the
uniformity of the buttons across the application.
Next, we are going to explore the indicators provided by Angular Material. We will learn
about badges and progress bar components as part of the indicator components.
Badges are a way to highlight some data along with other UI elements. We may come
across use cases where we want to use badges along with buttons. You must already be
thinking, can we also add some UX for the buttons to design some functionality, too? Yes,
we can!
Angular Material provides a module called MatBadgeModule, which has implementations
for the matBadge, matBadgePosition and matBadgeColor attributes, which can easily
be used to set badges to the buttons. Take a look at the following sample code:
<button mat-raised-button color="primary"
matBadge="10" matBadgePosition="before" matBadgeColor="accent">
Left Badge
</button>
Working with Angular Material Chapter 9
[ 268 ]
In the preceding code, we added a button element and we specified the attributes, such as
matBadge, matBadgePosition and matBadgeColor. The output of the preceding code is
as follows:
This was a button with badges. There is another UI component called chips. We can easily
use these in order to enhance the UX as well. Think of material chips as tags in any other
application you have used previously. Angular Material provides a module called
MatChipModule, which provides the <mat-chip-list> and <mat-chip> directives,
which we can easily integrate into our application. Take a look at the following sample
code:
<mat-chip-list>
<mat-chip color="primary" selected>New York</mat-chip>
<mat-chip>London</mat-chip>
<mat-chip>Dallas</mat-chip>
<mat-chip>Accent fish</mat-chip>
</mat-chip-list>
Working with Angular Material Chapter 9
[ 269 ]
In the preceding code, we used the directives resulting from MatChipModule and from
putting together the tags. The output of the preceding code is as follows:
That was neat. The next indicator that we will learn to implement is a very important one;
the progress bar. We need to show and inform our users about actions that are being
performed in the background, or show the progress of processing some user data. In such
situations, we will need to clearly show this using a progress bar.
Angular Material provides modules named MatProgressBarModule
and MatProgressSpinnerModule, using which, we can easily add a loading icon or
spinner to our web application. Using the API properties and events, we can easily capture
and process the data as well. Take a look at the following sample code:
<mat-spinner></mat-spinner>
Working with Angular Material Chapter 9
[ 270 ]
That's it? Really? Are we kidding? No, we are not. Just by using this module, we should see
the spinning wheel displayed in our application. Take a look at the output of the preceding
code:
In the next section, we will learn all about the modals and dialog windows that are
provided by Angular Material.
Popups and modals
Modern web applications have introduced a lot of innovative UX features and
functionalities. One feature that really stands out has to be modal windows. Take any major
web application; it will have some flavor of modal window implemented in it. The Angular
Material library, too, provides us with an easy way to implement modal or dialog pop-up
windows.
Working with Angular Material Chapter 9
[ 271 ]
Angular Material has a module named MatDialogModule, which provides various classes
that we can use in our component classes. Unlike other UI components, there are no
directives that you can directly use in the template file; instead, we need to achieve this
functionality programmatically. Before we get into creating our dialog window
implementation, we will need a component in which we can store the modal window
content. Run the following command and generate a component. Let's call it the
addDialog component:
ng g c addDialog
When the command is executed successfully, we should see the output shown in the
following screenshot:
Now, open the newly created add-dialog.component.html file and add some content.
Even Hello World is just fine for now.
Next, let's start modifying our MaterialModalComponent class and add the following
code into it:
import { Component, OnInit, Inject} from '@angular/core';
import { VERSION, MatDialogRef, MatDialog} from '@angular/material';
import {AddDialogComponent} from '../add-dialog/add-dialog.component';
@Component({
selector: 'app-material-modals',
templateUrl: './material-modals.component.html',
styleUrls: ['./material-modals.component.scss']
})
export class MaterialModalsComponent implements OnInit {
constructor(private dialog: MatDialog) { }
ngOnInit() { }
openDialog() {
const dialogRef = this.dialog.open(AddDialogComponent);
}
}
Working with Angular Material Chapter 9
[ 272 ]
Let's analyze the preceding code. We imported all the required modules into the file. We
then imported VERSION, MatDialogRef and MatDialog into our component class. We
also imported AddNewComponent, which we want to display in the modal window. Since
we imported MatDialog into the class, we need to inject it into our constructor method,
and then create an instance of it. We will then create another method, named
openDialog. In this method, by using the MatDialog instance, we are calling the method
open and passing AddNewComponent as the parameter. We have implemented the
functionality of the modal window, but this won't work until we actually call the
openDialog method.
So, let's open our material-modal.component.html template file and add the following
line to it:
<button mat-raised-button (click)="openDialog()">Pick one</button>
There's not much to describe here. We just added a button and attached an onclick event
in order to call the openDialog method: simple and sweet. Let's run the app using the ng
serve command and we should see the following output:
Working with Angular Material Chapter 9
[ 273 ]
In my AddDialogComponent, I have added some text and a button. You can add or design
your own template as well. The API provides a lot of properties and events that we can
associate with the dialog window.
In the next section, we will learn about the data tables feature that is provided by Angular
Material.
Data tables
Tables are one of the key aspects of designing complex behind-the-login screen
functionalities. I say behind the login screen, because that way, the search engine
optimization debate won't come into the picture. The problem with traditional tables is that
we need to map the data, rows and columns ourselves, along with implementing
pagination and responsiveness. Thanks to Angular Material, we can now have all of that
generated for us with just one line of command. That's right, you read it correctly-with
only one command, when we use schematics. Run the following command and we should
have our data table ready in no time:
ng generate @angular/material:table issueList
We use the ng command to specify to the schematics with which we want to generate the
table from Angular Material and that it should be created in a new component named
issueList. Upon the successful running of the command, we should see the output
shown in the following screenshot:
Working with Angular Material Chapter 9
[ 274 ]
Run the app using the ng serve command and navigate to the route of the table. We
should see the output shown in the following screenshot:
Voila! We now have our dynamic table ready to use. We can customize the data source
values and the columns that we need to display and update the pagination just using the
configurations in our component class. Go ahead and give it a try.
Summary
We started this chapter by creating the placeholder components for each of the main
categories of the UI components. The components are categorized under various category
layouts, material cards, form controls, navigations, buttons and indicators, modals and
popups and tables.
Working with Angular Material Chapter 9
[ 275 ]
We started by creating the navigation menu component. We learned how to autogenerate
the navigation menu component using schematics. We then also learned how to implement
a custom menu for our apps. Next, we started learning and implementing the layout
components that are provided by Angular Material. In the layout components, we learned
about Material cards. We learned how to include various content inside the Material cards.
We learned about various lists that are supported by Material. We learned about lists with
dividers and navigation lists. We also learned how to implement accordions and expansion
panels to better group and arrange the data. We also explored how to use the stepper
component, which is very useful when designing UX for data that requires various steps.
Along the same lines, we learned about grouping things using tabs.
Next, we explored Material forms and learned how to implement form field elements
including input, textarea, radio and checkbox buttons, sliders and slide toggles. We also
learned about different types of buttons and indicators, including badges and tags that are
provided by Material. We then learned about and implemented the modals and pop-up
windows that are provided by Angular Material.
Finally, we learned about data tables and how schematics help us to set up data tables
quickly in our applications.
A separate book is required if we want to cover every nook and hook of the Angular
Material components. We have tried to give you an overview of the different components
available and why you might consider Material in your next project when it makes sense to
do so and suits you/your clients. It's definitely worth a try!
10 Working with Forms
Let's start this chapter with a simple guessing game. Can you think of any web application
that does not have any sort of form, such as, signing up, login, create, contact us, edit forms,
and so on; the list is endless. (wrong answer-even the Google homepage has a search
form.)
Technically, it's possible. I am 100% sure there are some websites that may not use forms at
all, but I am also equally confident they will be static and won't interact or engage with
users dynamically, which brings us to the main context and focus of this chapter:
implementing and using forms in our Angular application.
OK, let's now take a look at what we'll be covering in this chapter:
Introduction to Bootstrap forms
Bootstrap form classes
Bootstrap form classes-extended
Angular forms
Template-driven forms
Reactive forms
Form validations
Submitting and processing form data
Bootstrap forms
We will learn to make use of the awesome Bootstrap library, which offers a rich set of
classes and utilities for us to design and develop forms in our applications, making
developers' and designers' life easy!
Working with Forms Chapter 10
[ 277 ]
What are forms?
Forms are sets, collections of input fields gathered together to enable us to collect data from
the user through the keyboard, mouse, or touch input.
We will learn to stitch input elements together and build some sample forms, such as
logging in, signing up, or for when the user forgets their password.
Before we jump into creating the forms, here's a quick list of available HTML input
elements that we can use in our apps:
Input (including text, radio, checkbox, or file)
Textarea
Select
Button
Form
Fieldset
If you want a quick refresher tutorial on HTML tags and elements, you
can visit W3schools.com.
Armed with the knowledge about forms and the available HTML elements, it's hands-on
time.
Bootstrap form classes
In this section, we will learn about the available classes from the Bootstrap framework,
which we can make use of while building our forms. Each form can consist of various input
elements, such as textual form controls, file input controls, input checkboxes and radio
buttons. The .form-group class is an easy way to add structure to our forms. Using
the .form-group class, we can easily group input elements, labels and help text to ensure
proper grouping of elements in the form. Inside the .form-group element, we will add
input elements and assign them each the .form-control class.
Working with Forms Chapter 10
[ 278 ]
A sample of a grouping of elements using the .form-group class is as follows:
<div class="form-group">
<label for="userName">Enter username</label>
<input type="text" class="form-control" id="userName" placeholder="Enter
username">
</div>
In the preceding code, we are creating a form group consisting of label and input elements
of type text.
On the same lines, we can easily add the textual input elements, such as email, password,
and textarea. The following is the code to add the input element of type email:
<div class="form-group">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control" id="emailAddress"
placeholder="name@example.com">
</div>
Similarly, we can easily add an input element of type password as well. Again, notice that
we are making use of form-group as a wrapper and adding form-control to the element:
<div class="form-group">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
Nice. We learned to use form-group and form-control classes on input elements. Now,
let's add the same classes to the textarea element. The following is the sample code for
adding the classes to a textarea element:
<div class="form-group">
<label for="userComments">Example comments</label>
<textarea class="form-control" id="userComments" rows="3"></textarea>
</div>
You will notice that all of the preceding elements have the same structure and grouping.
For select and multiple select input elements, it's also exactly the same.
In the following sample code, we are creating a select drop-down element and using the
form-control class:
<div class="form-group">
<label for="userRegion">Example select</label>
<select class="form-control" id="userRegion">
<option>USA</option>
Working with Forms Chapter 10
[ 279 ]
<option>UK</option>
<option>APAC</option>
<option>Europe</option>
</select>
</div>
We have added a select drop-down element and will allow the user to select only one
option from the list. And just by adding an additional attribute, multiple, we can easily
allow the user to select multiple options:
<div class="form-group">
<label for="userInterests">Example multiple select</label>
<select multiple class="form-control" id="userInterests">
<option>Biking</option>
<option>Skiing</option>
<option>Movies</option>
<option>Music</option>
<option>Sports</option>
</select>
</div>
That was simple and straightforward. Let's keep rolling.
Now, let's proceed to other important input elements: checkboxes and radio buttons.
However, the classes are different for checkbox and radio elements.
There are 3 new classes that we will learn to implement for checkbox and radio
elements:
To wrap the element, we will use the form-check class
For the input type checkbox and the radio element, we will use form-checkinput
For checkbox and radio elements, we will need to display labels, for which we
will use the form-check-label class:
<div class="form-check">
<input class="form-check-input" type="checkbox" value="" id="Worldwide">
<label class="form-check-label" for="Worldwide">
Worldwide
</label>
</div>
Working with Forms Chapter 10
[ 280 ]
In the preceding code, we are using the .form-check class, .form-check-input, and
.form-check-label to our wrapper div and label elements.
Ditto, on similar lines, we will use the preceding classes to add to input radio elements:
<div class="form-check">
<input class="form-check-input" type="radio" name="gender" id="maleGender"
value="option1" checked>
<label class="form-check-label" for="maleGender">
Male
</label>
</div>
<div class="form-check">
<input class="form-check-input" type="radio" name="gender"
id="femaleGender"
value="option2">
<label class="form-check-label" for="femaleGender">
Female
</label>
</div>
In the preceding code, we are creating two radio buttons for the user to select their gender,
and the user can make only one selection out of the two options.
In most modern web applications, we will need a user to be able to upload files or assets to
our applications. Bootstrap provides us class named "form-control-file", which we can
associate to the file upload element.
We will use the form-control-file class to our input type file element. The sample
code for this is as follows:
<div class="form-group">
<label for="userProfilePic">Upload Profile Pic</label>
<input type="file" class="form-control-file" id="userProfilePic">
</div>
Great. We have learned to put together all the elements with which we can create our
beautiful and powerful forms.
Bootstrap form classes - extended
We have learned to create forms with input elements and add some of the available form
classes in Bootstrap to group elements, as well as to improve our application.
Working with Forms Chapter 10
[ 281 ]
In this section, we will look at other additional classes and attributes provided by the
Bootstrap framework, which can be used to improve user experience (UX), as well as
extend the behavior of the elements:
Sizing
Readonly
Inline forms
Forms using Bootstrap grid classes
Disabled
Help text
Plain text inside form-group
We will go through each one of the aforementioned options and learn to implement them
and see them in action.
Sizing
We can set the size of the input elements in our form. We can control the height of the
element using various classes for small, medium and large resolutions.
We have learned to use the .form-control class in the previous section and, by default,
the medium size height with the .form-control-md class is applied. There are other
classes available to set the height as large or small. We can use .form-control-lg and
.form-control-sm, respectively.
The following is the sample code, where we are setting the height of the email address
element as large using the .form-control-lg class and the password field with
the .form-control-sm class:
<form>
<div class="form-group mb-2 mr-sm-2">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control form-control-lg"
id="userEmailAddress">
</div>
<div class="form-group mb-2 mr-sm-2">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control form-control-sm"
id="userPassword">
</div>
<button type="submit" class="btn btn-primary">Submit</button>
</form>
Working with Forms Chapter 10
[ 282 ]
We have added the form-control-lg and form-control-sm classes to the form control's
email address and password form elements, respectively.
When we run the application, the output of the preceding code is as follows:
In the preceding screenshot, notice the difference in heights of the input elements. The
email address text field has increased in height and the password field is small.
Readonly
We may come across a use case where we will need to disable a field and make it read-only.
We can utilize the attribute readonly. By adding the Boolean readonly attribute to any
form control element, we can disable that element.
The sample code showing the usage of the readonly attribute on the username field is as
follows:
<div class="form-group">
<label for="userName">Enter username</label>
<input type="text" class="form-control" id="userName" placeholder="E.g
packtpub" readonly>
</div>
Working with Forms Chapter 10
[ 283 ]
The output of the preceding code is displayed as follows. Notice that email address field is
disabled and so the user will not be able to add/edit the element:
Inline forms
The design is also an equally important aspect of how we display the form. We may come
across a use case where we have a requirement to place our form horizontally, instead of
the regular vertical way.
Bootstrap has the .form-inline class to support inline or horizontal forms. When the
.form-inline class is used, the form elements automatically float horizontally.
The following is some sample code, where we create the login form with an email address
and password. We make it inline using the form-inline class :
<form class="form-inline">
<div class="form-group">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control" id="emailAddress"
placeholder="name@example.com">
</div>
<div class="form-group">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
</form>
In the preceding code, the important thing to note is the usage of the .form-inline class.
Working with Forms Chapter 10
[ 284 ]
The output of the preceding code is displayed as follows:
By default, all forms designed using Bootstrap are vertical.
Forms using Bootstrap grid classes
Remember the Bootstrap grid classes we learned about in Chapter 3, Bootstrap - Grid Layout
and Components? Yes, rows, columns and designing the layout of the screen.
In this section, we will learn to use the same row and column grid classes inside our forms,
which is good news because using these classes, we can design a custom layout and update
the look and feel of the form.
The sample code for this is as follows:
<form>
<div class="row">
<div class="col">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control" id="emailAddress" readonly>
</div>
<div class="col">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
</div>
</form>
In the preceding code, instead of using the .form-group class, we are making use of
the row and col classes, which are mainly used for designing layout.
We make a single row with two columns and in each column, we add input elements.
Working with Forms Chapter 10
[ 285 ]
The output of the preceding code is as follows:
Here's your homework now. Try out these fun use cases using grid classes with forms:
Add more input elements in the same row by adding more column div elements
to the same row
Add multiple rows to the form
Assign a fixed width for some columns (column 4 or column 3)
Disabled
While developing web applications with critical and complex compliance requirements, it's
very common that we will have to disable certain input elements based on user selections.
A good use case is where some fields are not applicable to a specific country the user has
selected, so we need to disable other dependent fields.
Using the disabled attribute which takes a Boolean value, we can either disable a form or
a particular element.
Let's see the disabled attribute in action:
<form>
<div class="row">
<div class="col">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control" id="emailAddress" disabled>
</div>
<div class="col">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
</div>
</form>
Working with Forms Chapter 10
[ 286 ]
In the preceding code, we are using the disabled attribute. We can see in the following
screenshot that the email address field is completely disabled:
We can make any element disabled just by adding the disabled attribute to the element.
This is good, but what if we want to disable the entire form in one go? We can do that as
well.
Take a look at the following code:
<form>
<fieldset disabled>
<div class="row">
<div class="col">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control" id="emailAddress">
</div>
<div class="col">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
</div>
</fieldset>
</form>
We are adding the fieldset tag inside the form to wrap all the elements of the form
together and apply the disabled attribute to the fieldset element, which will disable the
entire form in one go.
Working with Forms Chapter 10
[ 287 ]
The output of the preceding code is displayed as follows:
Help text inside forms
Any good web application will have beautiful, yet powerful forms, which talk to users and
create a good UX experience.
Help text is one of the options we have to notify the user about any errors, warnings, or
mandatory fields in the form, so that the user can take necessary actions.
Take a look at the following code:
<form>
<div class="form-group">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control" id="userEmailAddress">
<small id="userEmailAddressHelp" class="form-text text-danger">
Email address cannot be blank.
Email address should be atleast 3 characters
</small>
</div>
<div class="form-group">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
</form>
In the preceding code, we are adding text inside the <small> tag and assigning the
.form-text class and .text-danger.
Working with Forms Chapter 10
[ 288 ]
The output of the preceding code is as follows:
Displaying input elements as plain text
We may come across a requirement where we need to display an input element as just text,
and not as an input element.
We can do this simply by customizing our style sheet, or just by using the .formcontrol-
plaintext class inside the element with the .form-group class.
Take a look at the following code:
<form>
<div class="form-group">
<label for="userEmailAddress">Enter email address</label>
<input type="email" class="form-control-plaintext" id="userEmailAddress"
placeholder="Enter email address">
<small id="userEmailAddressHelp" class="form-text text-danger">
Email address cannot be blank.
Email address should be atleast 3 characters
</small>
</div>
<div class="form-group">
<label for="userPassword">Enter password</label>
<input type="password" class="form-control" id="userPassword">
</div>
</form>
In the preceding code, we have added the .form-control-plaintext class to the input
element.
Working with Forms Chapter 10
[ 289 ]
The output of the preceding code is as follows:
In this section, we have learned about various classes and attributes that we can use to
enhance and make our forms more interactive and powerful and above all, add to better
user design and experience.
Angular forms
In this section comes the real action of forms in Angular applications. Forms are at the heart
of any application and are the main building blocks to gather, view, capture and process
data provided by the users. We will continue to use the Bootstrap library to enhance the
design of our forms in this section.
Angular provides two different approaches to building forms inside our apps.
The two approaches provided by Angular for building forms are as follows:
Template-driven forms: HTML and data binding defined in template files
Reactive or model-driven forms, using model and validation in the Component
class files
Although the form model is a commonality between templatedriven
forms and reactive forms, they are created differently.
Working with Forms Chapter 10
[ 290 ]
The main difference between reactive forms and template-driven forms, when it comes to
the template, is in the data binding. In template-driven forms, we use 2-way data
binding to bind our data model directly to the form elements. On the other hand, with
reactive forms, we bind our data model to the form itself (as opposed to its individual form
elements).
We will explore each of these approaches in detail, learn about the pros and cons of the
approaches and finally, we will build some forms using both approaches. Let's roll.
Template-driven forms
Template-driven forms, as the name suggests, involve all the heavy-duty work of forms
being performed right inside the template of the component. The approach is good and is
recommended when dealing with simple, straightforward forms, without much complex
validation or rules.
All the logic is in the template files, which essentially means that we will make use of
HTML elements and attributes. With template-driven forms, we use HTML to create the
form and the input elements and create validation rules as HTML attributes. 2-way data
binding is the key part, so we can tie the form elements to the properties in the Component
class.
Angular automatically tracks the form and input element states by generating the form
model automatically for us to use. We can directly take the form as an object and process
data easily.
When using the template-driven approach, we 1st import the FormsModule, so we can
have access to the following directives:
ngForm
ngModel
ngModelGroup
We need to import the FormsModule into our app.module.ts file.
Let's take a look at the pros and cons of using the template-driven form approach in our
apps.
Working with Forms Chapter 10
[ 291 ]
Template-driven forms - pros
Template-driven forms can be very useful and helpful if the forms in our application are
simple and straight forward with less metadata and validations. In this section we will
highlight the pros of using template-driven forms in our applications:
Template-driven forms are very easy to use
Suitable for simple and straightforward use cases
Easy-to-use 2-way data binding, so there is minimal code and complexity
Angular automatically tracks the form and input element state (you can disable
the Submit button if the form's state is not complete)
Not recommended if the form has complex form validations or require custom
form validations
Template-driven forms - cons
In the previous section, we have learned about the advantages of using template-driven
forms in our application and we have made a strong argument about the pros of using the
template-driven form approach. In this section, we will learn about some of the cons of
using template-driven forms in our applications:
Not recommended or suitable where the requirements of the form are complex
and comprise custom form validations
Unit testing cannot be fully covered to test all use cases
Template-driven forms - important modules
Armed with knowledge about the pros and cons of using the template-driven approach,
without wasting any time we will deep dive into learning how to implement the templatedriven
forms in our application. We will start by learning about the required modules and
gradually progress to create forms in our application. As explained in the preceding
sections, template-driven forms are mostly defined in the template file. Before we jump into
creating examples of template-driven forms, we should understand some of the most
important concepts related to forms, namely, ngForm and ngModel:
ngForm: This is the directive that helps to create the control groups inside the
form directive
ngModel: When ngModel is used on elements inside ngForm, all the elements
and data get registered inside ngForm
Working with Forms Chapter 10
[ 292 ]
If the Angular form is using ngForm and ngModel, it means that the form
is template-driven.
Building our login form
So far, we have a good high-level understanding of what template-driven forms are. In this
section, we will put our knowledge to work by building a form. Let's put together a form
using the classes we have learned in the preceding section.
The use case we will work on is the user login form for our application. 1st, we need to
generate our login component. Run the following ng command to generate the login
component:
ng g c login
The output of the preceding command is displayed as follows:
We will need to add our route path in the app-routing.module.ts file
in order to access the routes for login and register.
We are building our form using the template-driven approach, so we will need to do most
of the work in our template file. Before we start modifying our template file, we will need
to import a required module into our app.module.ts file.
Open the app.module.ts file and add the following line of code:
import {FormsModule} from '@angular/forms';
Once we have imported FormsModule into our app.module.ts file, don't forget to add it
to our list of imports inside ngModule.
Working with Forms Chapter 10
[ 293 ]
The updated app.module.ts file is displayed as follows:
Now, let's open our login component template file and create our login form in
the login.component.html file. The following is the code we will add to our template
file:
<form #loginForm="ngForm" (ngSubmit)="login(loginForm.value)">
<h3 class="text-center text-primary">Login</h3>
<div class="form-group">
<label for="username">Username:</label><br>
<input type="text" [ngModel]="username" name="username"
class="form-control">
</div>
<div class="form-group">
<label for="password">Password:</label><br>
<input type="password" [ngModel]="password" name="password"
class="form-control">
</div>
<button type="submit" class="btn btn-primary">Sign in</button>
</form>
Working with Forms Chapter 10
[ 294 ]
Let's analyze the preceding code in depth. We are creating a form using the HTML input
elements and adding a username, password and Submit button to the form. Important
things to note are that for the form itself, we are telling the template that the form is ngForm
and ngForm will group all the input elements of the form together into
the #loginForm template variable. For the input elements, we have added the ngModel
attribute and we specify the name attribute for the elements.
Using ngForm, we can now easily retrieve the value of the elements inside the form. Since
we have defined the local #loginForm template variable we can now use its properties
easily. loginForm has the following properties:
loginForm.value: Returns the object containing all the values of the input
elements inside the form
loginForm.valid: Returns if the form is valid or not, based on the HTML
attribute validators applied in the template
loginForm.touched: Returns true or false depending on whether the form
was touched/edited by the user or not
In the preceding code, we are passing loginForm.value to the component. We can pass
any of these value to the component for processing or validation. Notice that we are also
calling a login method, which we need to implement in our Component class file.
Now, let's create a method in our Component class to capture the data coming in from our
loginForm. We are collecting the value of the form and displaying it in the console:
import { Component, OnInit } from '@angular/core';
@Component({
selector: 'app-login',
templateUrl: './login.component.html',
styleUrls: ['./login.component.scss']
})
export class LoginComponent {
constructor() { }
login(loginForm) {
console.log(loginForm);
console.log(loginForm.controls.username);
}
}
Working with Forms Chapter 10
[ 295 ]
Run the app using the ng serve command and we should see the output shown in the
following screenshot:
remember, that in typical server-side scripting, we used to write action
and method attributes for forms. We do not need to define these anymore,
since they are declared and used in the Component class.
This is good stuff and good progress. We will continue to use the preceding login form and
add validations shortly. Let's keep digging for more information.
Model-driven forms, or reactive forms
Reactive forms are also called model-driven forms. In model-driven forms, the model is
created in the Component class file and is responsible for doing the form validation,
processing data and much more.
Angular internally builds a tree structure of the Angular form controls, which makes it
much easier to push and manage data between the data models and the UI elements.
We need to build the form model in our Component class by creating the instances of the
building blocks (that is, FormControl and FormGroup). Additionally, we write the
validation rules and the validation error messages in the class as well. We even manage the
properties (that is, the data model) in the class as opposed to using data binding in the
HTML.
Working with Forms Chapter 10
[ 296 ]
Template-driven forms put the responsibility for the forms on the template, whereas
reactive forms shift the responsibility for validation to the Component class.
In this chapter, we will use the both terms: model-driven forms and
reactive forms, as both refer to the same thing.
Model-driven forms - pros
Reactive forms are very useful in creating, validating and applying custom form validations
to our forms in our applications. We can easily trust the model driven approach to do all
the heavy duty work that is usually associated with any complex forms. In this section, we
will list and understand the pros of using model-driven forms in our applications:
Greater flexibility for more complicated validation scenarios and custom,
complex form validations
The data model is immutable
Since the data model is immutable, no data binding is done
It's easier to add input elements dynamically (such as subtasks on a task form)
using form arrays
It's easy to bind various events to input elements using HostListener and
HostBindings
All the code for the form controls and validations is inside the component, which
makes templates much simpler and easier to maintain
It's easier to unit test
Model-driven forms - cons
All good things in life has some form of cons attached to them. Reactive forms are no
different in nature. While the pros and advantages of using reactive forms can certainly
outweight the cons but still it's important to learn and understand the cons of using reactive
forms in our applications. In this section, we will list the cons of using model-driven forms
in our applications:
Immediate beginners may find the initial learning curve too high
The developer is expected to have knowledge about the various modules
required to work with model-driven forms, such as ngvalidators and so on
Working with Forms Chapter 10
[ 297 ]
Model-driven forms - important modules
We create the model using the two powerful classes provided by Angular-formGroup
and formControl:
FormControl: Tracks the value and state of individual form input elements
FormGroup: Tracks the value and state of a group of form controls
FormBuilder: Helps us to develop forms with their initial value and their
validations
Just as we imported FormsModule in to our template-driven forms, we will need to import
ReactiveFormsModule in to our app.module.ts file.
The updated app.module.ts file should look like the following screenshot:
Working with Forms Chapter 10
[ 298 ]
Armed with all the knowledge about the model-driven form approach, it's time for a
hands-on example.
Reactive forms - registration form example
In the previous section while covering template-driven forms, we have created our login
form for our application. It's time to do a hands-on exercise using the reactive forms. The
fundamental idea behind implementing login and registration forms using different
approaches is to show you the difference in implementation of each approach. There is no
right or wrong approach, the decision is driven by the complexity and requirement of our
forms in the applications.
In this section, we will learn to implement our new user registration form using the modeldriven
approach.
1st, we will need to generate our register component. Run the following ng command
to generate the register component:
ng g c register
The output of the preceding command is as follows:
Since we are talking about model-driven forms, all the hard work had to be done in the
Component class. We will still need to have a template for our reactive forms, but we won't
be adding any validations or data binding into the template.
We want our registration form to have four form elements-that is, fields for full names,
email addresses, passwords and terms and conditions.
Working with Forms Chapter 10
[ 299 ]
Let's update our Component class in the register.component.ts file and create an
instance of formGroup:
import { Component, OnInit } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
@Component({
selector: 'app-register',
templateUrl: './register.component.html',
styleUrls: ['./register.component.scss']
})
export class RegisterComponent implements OnInit {
registerForm = new FormGroup({
fullName: new FormControl(),
emailAddress: new FormControl(''),
password: new FormControl(''),
termsConditions: new FormControl('')
});
constructor() { }
ngOnInit() {
}
register()
{
console.log(this.registerForm.value);
}
}
You will notice a lot of new stuff in the preceding code. Let's take it slowly, step by step.
We are importing the required modules, FormGroup and FormControl, from the
angular/core. Inside the Component class, we are creating an instance of the FormGroup
class, registerForm. You will notice that we are now creating multiple FormControl
instances, each one for a form element that we want to add to our form.
Is that all we need to do? For now, yes. Remember, as explained before, that reactive forms
also need to have a basic template, but all the logic and validations will be inside the
component, rather than the template file.
Working with Forms Chapter 10
[ 300 ]
So now, let's update our template file. In the register.component.html file, add the
following code:
<div>
<form [formGroup]="registerForm" (ngSubmit)="register()">
<h3 class="text-center text-primary">New User Registration</h3>
<div class="form-group">
<label for="fullName">Your Name</label><br>
<input type="text" formControlName="fullName" class="form-control">
</div>
<div class="form-group">
<label for="emailAddress">Enter Email Address:</label><br>
<input type="text" formControlName="emailAddress" class="form-control">
</div>
<div class="form-group">
<label for="password">Password:</label><br>
<input type="password" formControlName="password" class="form-control">
</div>
<div class="form-group">
<div class="form-check">
<input class="form-check-input" type="checkbox"
formControlName="termsConditions" id="defaultCheck1">
<label class="form-check-label" for="defaultCheck1">
I agree to Terms and Conditions
</label>
</div>
</div>
<button type="submit" class="btn btn-primary">Sign in</button>
</form>
</div>
In the preceding code, we are creating a dynamic reactive form. There are many important
concepts that we need to understand in the preceding code. We are using the FormGroup
attribute for model-driven forms. In the template-driven forms, we used ngForm. Notice
carefully that for every form element, we mention the FormControlName attribute and the
value for this attribute has to be exactly the same as was mentioned in the Component class
during the FormControl instance declaration. Take a pause and read the last few sentences
again.
We don't have to mention ngModel for elements anymore, since data binding is tightly
coupled inside the Component class itself. We have also attached a ngSubmit event, which
will call the method register implemented inside the component to print the form value on
the console.
Working with Forms Chapter 10
[ 301 ]
Awesome. That's it. Now serve your application using the ng serve command and we
should see the output as displayed in the following screenshot:
Congrats on getting your forms up and running using the approaches provided by
Angular. We have learned to build forms using template-driven and model-driven
approaches. In the next sections, we will learn to extend them by adding validation and
custom rules.
Angular form validations
By now, we understand how important and critical forms are to all our applications. Since
we will be working on data we receive from users, it's very important to make sure that the
data we receive from our users is correct and valid.
Np. when we expect the user to enter an email address, we should not allow
spaces or a few special characters in the email address. One more example, if we request the
user to enter the phone number, it should not have more than 10 digits (excluding country
code of course).
There can be many such custom valid checkpoints that we may want to have in our forms.
In this section, we will continue to use both the login form and our registration form to
learn how to add validations in both template-driven forms and model-driven forms.
Working with Forms Chapter 10
[ 302 ]
Template-driven form validation
Bring up our login form that we developed using the template-driven approach.
Remember, that in the template-driven forms, validation is done in the template itself using
the HTML attributes.
We can use any of the HTML attributes, such as required, maxlength, minlength, size,
email, number, length and so on, to put validation in forms. We can also make use of
HTML pattern attributes to put regular expression checks in our form elements.
There are various classes that we can make use of readily to implement validation in our
forms:
ng-touched: Input controls have been visited
ng-untouched: Input controls have not been visited
ng-dirty: Input controls data was changed
ng-pristine: Input controls data has not been changed/updated
ng-valid: Input control data is a valid set and makes the form valid
ng-invalid: Input control data is not valid and hence the form is not valid
In template-driven forms, Angular will automatically track the state of each input element
and the state of the form as well. Hence, we can also use the preceding classes in our
CSS/SCSS to style/design our error notifications, as follows:
input.ng-invalid {
border:2px solid red;
}
Alright, now that we know about validations in template-driven forms, it's time to update
our login form component and make it jazzy. We are updating the
login.component.html file by adding validations to the form elements.
<div>
<form #loginForm="ngForm" (ngSubmit)="login(loginForm.value)">
<h3 class="text-center text-primary">Login</h3>
<div class="form-group">
<label for="username">Username:</label><br>
<input type="text" ngModel #username="ngModel" name="username"
placeholder="Enter username" required class="form-control">
<span class="text-danger" *ngIf="username.touched && !username.valid">
enter username </span>
</div>
<div class="form-group">
<label for="password">Password:</label><br>
Working with Forms Chapter 10
[ 303 ]
<input type="password" [ngModel]="password" name="password"
required minlength="3" class="form-control">
</div>
<button type="submit" class="btn btn-primary"
[disabled]="!loginForm.valid">
Sign in</button>
</form>
</div>
Let's take a closer look at the preceding code. We have extended the login form we had
created earlier. Notice that for the username form control, we have the HTML attribute
required, which will be set on the form control. If the user does not enter any value for the
field and steps out of the focus of the field, using the ngIf condition, we are checking if the
field is touched by the user and is if the value is not valid, we are displaying the error
message. For the password field, we are setting other HTML attributes, such as required
and minlength validation checks. If the form control data is not valid, we should not
enable the form, right? That's what we are doing by adding the disabled attribute to the
Submit button.
Now let's run the app using the ng serve command and we should see the output, as
shown in the following screenshot:
For your homework, please try out these use cases in template-driven forms:
Add minimum and maximum length to the username form element
Add a new form element and add validation that it should be in an email format
Working with Forms Chapter 10
[ 304 ]
Reactive form, or model-driven form, validations
So far all, the validations we have implemented are only in the template file using the basic
HTML attributes. In this section, we will learn to implement the validations in the
component using the model-driven forms.
In previous sections, we have learned to create a form using the formControl and
formGroup classes in our Component class. We will continue to use the same registration
form to extend and implement validations now.
We are adding the validation code in our component by adding validations in
the register.component.ts file. Take a look at the code we will add in the file:
import { Component, OnInit } from '@angular/core';
import { FormGroup, Validators, FormControl } from '@angular/forms';
@Component({
selector: 'app-register',
templateUrl: './register.component.html',
styleUrls: ['./register.component.scss']
})
export class RegisterComponent implements OnInit {
registerForm = new FormGroup({
fullName: new FormControl('',[Validators.required,
Validators.maxLength(15)]), emailAddress:
new FormControl('',[Validators.pattern('[a-zA-Z]*')]),
password: new FormControl('',[Validators.required]),
termsConditions: new FormControl('',[Validators.required])
});
constructor() { }
ngOnInit() {
}
register()
{
console.log(this.registerForm.value);
}
}
Working with Forms Chapter 10
[ 305 ]
In the preceding code, you will notice that we have imported the required
modules, FormGroup, FormControl and Validators into our Component class. We had
already imported and used FormGroup and FormControl. The Validators module is the
only additional module that we have imported now. We are passing the validators as
options to FormControl. For fullname we are adding the validators as required and
maxLength. Note that we can pass multiple validators for each FormControl. Similarly,
for email address form control, we are passing a validator pattern, which has a regular
expression check on it. We have made all the required changes and validations in our
component.
Now it's time to update our template register.component.html file:
<div>
<form [formGroup]="registerForm" (ngSubmit)="register()">
<h3 class="text-center text-primary">New User Registration</h3>
<div class="form-group">
<label for="fullName">Your Name</label><br>
<input type="text" formControlName="fullName" class="form-control">
</div>
<div class="form-group">
<label for="emailAddress">Enter Email Address:</label><br>
<input type="text" formControlName="emailAddress" class="form-control">
</div>
<div class="form-group">
<label for="password">Password:</label><br>
<input type="password" formControlName="password" class="form-control">
</div>
<div class="form-group">
<div class="form-check">
<input class="form-check-input" type="checkbox"
formControlName="termsConditions" id="defaultCheck1">
<label class="form-check-label" for="defaultCheck1">
I agree to Terms and Conditions
</label>
</div>
</div>
<button type="submit" class="btn btn-primary"
[disabled]="!registerForm.valid">Sign in</button>
</form>
</div>
The HTML template is the same as the one we had created earlier for our model-driven
form. We have added some more functionality to the form. Notice that we have added
the disabled attribute to the Submit button, which will disable the form if any form
elements are empty or invalid.
Working with Forms Chapter 10
[ 306 ]
See, I told you, our template file will just be a placeholder and almost all of the action
happens in our Component class.
Now, let's serve the app using the ng serve command and we should see the output, as
shown in the following screenshot:
If you see the preceding screenshot, jump on your desk. As we have now learned and
implemented forms using both template-driven and model-driven approaches.
If you paid attention to the examples covered during the entire chapter, you will also notice
that we have created methods to process the form data.
In the next section, we focus exclusively on the same and learn some best practices to
process form data.
Submitting form data
So far, we have learned to design and develop our forms in our applications. In this section,
we will take things to downstream systems, which is to capture the data and process it.
Angular generates a form model in both approaches, be it template-driven forms or
reactive forms. The form model holds the data of the form elements and the state of the
form elements.
Working with Forms Chapter 10
[ 307 ]
In the previous sections, where we have implemented our forms, we have created a method
to call on ngSubmit.
For our template-driven login form, we added the following code to our
login.component.ts file:
login(loginForm)
{
console.log(loginForm);
console.log(loginForm.username);
}
We are passing the entire form object to the login method. Now the loginForm object will
have all the details of the form controls, as well as the states.
In our registration form, which is generated using a model-driven approach, we have used
the instance of formGroup that we created in our Component class
register.component.ts file.
The following is the code we have added for capturing and processing the data:
register()
{
console.log(this.registerForm.value);
}
If you notice, for reactive forms, we do not have to pass any form data, since we had
created the registerForm instance of FormGroup, so it's available in our class using
the this operator.
Once we have captured the data provided to the user, based on the application
requirements, we can now implement our custom logic inside the component.
Some of the common activities we do once we capture data are the following:
Securing data to make sure that we do not allow junk data into our system.
Processing/enhancing the data, such as converting the password into an
encrypted value.
Checking for any automated bots processing our applications.
Making HTTP calls to backend services using Angular services. We have an
entire chapter dedicated to this particular topic: Chapter 12, Integrating Backend
Data Services.
Working with Forms Chapter 10
[ 308 ]
That concludes this chapter on Angular forms. We have covered a lot of ground and I am
sure at this point you will be excited to create your own forms, write custom validations,
and process the captured data.
Summary
Forms are the very heart and soul of any good application. We started by learning the
awesome classes and utilities provided by the Bootstrap library. We explored in detail the
form-group and form-control classes. We learned and implemented various helper and
additional attributes that we can use to make our form look and behave even better.
We deep-dived into Angular forms by learning the two approaches Angular provides,
namely template-driven forms and model-driven forms.
We learned in detail about each of the approaches, their pros and cons and above all
created our login and registration forms using each of the approaches. We also explored the
various type of validations that we have used with template-driven forms and reactive
forms.
Last, but not least, we learned about processing the form data that we receive from the
forms. It's time to get wings and create your awesome forms.
While developing complex applications with multiple developers working on the same
application, things can get out of hand. Luckily, Angular supports dependency injections
and services, which enables us to create reusable services and define interface classes. We
can define new data types and make sure all team members are pushing code without
breaking each other's functionality. And how exactly will we achieve that? That's covered
in the next chapter. Keep reading!
11 Dependency Injection and
Services
In this chapter, we're going to take a look at dependency injection (DI). While DI is not
sth that you have to program directly in Angular (since Angular takes care of all the
DI plumbing for us), it still is sth that is very useful to understand. This is because
Angular makes heavy use of DI when managing its services, as well as any custom services
that you are likely to write as you create your Angular applications.
We'll be looking at one of Angular's most important built-in services, its HTTP service, in
the next chapter, Chapter 12, Integrating Backend Data Services. Without the HTTP service,
our applications would be super boring, since they would be unable to send data to, or
receive data from, an outside source (including our own backend APIs). And so this
chapter will serve us well in terms of helping us gain an understanding of how Angular
injects services such as its HTTP service into our applications for us to use. Moreover, this
topic is a perfect segue into the next chapter.
Here is a list of the topics that we're going to cover in this chapter:
What is DI?
What problem does it solve?
Additional advantages of using DI
Revealing the magic that Angular uses to make it all work
How we can guard against code minification (and why we need to)
By the end of this chapter, you'll have a solid grasp on what this often misunderstood
software design pattern is, and, more importantly, how it works. Dare I say, you may even
start to feel more technically advanced than most of your peers. Many developers
sometimes struggle to even define DI-because it does take some effort to wrap your mind
around it.
Dependency Injection and Services Chapter 11
[ 310 ]
Without further ado, let's get started and discover what DI is all about by injecting some
more software design knowledge into our heads.
What is DI?
Cutting to the chase, DI is a specific case of the Inversion of Control (IoC) design pattern.
In order to understand this high-level definition of DI, or even IoC, we 1st need to quickly
define design patterns. Design patterns are reusable solutions to common problems in
software design. There are dozens of software design patterns and they are typically
categorized into the following 3 high-level categories:
Creational patterns
Structural patterns
Behavioral patterns
In our case and in the interest of brevity, we can safely ignore the creational and structural
categories of design patterns, since DI is a type of behavioural design pattern and just
before we take a look at the IoC design pattern (I know, there are a lot of definitions and
concepts we need to know as prerequisites to truly appreciate what DI is), let's describe
what behavioral design patterns are.
Simply put, behavioral design patterns concern themselves with how objects communicate
with one another. One such pattern is known as the observer design pattern, which
basically sets forth a way of how an object notifies its dependent objects of when its state
changes.
Another behavioral design pattern is known as the publish-subscribe design pattern, which
is a messaging pattern similar to the observer pattern, but a little fancier. Yet another
behavioral design pattern is the template method. The purpose of this design pattern is to
defer the exact implementation of an algorithm to a subclass. The overall idea behind all of
these design patterns is the way they communicate (that is, message) with one another.
Armed with a definition of what the template method is, we're getting much closer to what
DI is all about, but just before we do, there is one last remaining design pattern that we
need to define. You guessed it-the IoC design pattern. Remember, DI is a special case of
the IoC pattern and so we really do need to take a quick look at what it is.
Dependency Injection and Services Chapter 11
[ 311 ]
IoC flips the typical flow of procedural, or imperative, code on its head. Instead of having a
custom object's code control the flow of the program by instantiating another object and
then calling one or more of the newly instantiated object's methods, it defers the
instantiation to a framework-yes, a framework, not just another object-to do that instead.
This will all make sense in a few moments. As an interesting tidbit, this is sometimes
jokingly referred to as Don't call us, we'll call you.
We're going to look at an example of this shortly so that it all makes sense. However, I need
to define what I mean by a framework doing the instantiation of dependent objects. Don't
you just love all the terms and concepts we need to know? (grinning). This framework is
typically referred to as an IoC container. These containers are smart enough to be able to
examine the custom code, figure out what other objects it depends on, instantiate those
objects and pass them into the custom object's constructor. This is opposed to the
traditional way of having the instantiation of the object's dependencies happen within the
custom object itself. Instead, the IoC container performs these duties for it. In a moment, I
will tie this back to Angular and give you a couple of very important advantages that the
IoC pattern provides, but we'll discuss it from the DI perspective-finally!
OK. Let's try to tie this all together and provide an example scenario, or use case. The
Angular framework provides the functionality of an IoC container-among all the other
things that it provides. Since Angular is a modular framework and encapsulates most of
what it does in segregated services, it would make sense that its IoC capabilities are also
encapsulated in one of its services-and, in fact, this is the case.
The Angular service responsible for DI is its injector service-aptly named because it injects
your custom class's dependencies into your class's constructor after instantiating them. Not
only that, but it calls the custom method for you-back to what I had previously
mentioned, Don't call us, we'll call you. All we need to do is to list the names of the
dependencies in the constructor's signature for our custom class.
From this point forward, I will not mention IoC, because we're talking about DI-again,this
is technically not IoC, but rather a special case of it. I only mention this because many
developers use the terms IoC and DI synonymously.
So, let's ask a couple of questions: Since DI is a design pattern and design patterns solve
common software design problems, what problems does DI solve? What are the
advantages of DI? These are excellent questions and I believe I can answer them in one fell
swoop in the following two paragraphs.
Dependency Injection and Services Chapter 11
[ 312 ]
One problem that even object-oriented code has had for a very long time is that a class that
depends on other classes (which is the whole point of object orientation-since we don't
want one class to do all of the work) had the code to instantiate these dependencies within
itself, and, as a result, contained at least some of the logic intertwined within it as well. This
is known as code that is tightly coupled. There are two problems with tightly coupled code:
1stly, the implantation logic is typically encapsulated within the class-which is
sth we don't want. We don't want one object to know the inner workings of other
objects. For instance-if we wanted to change the implementation of an algorithm in a
dependent class, we'd likely also have to change our code in the class that calls it. Another
problem that stems from this is that this code is difficult to test. The more tightly coupled
our classes are, the harder it is to run our unit tests on them-and this problem has been
around for as long as unit testing has.
OK. So how does DI solve these issues? We'll get to a specific use case to make everything
clearer in our minds, but let's 1st describe a couple of the advantages that DI gives us. The
1st advantage of the principle of DI is that it forces us to write decoupled code. We do this
by having the classes that we depend on (for their abstracted implementations) implement
interfaces and we do this so that all our calling class needs to do is to call the interface
methods on these objects-not caring about the implementation details behind the
underlying class methods. When we write code in this manner, we can swap out the class
we depend on, which has a specific implementation, for another class that has another
implementation-all without changing any of our calling code (since our code calls the
interface methods that these classes implement). This is also sometimes referred to as
coding by the interface. Here's another interesting tidbit: this technique is also used in a
style of programming known as aspect-oriented programming, or AOP for short.
A very useful thing that we get for free by adhering to the DI design principal, is that we
can very easily test our code-as opposed to not being able to test our code easily, or at all,
as is the case when we have tightly coupled code. How do we do this? By writing stubs
and / or mock classes-which also implement these very same interfaces that our calling
class calls.
As a side note, there is an important difference between stubs and mocks. Stubs are dumb
classes, which often just return a simple value (often hardcoded). Mock objects, on the other
hand, typically have full implementations so that things such as edge cases can be
tested-as well as to conduct database operations, or make RESTful API calls. Mocks can be
used to do whatever your tests call for. So, stubs are dumb, while mocks are smart. What
they have in common, however, is that they help us unit test our calling class's code by
having the same object messaging pattern (that is, their methods are called via interfaces).
Dependency Injection and Services Chapter 11
[ 313 ]
Whew! We're done with the theory part! Have you fallen asleep or are you still with me?
Ah, you're awake-OK, good. With all that theory now out of the way, let's take a look at
an example use case of where DI can be used for all the reasons mentioned previously-just
so we can cement these concepts into our heads.
Let's assume that we're building an e-commerce application for an online store where we
sell our homemade beer. Our application will need to have a shopping cart and we'll also
have to have at least one merchant account (which is a conduit, known as a payment
processing gateway, so we can charge our customers' credit cards). In this hypothetical
scenario, we have two merchant accounts-maybe because we'd like to keep one as a spare
in case the primary merchant account increases their discount rates (that is, fees), thereby
lowering our profits-but the point is, we have two merchant accounts.
When it comes to implementing the shopping cart, we want to be able to swap out one
merchant account for another one-if we need to-without changing the code in our
shopping cart class. The reason we don't want to change any code is that we may
accidentally introduce bugs in our application (the online store) and this just wouldn't look
good to customers. You may be saying-Hey, I test my code-so bugs are fleshed out-and if
you said that, you fell right into the next benefit of using DI for our application, which is
that we can easily test our application by writing test classes-remember our stubs and
mocks? Yes-we write stubs and mocks so we can test our code. And again, thanks to DI,
we don't have to change our shopping cart class to do so. We have our stubs and mocks
implement the interfaces. And we would wrap the bank's APIs (that is, our merchant
account classes-written by a 3rd party) in a custom class that implements our
interface-so that all these classes (that is, our stubs, mocks and wrapped real bank objects)
can be called in the exact same way.
Cool. So, as a bonus, let's take a quick look at how Angular knows what our class needs,
and how it can call our class's constructor method for us. Well, it's not magic, but it is
ingenious. However, Angular does need a little upfront help from us. When we create
custom classes, for our application, we typically wrap them up as Angular services (we'll
take a look at services in the next chapter, Chapter 12, Integrating Backend Data Services).
Angular requests that we register these services with it and you'll see why we need to do
this in a moment.
Angular's injector service scans our code, specifically, our class's constructor signature, and
figures out its parameters. Because our parameters are services that we need for our class, it
knows that the parameters are services. It then matches the text of the service name against
the manifest of its own services, as well as any custom services that we wrote ourselves,
and when a match is found, it instantiates that service object. The reason it can do this is
that it knows its own services and it knows what services we wrote because we had to
register them with Angular.
Dependency Injection and Services Chapter 11
[ 314 ]
The next thing Angular does, once it has these instantiated service objects, is to call our
class's constructor, passing the objects in as the arguments. That is the injection process that
Angular's injector service does. One more time, say it with me: Don't call us, we'll call you.
And just like that, the magic behind what Angular does has been explained away. Still, it's
very cool and we should tip our hat to the Angular development team.
Generating services and interfaces
Now that we have learned about DI and design patterns, in this section, we will learn to
create our services. Angular CLI provides us with the fastest and easiest way to generate
services inside our project. We will create a sample project called LearningDIServices by
running the following command:
ng new LearningDIServices
We are creating a new Angular project using the ng command and we name the
project LearningDIServices. Upon successful execution of the command, we should see
the output shown in the following screenshot:
Dependency Injection and Services Chapter 11
[ 315 ]
Now that we have our project directory created, using the Angular CLI, we will generate a
few services and interfaces. We will create a service called Photos. Run the following
command and we should see the service added to our project directory:
ng generate service photos
Upon successful execution, we should see the output shown in the following screenshot:
We can see that there are two new files generated. One is the service file and the other is
the spec file, which is for writing the tests for the service. Let's take a closer look at the files
containing autogenerated code for the photo.service.ts file:
import { Injectable } from '@angular/core';
@Injectable({
providedIn: 'root'
})
export class PhotosService {
constructor() { }
}
In the preceding code, we can see that the Injectable class needs to be imported from the
angular/core library. The Injectable class allows us to make the service inject in
various component classes so that we can reuse the methods. Using the injectable
decorator, we are explicitly mentioning that the service needs to be injected in the root. And
finally, we are exporting our PhotosService class, which will contain the constructor
method and other methods that we will create, specific to our application.
Unlike the Angular components, there is no need to update
app.module.ts file with an entry of the service.
Dependency Injection and Services Chapter 11
[ 316 ]
In previous sections, we learned about the overview of interfaces. Now, let's quickly learn
how to generate use of the interfaces in our applications. Using Angular CLI, we can also
quickly create interfaces:
ng generate interface photo
In the preceding command, we have generated an interface named photo and, once the
preceding command is executed successfully, we should see the following output:
Let's take a closer look at the interface files that are generated. The following is the default
code generated:
export interface Photo {
}
We can see it's empty intentionally. Since interfaces are used to define the entity or model
classes, each interface created in the application will be unique and specific to each
application. Now, if we want to create an interface for our photos, we will have to define it
as follows:
export interface Photo {
photoId: number;
photoURL: string;
photoOwner: string;
isActive: boolean;
}
In the preceding sample code, we have created an interface for photos with some properties
and their data types. This will allow us to create strictly typed objects for photos.
In this section, we learned to create Angular services and interfaces. Even if some of the
concepts are not very clear, do not worry, my friend. We have an entire chapter dedicated
to showing you how to generate and implement services in our applications. In the next
chapter, we will learn how to implement and use them and also integrate them into our
components.
Dependency Injection and Services Chapter 11
[ 317 ]
Guarding against code minification
There is one last thing that I would like to cover really quickly and that is code minification
and how we can guard against it. Code minification is the process of compressing our code
by removing the whitespace, as well as replacing variable names with very short symbols.
This is done when we compile our Angular application so that it becomes a smaller
package that our users have to download (once we've deployed our application) to retrieve
our application. But this does present a problem for us. It can wreck our day by changing
the parameter names and then Angular can no longer match the names against the service
manifest. Fortunately, there is an easy solution. If we add single quotes around our
parameter names, we protect our code against code minification. How? Well, putting
quotes around the service names turns them into literal strings and the minification
process does not compress or change strings-it leaves them intact. This is because literal
strings have a meaning outside of syntax and is not code. Minification just minifies code
(that is, variable and function names and whitespace). That's all you have to know about
protecting your code from code minification.
Summary
You should now feel comfortable with what DI is and what problem it solves. You should
also be able to list a few of the advantages-thus being able to explain why DI is a good
principle for us to follow in designing our applications. And you should also be
comfortable in explaining away the seemingly magical feats that Angular performs in
making everything work out of the box. And finally, you should also now know how to
guard your DI code against code minification.
Armed with this DI knowledge, we can now continue our journey into discovering one of
Angular's most useful services, its HTTP service, in Chapter 12, Integrating Backend Data
Services. Once you complete the next chapter, you will be ready to write code to integrate
your Angular application with virtually any RESTful API-compliant application and / or
service that your application is authorized to talk to. That should sound exciting to you! If it
does, turn the page and continue your journey to Angular enlightenment.
12 Integrating Backend Data
Services
Welcome to Chapter 12! This is definitely my favorite chapter, as we will be building many
end-to-end use cases for our application.
A gentle warning-this chapter is dense-it is packed with a ton of information. You may
have to read it at a slower pace and spend more time at the keyboard than you have with
the previous chapters, but, I must say, it is well worth the effort.
Here is a great way to look at the overall progression of this book:
Everything we've looked at so far, including the two most recent chapters
(Chapter 10, Working with Forms and Chapter 11, Dependency Injection and
Services), has laid the foundation for this chapter. With that knowledge under our
belts, we are now ready to put it all together in order to create our application.
So, in essence, this chapter also serves the purpose of reviewing many of the
topics we covered in previous chapters.
This chapter is the pivotal turning point for us because we will take everything
we've learned thus far to build 95% of our application in this single chapter. This
is a lot of material for one chapter, but we have spent a good amount of time
going over all the aspects of Angular that we will need to build our application,
so we're going to breeze through it. There is some new and slightly off-topic
material too-learning how to build backend APIs-which is less important than
the Angular material. However, we need to have an API, so I selected a set of
technologies that are simple enough to quickly get up to speed with. We are also
going over this to help you get your mind around the technologies we will be
using to construct the APIs.
In the chapters that follow this one, we will add a couple of things to our app
(such as route guards and custom form validation) and we will learn how to test,
debug, secure and deploy our application.
Integrating Backend Data Services Chapter 12
[ 319 ]
So, from that perspective, we're good to go. Many sections in this chapter are bonus
material that I deem important to learn about because I want you to succeed, not only as an
Angular developer, but as a web developer in general. This will help you to enhance your
skills and hands-on examples are sure to augment your technical knowledge as a web
developer.
We will cover the following topics:
ListingApp - an overview
Fundamental concepts for Angular applications
ListingApp - technical requirements
Building APIs for our application
The Google Firestore database
Angular HttpClient
Integrating backend services
We've spent a lot of time in this book discussing a myriad of things-mostly Angularcentric
(such as components, routing, flex-layout, NG Bootstrap, Angular Material, and
working with forms) and a few things that were standalone (such as wire-framing, ES6,
TS and Bootstrap). It is important to possess all that knowledge, of course, but we
haven't yet integrated live data to bring our Angular application to life. However, as you
can see from the previous bullet-point list, this is about to change. This is where developing
in Angular starts to get fun and also much more practical, since an application that does
not create and consume data is not much of an application at all.
OK. Let's get right into it by starting with learning about some of the fundamental concepts
that form the foundation of any application. Then, we'll take a look at the steps involved in
building our ListingApp.
ListingApp - an overview
In this chapter, we will be building our ListingApp application. In this section, we will
cover the functional requirement list. Our overall application plan can be broken down into
three main sections:
UI layer: The UI aspects involve designing or building the forms, displaying
data, routing and validations.
Integrating Backend Data Services Chapter 12
[ 320 ]
Services or middleware layer: We will learn how to write shared services, which
will be responsible for backend integrations with APIs and databases.
Database or fake API setup: We will learn how to set up fake APIs using JSON
Server and we will also learn how to create our NoSQL database using Firestore.
Here's the complete list of functional use cases we will be building as part of the learning
experience in this chapter:
Display all the listings
View listings by ID
Add a new listing
Edit a listing
Delete a listing
Add comments
Update comments
Delete comments
Edit comments
All the use cases listed will require us to implement HTTP calls. For some, we will need to
make POST, GET and PUT HTTP calls.
Before we proceed any further, now is a good time to bring back all the learning and
functionality we have implemented throughout the course of this book. We will need to
recollect how we designed and developed our forms, how we captured the form data, how
we displayed the data in the component templates, how we implemented routing with
parameters and how we call methods implemented in services inside components.
We have a lot of work to do and a load of fun awaits us, so let's get started!
Fundamental concepts for Angular
applications
We are going to learn and build a lot of interesting things in this chapter, but before we
start doing that, we should learn about a number of fundamental concepts, including
strongly typed language concepts, Angular models, observables, NoSQL databases, and
CRUD operations in general.
Integrating Backend Data Services Chapter 12
[ 321 ]
Strongly typed languages
A strongly typed programming language refers to the fact that each of the data types is
predefined and tightly coupled with the variables. Take a look at the following variable
that's been defined:
int age = 10;
We are declaring a variable and explicitly mentioned the fact that the type of variable is an
integer, which makes it very obvious that the variable cannot hold any other data type
except an integer. If we try to provide any value that is not an integer, TS will
throw an error. TS is also a strongly typed language and, since we write our
Angular applications in TS, we can conclude that Angular applications
follow strongly typed formats.
TS interfaces
In this section, we will learn how to create our own data types in TS, which we can
use in our Angular applications.
Angular models are a way to create complex data structures by clubbing multiple data
types into an object and defining a new object, which can then be used as a data type in
itself. It's Angular's way of ensuring that complex data objects adhere to certain predefined
data specs.
The TS language provides interfaces that also serve the same purpose. We can also
make use of ES6 classes to define our data structures. We can extend the programming
syntax to create our custom data types. Let's demonstrate this by creating a sample model.
We are going to create a model and call it Listing, which will have the following
properties:
export class Listing {
id: number;
userId: number;
title: string;
status: string;
price: number;
active: boolean;
}
Integrating Backend Data Services Chapter 12
[ 322 ]
We have created an Angular model, which is a class with properties such as id, userId,
title, status, price and active. We can now use this model as a data type in our
application. We can import this class into all of our components and services to make sure
our data map adheres to the Listing data spec.
We will use the previously defined model throughout this chapter while building our
application.
Observables
Most traditional applications work on the request and response architecture, which means
our application client will make a request for data to the server, and, in return, the server
will give us a response. While the server is returning the response, our application goes into
wait mode until all the responses are received, which obviously makes applications slow.
This architecture has multiple drawbacks. 1st, the application waits for a response, which
creates delays in applications. 2nd, there is no way we can handle multiple pieces of
data coming in over a period of time. 3rd, since our application waits until it gets the
response, which makes synchronous calls, we cannot execute asynchronous programming.
And finally, event handling becomes a nightmare for developers. So, how do we address
the preceding issues? The answer is by using observables.
Observables are a type of array that returns data over a period of time asynchronously.
Angular uses a 3rd-party library called Reactive Extensions (RxJS) and has observables
implemented inside the framework mainly for event handling, tree shaking and so on. We
can also easily import, create and subscribe to custom observables.
NoSQL databases concept
In this section, we are going to learn about NoSQL databases. Really? NoSQL? Are we not
going to use a database to store our critical data? Of course we are going to use a database
to store our data; however, it won't be a traditional relational database, which has a strict
predefined schema and columns that have a standard data type. With NoSQL databases,
everything is document-oriented and we can store data in one place without worrying
about the data types. NoSQL databases hold collections of documents.
Integrating Backend Data Services Chapter 12
[ 323 ]
We can still perform database activities such as the following:
Creating a document
Inserting a document
Editing an existing document
Deleting a document
We can also perform a lot of advanced functionality, such as indexing and authentication.
There are a lot of open source as well as commercial solutions that provide NoSQL
databases. Here's a quick list of some of the NoSQL database providers:
MongoDB
Redis
RavenDB
Firestore
MemcacheDB
During the course of developing our application in this chapter, we will implement
Firestore as our backend system. In the next section, we will learn about some of the
important tasks we will undertake involving these databases.
CRUD operations - overview
Whenever we consider using a database as a backend storage system for applications, the
primary goal is to be able to add, retrieve, search, or modify the data, which are
more commonly known as CRUD operations.
CRUD stands for Create, Read, Update and Delete in computer programming and these
terms are outlined as follows:
Create: Create or add new data to the database. We would usually be running an
INSERT query in the database. This is associated with the HTTP POST method.
Read: Read or retrieve data based on a filter or search criteria. We will run the
SELECT query in the database to do this. This is associated with the HTTP GET
method.
Update: Update or edit an existing record in the database. We will use the
UPDATE query in the database. This is associated with the HTTP PUT method.
Delete: Delete an existing record in the database. We can either use the DELETE
query to delete a record, or just set a column indicating that the record has been
deleted using the UPDATE query. This is associated with the DELETE method.
Integrating Backend Data Services Chapter 12
[ 324 ]
In the upcoming sections, we'll use these concepts to build our ListingApp functionality
and the technical requirements of our application.
ListingApp - technical requirements
Any good dynamic application will require us to work with APIs and we will need to store
the data in a database. This section covers two very important technical aspects required for
building any dynamic application-JSON APIs and a dynamic database. We will be making
use of the JSON server and for the database, we will use Google's Firestore database.
Building APIs for ListingApp
During the development cycle of any project, as a frontend developer, we will need to work
with APIs and integrate them into our application. We will need to define and agree upon
the JSON contracts that we expect from our APIs. In this section, we will learn about the
various options we have to generate the APIs that we can use while the backend developers
are still working on developing actual APIs. When we have fake APIs available, developers
can work independently.
There are various tools and libraries (available for free) that we can use to work with fake
APIs. We will be using the JSON server library to serve our APIs. So, let's begin by taking
the following steps:
1. To install the json-server library, run the following command in the
command-line interface:
npm i json-server --save
When the command has run successfully, you should see the following output:
Integrating Backend Data Services Chapter 12
[ 325 ]
2. Now that we have installed our json-server library, it's time to create our APIs
and JSON structure. In our project directory, we will create a new folder called
APIs and create a new file named data.json, which will hold our JSON data.
Take a look at the folder structure once you have created the folder and files:
3. Since we have created two JSON files, it's time to add some JSON data to the files
for listings, as well as users. Open the listings.json file by adding the
following data to it:
{
"listings": [
{ "id": 1, "title": "Sunset in New York", "price":"190",
"status": "Active" },
{ "id": 2, "title": "Dawn at Miami", "price":"150",
"status": "Active" },
{ "id": 3, "title": "Evening in California","price":"70",
"status": "Inactive" }
],
"users": [
{ "id": 1, "username": "andrew",
"userEmail": "andrew@localhost.com" },
{ "id": 2, "username": "stacy",
"userEmail": "stacy@localhost.com" },
Integrating Backend Data Services Chapter 12
[ 326 ]
{ "id": 3, "username": "linda",
"userEmail": "linda@localhost.com" },
{ "id": 4, "username": "shane",
"userEmail": "shane@localhost.com" }
],
"cities": [
{ "id":1, "name": "New York" },
{ "id":1, "name": "California" },
{ "id":1, "name": "Miami" }
]
}
We are creating dummy data of JSON arrays for listings, users and cities.
Technically, in a real application scenario, this data would be retrieved from the
database at runtime.
4. To start serving the fake APIs with data, we need to start and initialize the JSON
file. We will navigate to the API folder where we have created our data.json
file and run the following command:
json-server --watch data.json
5. When we have run the command successfully, we should see the following
output:
Integrating Backend Data Services Chapter 12
[ 327 ]
Notice that, under Resources, we can see the fake APIs that are listed; that
is, http://localhost:3000/listings.
6. Try launching the URL in the browser. You should see the JSON data displayed
for listings, users and cities. The output is displayed in the following
screenshot:
Awesome! We can now use these APIs in our HTTP calls. We will have to wait for just one
more section before we jump right into learning about HTTP functionality. For our friends
who are full stack developers and know how to set up databases, the next section is
certainly for you. We will learn about setting up our Firestore database, which will store
our data. Later, we will use this to implement our application.
Integrating Backend Data Services Chapter 12
[ 328 ]
Google Firestore database
The Google Firestore database is part of Google Cloud Platform. The official website of
Google Cloud describes it as follows:
Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL document
database that simplifies storing, syncing and querying data for your mobile, web and IoT
apps on a global scale. Reference: https://cloud. google.com/ firestore/
Firestore is a database as a service offered by Google and offers an easy-to-use NoSQL
document database. Since Firestore is also coming from the makers of Angular, it's natural
that there are libraries that support easy integrations between the two. In this section, we
will learn how to set up the Firestore database. So, let's begin:
1. We will need to log in to our Firebase application using our credentials. Upon
successful login, we should see the welcome screen, as displayed in the following
screenshot:
The home page will list all the projects we created in the Firebase application, and
you will also notice a big Add project link.
Integrating Backend Data Services Chapter 12
[ 329 ]
2. Now, let's create a new project for our application by clicking on the Add
project link.We will be prompted by a modal window where we need to enter
a Project name for our project, as shown in the following screenshot:
Here, we will enter Listings as our project name. Once our project has been
provisioned, we will be taken to the newly created project page.
Integrating Backend Data Services Chapter 12
[ 330 ]
3. We now click on Databases in the sidebar menu. We will be prompted to select
the mode in which we will initialize our database. We will select the test mode
for our testing and once we have performed the implementation, we will switch
the security mode:
As shown in the preceding screenshot, we are using a database in test mode,
which will allow us to read or write documents easily.
Do not forget to change the settings of the database if you want to use the
database in a production environment.
Integrating Backend Data Services Chapter 12
[ 331 ]
4. We'll now move on to create our comments collection. We'll add a unique
identifier called commentId. In addition, we are adding 3 fields as a schema
for the documents that will be stored in the collections, as shown here:
Since Firestore is a NoSQL document database, the schema is not restricted by any data
types. We can now perform CRUD operations, such as adding a new document, editing, or
even deleting documents, in the Firestore database.
In the last two sections, we have learned about creating fake APIs using the JSON Server,
and we have also created a NoSQL document database using Firestore. Now that we have
reached a stage where we have learned about all the fundamental concepts needed to start
implementing the end-to-end functionality of our ListingApp, let's jump into the HTTP
world!
Angular HttpClient
In this section, we will learn about the most important aspect of Angular-HttpClient.
Using the HttpClient interface, we can perform HTTP request and response calls. In the
previous chapter, we learned about dependency injection and services; in this chapter, we
will learn how to write services, which will include methods so that we can make HTTP
calls and process responses using HttpClient.
Integrating Backend Data Services Chapter 12
[ 332 ]
HttpClient is a small, easy-to-use, powerful library for performing HTTP request and
response calls. Using HttpClient, we can easily communicate with backend services, and
the module supports most modern web browsers. HttpClient comes with a lot of
advanced functionality, such as interceptors and progress events. HttpClient supports
various HTTP methods, including GET, POST, PUT, PATCH, DELETE, JSONP, and
options. Each of these calls always returns an observable. We have to subscribe to the
observables in order to process the responses. If we do not subscribe, nothing will happen.
HttpClientModule is available in the @angular/common/http library and needs to be
imported into the app.module.ts file; otherwise, we will encounter errors.
We now know about the HttpClient module, but before we jump into implementing the
module in our applications, it's good to know about some of the key functionality that got
added to HttpClient:
HttpClient provides a strongly typed response body.
The request/response objects in HttpClient are immutable.
The JSON format response is the default. We no longer have to map it into a
JSON object.
HttpClient provides interceptors that are really helpful in middleware for
intercepting an HttpRequest for transforming or processing a response.
HttpClient includes testability features. We can easily mock the requests and
process headers more efficiently.
In the following section, we will learn about the HttpClient module, which needs to be
imported into the component or service where we can make the HTTP calls. We will also
learn about the HTTP verbs that are available and learn about their purpose in modern
applications.
HttpClient and HTTP verbs
If the previous section was an introduction to HttpClientModule and HttpClient and its
advantages, in this section, we will dig deeper and also learn how to write some sample
code for implementing HttpClient.
Integrating Backend Data Services Chapter 12
[ 333 ]
As we mentioned earlier, HttpClient supports GET, POST, PUT, PATCH, DELETE,
JSONP and options methods, which will return observables. HttpClient also provides
modules, which can easily pass various options and data using HttpHeaders and
HttpParams.
In order to use HttpClient, we will need to import HttpClientModule into our
application module (app.module.ts) file and we also need to import HttpClient into
our services or components and inject HttpClient inside the constructor so that we can
use it to make HTTP calls. Add the following line of code to your app.module.ts file, and
don't forget to add it to the list of import modules as well:
// Import the module into the component or service
import { HttpClient } from '@angular/core/http';
// Inside the constructor method inject the HttpClient and create an
instance
constructor(private http: HttpClient)
Now, let's implement some of the most frequently used HTTP verbs.
We will implement the HTTP methods separately for both the JSON
server APIs and the Firestore database.
HTTP GET
We use the HTTP GET method to communicate with backend services to retrieve
information from a particular URL resource. The sample code to get all listings is as
follows:
getAllListings():Observable<any>
{
return this.http.get<Observable>('api/get-listing');
}
We have created a method named getAllListings and we have explicitly mentioning
the fact that the method will return an observable value of any data type. We have to pass
the URL to the GET method. The URL is a mandatory value we need to pass. We can also
pass optional data such as Headers, Params, reportProgress and responseType. The
GET method will return an instance of an RxJS observable and we can subscribe to listen to
the response.
Integrating Backend Data Services Chapter 12
[ 334 ]
On similar terms, we can easily create HTTP calls using the POST, PUT and DELETE
methods.
HTTP POST
Whenever we need to send any data or information securely to the server, such as a
username, password and email, we always use the POST method. The HTTP POST verb is
always associated with creating or adding new data. It's secure and does not make data
visible in the URL, unlike GET. In the POST method, along with the URL as a string, we
will need to pass data to the URL. We can also pass options to the POST method, such as
Headers and Params. The following is the sample code for writing a sample HTTP POST
call:
addNewListing(listing) {
let httpHeaders = new HttpHeaders();
httpHeaders.set('Content-Type', 'application/json');
let options = { headers: httpHeaders};
return this.http.post('api/add-listing', listing, options);
}
In the preceding code, we are creating a new method called addNewListing, which is
accepting a param listing, which we will use as our data. We are creating an instance of
HttpHeaders, so we create an object of the class and we are setting the value of
the Content-Type object to be application/json. We are then creating variable options
and formatting them to send headers. Finally, we are making use of the http.post method
to make a POST request.
HTTP PUT
In this section, we will learn how to make HTTP PUT calls. The PUT method is used to
update or edit an existing dataset in the server. The HTTP PUT method involves a two-step
process. 1st, we will need to retrieve data that we need to update and then pass the
updated information back to the server using the POST method. The following is the
sample code for creating the PUT method:
this.http.put(url, options);
We need to pass the URL as a mandatory parameter for the PUT method. Fortunately, there
are various options available. Np. we can pass headers, params and suchlike in
the options.
Integrating Backend Data Services Chapter 12
[ 335 ]
HTTP DELETE
DELETE is an important operation of CRUD functionality. We can easily perform delete
operations using the HTTP DELETE method. The delete operation can be achieved
depending on the use case and the application's compliance. There are two types of
deletions we can do-soft delete and hard delete:
Soft delete: When using soft delete, we do not delete or erase the records from
our database systems; instead, we update the records and set a column or field
and mark it as deleted so that the records are not displayed to the user.
Hard delete: The requested data is deleted permanently from the database
system. Once the data is erased, it cannot be reverted or restored.
Let me give you a good example of both use cases. If you try to delete your Google account,
it notifies you that you can come back and restore your account within x number of days,
after which the data will be completely erased from their servers.
Back to our implementation. We can use the http.delete() method to implement the
DELETE functionality in our applications. The sample code is given here:
this.http.delete(url, options);
We need to pass the URL value as mandatory and options, as the name implies, are
optional for the delete method.
HTTP via promises
Promises are just a technical implementation of what real-world promises do! Suppose you
had promised your boss that you would complete tasks assigned to you. If you do, that
means a promise has been resolved and if you don't, it means it's been rejected. Similarly, a
Promise in HTTP implementation means that we will wait for future data, either resolved
or rejected and then we'll do some logical processing based on the output received.
HTTP promises are a way to keep a placeholder for future data based on the success or
failed states. Does this sound similar to regular HTTP calls? Yes, they are, with a major
striking difference-promises are asynchronous in nature. When we make HTTP calls in
Angular, it will wait until the request is completed and we receive the response; JS
will continue with the execution and, if it encounters synchronous assignments/operations,
it will execute them immediately and fail if they are dependent on previous states or data.
Integrating Backend Data Services Chapter 12
[ 336 ]
A promise takes a callback method, which will take two parameters-resolve and
reject. resolve means the method will return a promise object with a given message,
while reject means the promise object is rejected with a reason. Then, you can
expect .then and .catch to be called back if all goes well or not, respectively. The
following is the sample code for writing a promise, showing the handling responses of
resolve and reject:
//check if the listing status is active
ListingDetails(listing){
let promise = new Promise(function(resolve, reject) {
if(listing.status == 'active') {
resolved("listing is active");
}
else {
reject("listing is not active");
}
promise.then((s => {
//next steps after the promise has returned resolved
}).catch((err => {
// what to do when it's error or rejected
})
}
Let's analyze the preceding code in detail. We have implemented a promise and, as
specified, the callback method will take two parameters, resolve and reject. We check
whether the status of the listing is active; if yes, we resolve the promise; otherwise, we reject
the promise. By default, the data returned by the resolved method will be passed to
the .then method and any failures or exceptions will be passed to the .catch method.
Since promises are asynchronous, which means we can chain events or methods, go ahead
and add a method that will be called inside the .then method.
Awesome! We are now armed with all the theoretical knowledge about the classes and
modules provided by Angular for HTTP functionality. We learned about
HttpClientModule, HttpClient, and, above all, we learned about the various HTTP
verbs we can make use of in our application. We also learned about HTTP observables and
promises.
Integrating Backend Data Services Chapter 12
[ 337 ]
Now, it's time to get our hands dirty with code. We will learn how to create our multiple
data sources, which we will need to integrate using HTTP calls. The 1st one will be using
the fake JSON server APIs, while the 2nd one will be using the Firestore database. In the
next section, we will learn about and create, the services that we will need before we start
our mission of integrating functionality end to end.
Integrating backend services
We are making really good progress here, so let's keep rolling. One of the best practices in
software development is to create code that is reusable, generic and maintainable. In most
applications that are dynamic in nature, we need to make a lot of HTTP calls to create, save,
retrieve, edit, or delete data, as per the functional requirements of the application. If we do
not have commonly shared HTTP calls, we may end up with a lot of methods having HTTP
implementations and it will be very difficult to maintain them in the long run. How do we
address this situation? You already know the answer, my friend. That's right-by using
services. In Chapter 11, Dependency Injection and Services, we learned all about Angular
services and best practices regarding dependency injection.
Angular guidelines clearly state that all HTTP calls and functionality should be kept in
services, which makes it easy to reuse existing code. Angular services are shared functions
that allow us to access the properties and methods defined inside it. We will also create our
custom services, in which we will implement our HTTP calls and which can be easily
reused in various components. Let's create two services-one for working with JSON server
APIs and one for Firestore database operations. For working with JSON server APIs, we
will call our DbOperationsService service and for working with the Firestore database,
we will call our CRUDService service. Each of these services will have the methods to make
HTTP calls for creating, reading, updating and deleting the data. Now, let's run the
following ng command, which will generate our services:
ng generate service db-operations
Upon successful execution of the preceding command, we will execute the following
command to generate another service. Let's call it crud. We will use the following ng
command to generate the service.
ng generate service crud
Following a successful run, we should see the service files being generated, along with their
respective spec files. So far, so good. We will need these services when we start the end-toend
integration work. It may look complicated, but trust me, all of it will make a lot of
sense in the sections to follow.
Integrating Backend Data Services Chapter 12
[ 338 ]
Integrating Angular HTTP with backend APIs
This section is very important as this is the melting pot for most of the topics we have
learned about throughout the course of this book. We are going to do complete end-to-end
integration, from the UI to services, through to data sources.
We will need to generate the components that we are going to use in our application. Let's
run the following ng commands to generate four components:
ng g component createListing
ng g component viewListing
ng g component deleteListing
ng g component updateListing
When these commands are run successfully, we should see the output shown in the
following screenshot:
Integrating Backend Data Services Chapter 12
[ 339 ]
Now that we have generated our components, we will make use of
the DbOperationsService service we generated in the previous section. We will also use
our fake APIs that we created using the JSON server. We will implement methods for
getting all the listings, viewing a particular listing, editing an existing listing and finally,
deleting a listing. In order to achieve this, we will need to import HttpClientModule into
our app.module.ts file. We will also need to import HttpClient into our dboperations.
service.ts service file. We will also import the HttpHeaders module. This
is not mandatory, but, by way of good practice, we will be importing and using it while
making our HTTP calls. We will be adding the following code to the dboperations.
service.ts file:
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
@Injectable({
providedIn: 'root'
})
export class DbOperationsService {
constructor(private http: HttpClient) { }
getListings(){
return this.http.get('http://localhost:3000/listings');
}
viewListing(id){
return this.http.get('http://localhost:3000/listings/'+id);
}
addListing(newList){
let headers = new HttpHeaders({ 'Content-Type': 'application/json' });
return this.http.post('http://localhost:3000/listings', newList);
}
editListing(id, newList){
let headers = new HttpHeaders({ 'Content-Type': 'application/json' });
return this.http.put('http://localhost:3000/listings/'+id, newList);
}
deleteListing(id){
return this.http.delete('http://localhost:3000/listings/'+id);
}
}
Integrating Backend Data Services Chapter 12
[ 340 ]
Let's analyze the preceding code in detail. 1st, we are importing the required
modules: Injectable, HttpClient, HttpHeaders and HttpParams. We are then
injecting HttpClient into our constructor and creating an instance named http. We are
then creating four methods, namely; getListings, viewListing, editListing, and
deleteListing. In the getListings method, we are calling the API URL using the HTTP
GET method. This will return all the listings from the data.json file we created earlier.
In viewListing, we pass the ID of the Listing to retrieve the data of the listing using the
HTTP GET method. In the addListing method, we are calling the API and passing the
data object using the HTTP POST method. This will create a new row in our JSON file. Next
up is the editListing method, which takes two parameters-the ID of the listing and the
updated data object, which we need to save. The last method is deleteListing, to which
we will pass the ID of the listing we want to delete.
In a more practical world, we would need to pass authentication tokens,
additional security, cleaning data and so on.
We have now made our custom service, which includes the methods that will make HTTP
calls. Before we start working on our components, we will create a few routes where we
will map the components we have generated. Open the app-routing.module.ts file and
import all our components inside it. Then, we will need to add the routes to it, as shown in
the following code block:
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import {UpdateListingComponent} from './update-listing/updatelisting.
component';
import {CreateListingComponent} from './create-listing/createlisting.
component';
import {ViewListingComponent} from './view-listing/view-listing.component';
import {DeleteListingComponent} from './delete-listing/deletelisting.
component';
const routes: Routes = [
{path:'create-listing', component:CreateListingComponent },
{ path:'view-listing', component:ViewListingComponent },
{ path:'delete-listing/:id', component:DeleteListingComponent},
{path:'update-listing/:id', component:UpdateListingComponent}
];
@NgModule({
imports: [RouterModule.forRoot(routes)],
exports: [RouterModule]
Integrating Backend Data Services Chapter 12
[ 341 ]
})
export class AppRoutingModule { }
In the preceding code, we are updating our AppRoutingModule and adding five routes.
We created the create-listing and view-listing routes and mapped them to
CreateListingComponent and ViewListingComponent, respectively. That's very
straightforward. For the delete-listing and update-listing routes, notice that we are
passing a parameter named ID. We will use these and pass the listing ID in order to delete
or update the data for a listing.
Now that we have created our service and routes, they are ready to be implemented in our
components. Let's start working on our components. 1st, we will start with
ViewListingComponent. Open the view-listing.component.ts file and add
functionality to retrieve all the listings, as shown in the following code block:
import { Component, OnInit } from '@angular/core';
import {DbOperationsService} from '../db-operations.service';
import { Listing} from '../models/listing';
import {Observable} from 'rxjs';
@Component({
selector: 'app-view-listing',
templateUrl: './view-listing.component.html',
styleUrls: ['./view-listing.component.scss']
})
export class ViewListingComponent implements OnInit {
listArr: Observable<any[]>;
viewList:Observable<Listing>;
isViewPage: boolean = false;
constructor(private dbOps: DbOperationsService ) { }
ngOnInit() {
this.dbOps.getListings().subscribe((data) => {this.listArr = data});
}
showListing(listing){
this.isViewPage = true;
this.dbOps.viewListing(listing.id).subscribe((data) => {this.viewList =
data});
}
}
Integrating Backend Data Services Chapter 12
[ 342 ]
Let's analyze the preceding code in detail. 1st, we need to import all the required modules
and classes. We are importing DbOperationsService we created. We are also importing
the listing interface class we created previously. Since we will be working with
the Listing interface class, we will need to import Observable from rxjs. Next, we are
declaring our selector as app-view-listing; we will call this directive in the template
view-listing.component.html file. We will now create 3 variables, named
listArr, viewList and isViewPage. Note that listArr and viewList are declared as
Observable. The difference between the listArr and viewList variables is
that listArr is an observable of the Listing type and is an array, whereas viewList is an
Observable of the Listing type and will hold a single list value. Since we have imported a
service, we will need to create an instance called dbOps in our constructor method. We will
implement the ngOnInIt method here; we are calling the getListings method using the
instance of the dbOps service. We are subscribing to the method, which means we will map
the data to the listArr variable. We will then use the listArr variable to display it in the
template file. Finally, we are creating a showListing method to which we are passing the
listing object. Using the instance of the service, we are calling the viewListing method
and passing the listing ID. We are subscribing to the data and mapping it to the viewList
variable.
Now, we need to update our template in the view-listing.component.html file and use
the listArr and viewList variables to display the data in the page, as shown in the
following code block:
<h4>Show All Listings</h4>
<table class="table table-bordered">
<tbody>
<tr>
<th>Title</th>
<th>Description</th>
<th>Price</th>
<th>Status</th>
<th>Actions</th>
</tr>
<tr *ngFor="let listing of listArr;let i = index">
<td>{{listing.title}}</td>
<td>{{listing.description}}</td>
<td>{{listing.price}}</td>
<td>{{listing.status}}</td>
<td><a [routerLink]="'/update-listing/'+listing.id">Edit</a> |
<a [routerLink]="'/delete-listing/'+listing.id">Delete</a></td>
</tr>
</tbody>
</table>
Integrating Backend Data Services Chapter 12
[ 343 ]
In the preceding code, we have created a table. Using ngFor, we are looping the data that
we get from the API, and, using interpolation, we are displaying the data in the table rows.
Note that, for the anchor tags, we are using the routerLink directive to dynamically create
the link and we are passing the ID for the edit and delete links.
I am sure you are excited about the end result. Let's run the ng serve command. You
should see the following output:
Beautiful! Now things are really cooking! There's no better encouragement than seeing the
code in action. We have added the Add New Listing menu link, so now it's time to
implement that functionality in our createListing component.
Open createListingComponent and modify the create-listing.component.ts file
by adding the following code to it:
import { Component, OnInit } from '@angular/core';
import {DbOperationsService} from '../db-operations.service';
@Component({
selector: 'app-create-listing',
templateUrl: './create-listing.component.html',
styleUrls: ['./create-listing.component.scss']
})
export class CreateListingComponent implements OnInit {
userId = 1;
newListing;
successMsg;
Integrating Backend Data Services Chapter 12
[ 344 ]
constructor(private dbOps: DbOperationsService) { }
ngOnInit() {
}
addNewList(listForm)
{
this.newListing = {
"userId":this.userId,
"id": 152,
"title":listForm.title,
"price":listForm.price,
"status":listForm.status,
};
this.dbOps.addListing(this.newListing).subscribe((data) => {
this.successMsg = data;
});
}
}
Let's analyze the preceding code in detail. We are importing the required modules in the
file. We are also importing the DbOperationsService, which we created earlier. We are
creating a few variables; that is, userId, newListing and successMsg and assigning
some initial values. We are creating an addNewList method and we are passing the
listForm data. We are also creating a data structure similar to our listing model that we
created. Next, using the instance of the service, we are calling the addListing method and
passing the data object that we need to save. This will create a new record in our
data.json file. Finally, we are mapping the result to the successMsg variable. We will
use this to display the success message to the user.
Since we are using a fake API, we have stubbed the value of the ID. In a
more real-time scenario, this ID will be auto-incremented on the database
side and would always be a unique value.
Integrating Backend Data Services Chapter 12
[ 345 ]
Now, it's time to update our template file so that we can get data from the user using the
form. Open the create-listing.component.html file and add the following code to it:
<h4>Add New Listing</h4>
<p>
<div class="container">
<div *ngIf="successMsg">List Added Successful</div>
<form #listingForm="ngForm" (ngSubmit)="addNewList(listingForm)">
<div class="form-group">
<label for="title">Enter Listing Title</label>
<input type="text" [ngModel]="title" name="title" class="form-control"
placeholder="Enter title">
</div>
<div class="form-group">
<label for="price">Enter Description</label>
<input type="text" [ngModel]="description" name="description"
class="form-control" placeholder="Enter Description">
</div>
<div class="form-group">
<label for="price">Enter Price</label>
<input type="number" [ngModel]="price" name="price" class="form-control"
placeholder="Enter price here">
</div>
<div class="form-group form-check">
<input type="checkbox" [ngModel]="status" name="status"
class="form-check-input">
<label class="form-check-label" for="status">Active?</label>
</div>
<button type="submit" class="btn btn-primary">Add New Listing</button>
</form>
</div>
In the preceding code, we are creating a form using the template-driven forms. We have
created a few form fields to capture data, such as title, description, price and active. We are
using the template variables for the form and the fields. We are also calling
the addNewList method on the ngSubmit event and submitting the entire form. By
running the ng serve command, we should see the following output:
Integrating Backend Data Services Chapter 12
[ 346 ]
Now, go ahead and add some data to the form fields and then click on the Submit button.
You should see a success message if the record has been created successfully:
Integrating Backend Data Services Chapter 12
[ 347 ]
Now, click on the Get All Listings link in the menu. You should see the newly created
record in the listings displayed in the table. Do you remember, that we added the edit and
delete links for the listings? It's time to implement them now. We will start with the edit
functionality 1st and then implement the delete functionality.
Open our update listing component, edit the update-listing.component.ts file, and
then add the following code to it:
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from "@angular/router";
import {DbOperationsService} from '../db-operations.service';
import { Listing} from '../models/listing';
import {Observable} from 'rxjs';
@Component({
selector: 'app-update-listing',
templateUrl: './update-listing.component.html',
styleUrls: ['./update-listing.component.scss']
})
export class UpdateListingComponent implements OnInit {
listId;
successMsg = false;
viewList: Observable<Listing>;
constructor(private route:ActivatedRoute, private
dbOps:DbOperationsService) { }
ngOnInit() {
this.listId = this.route.snapshot.paramMap.get("id");
this.dbOps.viewListing(this.listId).subscribe((data)
=> {this.viewList = data});
}
editListing(updatedList){
this.dbOps.editListing(updatedList.id, updatedList).subscribe((data) =>
{
this.successMsg = data;
});
}
}
Integrating Backend Data Services Chapter 12
[ 348 ]
Let's analyze the preceding code in detail. We are importing the required modules into our
component file. We are importing ActivatedRoute, our service, listing interface class, and
observable into the component file. In order to achieve update functionality, we need to do
two things. 1st, we will need to retrieve the data of the listing for which the ID is passed.
Once the user updates the data and clicks on the Submit button, we will persist the data for
that listing. We will also need to inject the router and service into our constructor. On the
ngOnInit method, using the router snapshot, we are capturing the ID of the listing from
the URL. Then, using the instance of the service, we are calling the viewListing method to
get details of the listing based on the ID that's passed. Finally, we have created an
editListing method. Using the instance of the service, we are calling the
editListing method and so we need to pass two parameters, one for passing the ID of
the listing and another for passing the updated data of the listings.
Now, let's update our template file. Open the update-listing.component.html file and
add the following code:
<div class="container">
<div *ngIf="successMsg">List Updated Successful</div>
<form #editlistingForm="ngForm" (ngSubmit)="editListing(editlistingForm)">
<div class="form-group">
<input type="hidden" class="form-control" name="id"
[(ngModel)]="viewList.id" ngModel #id>
</div>
<div class="form-group">
<input type="hidden" class="form-control" name="userId"
[(ngModel)]="viewList.userId" ngModel #userId>
</div>
<div class="form-group">
<label for="title">Enter Listing Title</label>
<input type="text" class="form-control" name="title"
[(ngModel)]="viewList.title" ngModel #title required>
</div>
<div class="form-group">
<label for="price">Enter Description</label>
<input type="text" name="description" [(ngModel)]="viewList.description"
ngModel #description class="form-control" required>
</div>
<div class="form-group">
<label for="price">Enter Price</label>
<input type="number" [(ngModel)]="viewList.price" name="price"
class="form-control" ngModel #price required>
</div>
<div class="form-group form-check">
<input type="checkbox" [(ngModel)]="viewList.status"
checked="{{viewList.status}}" name="status" ngModel
#status class="form-check-input" required>
Integrating Backend Data Services Chapter 12
[ 349 ]
<label class="form-check-label" for="status">Active?</label>
</div>
<button type="submit" [disabled]="!editListingForm.valid"
class="btn btn-primary">Update Listing</button>
</form>
</div>
In the preceding code, we are once again creating a form based on the template-driven form
approach. You will notice that the edit form is very much similar to the create listing form.
You are almost correct, but there are some important differences. Note that we are now
using 2-way data binding with ngModel and binding the value to the form field. With
this, when we get the initial data, it's displayed in the form field. Now, the user can edit
data and, when clicking on the Update Listing button, the data is sent to the addListing
method and persisted in the backend API. Now, let's see it in action. By running the ng
serve command, we should see the following output:
Notice that the URL has the ID of the listing that was passed as the parameter. The data is
retrieved and has been displayed on the page load. Now, when the user updates the details
in the form and clicks on the Submit button, this will update the data of the listings. That's
your homework.
Integrating Backend Data Services Chapter 12
[ 350 ]
Alright, so we have implemented create, edit and view functionality. Next, we will
implement the delete functionality of the listings. remember, that, for the delete and edit
functionalities, the user will always navigate to the pages on click-through anchor tags.
Open DeleteListingComponent and update the delete-listing.component.ts file,
as shown in the following code block:
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from "@angular/router";
import {DbOperationsService} from '../db-operations.service';
import { Listing} from '../models/listing';
import {Observable} from 'rxjs';
@Component({
selector: 'app-delete-listing',
templateUrl: './delete-listing.component.html',
styleUrls: ['./delete-listing.component.scss']
})
export class DeleteListingComponent implements OnInit {
viewList:Observable<Listing>;
listId;
successMsg:Observable<Listing>;
constructor(private route:ActivatedRoute, private
dbOps:DbOperationsService) { }
ngOnInit() {
this.listId = this.route.snapshot.paramMap.get("id");
this.dbOps.deleteListing(this.listId).subscribe((data) => {
this.successMsg = data;
});
}
}
Let's analyze the preceding code in detail. We are importing the required modules in the
component file; that is, ActivatedRoute, DbOperationsService, Listing, and
Observable. We are also creating a few variables-viewList, ListId and successMsg.
Then, we are injecting the route and service into the constructor method. Finally, with
the ngOnInIt method, we are passing the ID of the listing that needs to be deleted. We are
subscribing the data and mapping it to successMsg.
Integrating Backend Data Services Chapter 12
[ 351 ]
In this section, we have learned how to implement basic CRUD operations for our
ListingApp. Then, we learned how to make HTTP calls for the GET, POST, PUT, and
DELETE methods. Finally, we learned how to create fake APIs using the JSON Server. In
the next section, we will learn how to implement CRUD operations using the cloud NoSQL
Firestore database.
Integrating Angular HTTP with Google Firebase
In this section, we will learn how to implement HTTP functionality for a NoSQL Firestore
database. We created our Firestore database in an earlier section. Now is the right time to
integrate the Angular HTTP calls, which will invoke and work with the Firestore database.
What are the use cases we will implement? For our ListingApp, we will need a
commenting system. As a user, we should be able to add, edit, delete and view comments.
All of these use cases will require us to make HTTP calls to APIs to save, retrieve, and
delete comments.
Angular Fire is the official library for Firebase. The library provides a lot of built-in
modules that support activities such as authentication, working with Firestore databases,
observable-based push notifications and much more.
We will need to install this module under @angular/fire. Run the following command in
the command-line interface to install the library:
npm i @angular/fire
When we run the preceding command successfully, we should see the following output:
Once we have installed the library, we will proceed and create a new custom service for our
integration pieces with the Firestore database.
Run the following command to generate a new service:
ng generate service crudService
Integrating Backend Data Services Chapter 12
[ 352 ]
When we run the preceding command successfully, we should see the following output:
You will notice that two files are generated. We will implement all our HTTP calls inside
the service. As we mentioned previously, we will need to create a few components that will
map to each piece of functionality and will internally call the service that has the HTTP
implementations.
Run the following ng generate commands to generate components for the comment's
functionality:
ng generate component addComments
ng generate component viewComments
ng generate component editComments
ng generate component deleteComments
When we run the preceding commands successfully, we should see the following output:
Integrating Backend Data Services Chapter 12
[ 353 ]
You will notice that the components have been generated and added to our project
directory. You will also notice that the app.module.ts file has been updated with entries
for the components.
We have generated our components and the service that's required for our integration. We
have also installed the Angular Fire library. In order to use the Angular Fire library in our
application, we will need to import the library into our app.module.ts file. Import the
required modules into the app module file and list the modules in the import list of our
application, as shown here:
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { HttpClientModule} from '@angular/common/http';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { CreateListingComponent } from './create-listing/createlisting.
component';
import { ViewListingComponent } from './view-listing/viewlisting.
component';
import { DeleteListingComponent } from './delete-listing/deletelisting.
component';
import { UpdateListingComponent } from './update-listing/updatelisting.
component';
import {FormsModule} from '@angular/forms';
import { AngularFireModule} from 'angularfire2';
import {AngularFireDatabaseModule} from 'angularfire2/database';
import { AngularFireAuth } from '@angular/fire/auth';
import { environment } from './firebase-config';
import { AngularFirestore } from '@angular/fire/firestore';
import { AddCommentsComponent } from './add-comments/addcomments.
component';
import { EditCommentsComponent } from './edit-comments/editcomments.
component';
import { ViewCommentsComponent } from './view-comments/viewcomments.
component';
import { DeleteCommentsComponent } from './delete-comments/deletecomments.
component';
@NgModule({
declarations: [
AppComponent,
CreateListingComponent,
ViewListingComponent,
DeleteListingComponent,
Integrating Backend Data Services Chapter 12
[ 354 ]
UpdateListingComponent,
AddCommentsComponent,
EditCommentsComponent,
ViewCommentsComponent,
DeleteCommentsComponent
],
imports: [
BrowserModule,
HttpClientModule,
AppRoutingModule,
AngularFireModule.initializeApp(environment.firebaseConfig),
AngularFireDatabaseModule,
FormsModule
],
providers: [AngularFirestore],
bootstrap: [AppComponent]
})
export class AppModule { }
One important thing to note in the preceding code is that we are importing the required
modules from Angular Fire and also listing them under the import module list. Notice that
we have imported a file called firebase-config. These are environment variables, which
will hold the API keys for authentication with Firebase. We can find the API keys listed
under the Firebase account, as shown in the following screenshot:
Integrating Backend Data Services Chapter 12
[ 355 ]
We will need to copy the details into the firebase-config.ts file. The following
screenshot displays the settings specified in our ListingApp:
So far, so good. Now that we have installed the required library, imported the modules,
and done the configuration settings, it's time to work on our application components. We
are making great progress here. Let's keep this momentum going.
Now that we have created our components, we will quickly modify our approuting.
module.ts file and create a new route for each of these components.
We have already mastered Angular routing, in Chapter 4, Routing. Revisit
that chapter if you need a quick refresher.
In the following code, we have imported all the required component classes into the approuting.
module.ts file and added the respective routes to the routing file:
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import {UpdateListingComponent} from './update-listing/updateIntegrating
Backend Data Services Chapter 12
[ 356 ]
listing.component';
import {CreateListingComponent} from './create-listing/createlisting.
component';
import {ViewListingComponent} from './view-listing/view-listing.component';
import {DeleteListingComponent} from './delete-listing/deletelisting.
component';
import { AddCommentsComponent } from './add-comments/addcomments.
component';
import { EditCommentsComponent } from './edit-comments/editcomments.
component';
import { ViewCommentsComponent } from './view-comments/viewcomments.
component';
import { DeleteCommentsComponent } from './delete-comments/deletecomments.
component';
const routes: Routes = [
{ path:'create-listing', component:CreateListingComponent },
{ path:'view-listing', component:ViewListingComponent },
{ path:'delete-listing/:id', component:DeleteListingComponent},
{ path:'update-listing/:id', component:UpdateListingComponent},
{ path:'add-comment', component:AddCommentsComponent },
{ path:'view-comment', component:ViewCommentsComponent },
{ path:'delete-comment/:id', component:DeleteCommentsComponent},
{ path:'update-comment/:id', component:EditCommentsComponent}
];
@NgModule({
imports: [RouterModule.forRoot(routes)],
exports: [RouterModule]
})
export class AppRoutingModule { }
We will use the four newly created routes to implement the comment's functionality in
ListingApp. We are going to add the CRUD operations using the Firestore database. We
will need to import the AngularFirestore module to our service, as shown here:
import { AngularFirestore } from '@angular/fire/firestore';
After we have imported the module into our file, we will need to inject it inside the
constructor method, as follows:
constructor(private afStore : AngularFirestore, private route: Router ) { }
Integrating Backend Data Services Chapter 12
[ 357 ]
We can now make use of the AngularFirestore module and implement CRUD
operations using Firestore. Take a look at the complete updated code in the crudservice.
service.ts file:
import { Injectable } from '@angular/core';
import { AngularFireAuth } from '@angular/fire/auth';
import { environment } from './firebase-config';
import { AngularFirestore } from '@angular/fire/firestore';
@Injectable({
providedIn: 'root'
})
export class CrudServiceService {
constructor(private afStore : AngularFirestore) { }
getComments() {
return this.afStore.collection('comments');
}
deleteComment(id) {
this.afStore.collection('comments').doc(id).delete();
}
addComment(newComment) {
this.afStore.collection('comments').add(newComment);
}
updateComment(id, editedComment) {
this.afStore.collection('comments').doc(id).set(editedComment);
}
}
Let's analyze the preceding code in detail. We have imported all the required modules,
including our Angular Fire module and our firebase-config file. Since we have
imported our AngularFireStore module, we will need to inject it into our constructor
method and create an instance of it. We are creating methods for each of the actions for the
comment's functionality. In the getComments method, we are retrieving all the data from
the comments collection. In the deleteComment method, we are passing the ID of the
comment we need to delete. In the addComment method, we are passing the data that we
want to store in our collection. In the updateComment method, we are passing two
parameters; the 1st is the ID of the comment we want to update and the 2nd is the
updated data that we need to persist in the database.
Integrating Backend Data Services Chapter 12
[ 358 ]
You may wonder why we did not make any HTTP calls in these methods? The
AngularFireStore module internally makes HTTP calls to the service and will
authenticate and get account-specific information from the firebase config file.
In earlier sections, we learned how to send data from components to the service, right?
Along the same lines, go ahead and try for comments functionality. That's your homework.
Summary
How do you feel? You should feel great and you should be proud of yourself! This chapter
was a lot of work, but we're better off for having done it. It brought together all the aspects
we have learned so far, such as forms, components, routing, services and more.
For frontend developers, having a fake API setup in the local development environment
always helps us to work independently without depending on backend developers or APIs.
We learned about building fake APIs using the JSON server. We learned about the NoSQL
document database, particularly the Firestore database provided by Google Cloud. We
deep dived into Angular HTTP concepts and functionalities. We learned how to make
HTTP POST, GET, PUT and DELETE calls. We also implemented our entire application's
functional use cases using both the JSON Server and Firestore databases.
We have made tremendous progress so far. We are now capable of developing Angular
applications end to end, utilizing all the superpowers that Angular provides, including
forms, components, services, routing and much more. At the end of this chapter, I am
confident that we are able to bring together all the pieces of the Angular framework into a
single working app.
Having a working application up and running is a good sign of progress. But the important
factor in terms of judging the application is to look at the quality checks or unit tests.
In the next chapter, we are going to learn how to write unit tests to make sure we catch any
defects early in the product development life cycle. Writing test scripts ensures quality and
is a great sign of handling all use cases, including both the happy and negative paths of our
application.
13 Unit Testing
You've probably written unit tests for traditional server-side code, such as for Java, Python,
or C#. Unit testing is, of course, just as important on the client side, and, in this chapter, you
will learn about Angular testing, including the Jasmine and Karma frameworks, two
excellent tools for unit testing your client-side code.
Together, we'll explore how we can unit test various parts of our Angular application, such
as our components, routes and dependency injection (DI).
This chapter will cover the following topics:
An introduction to Jasmine and Karma
Testing directives
Testing components
Testing routing
Testing dependency injection
Testing HTTP
Introduction to testing frameworks
In this section, we will learn about two important testing frameworks, namely Jasmine and
Karma.
Testing is as important as development itself. It's a highly debatable topic, with some
experts believing in test-driven development (TDD), which means that writing test scripts
is important even before we write development code.
The beauty about Angular framework is that it natively supports testing frameworks and
offers a lot of testing utilities that make the developer's job happy and easy. We are not
complaining at all.
Unit Testing Chapter 13
[ 360 ]
Angular provides us with a core testing module, which has a lot of awesome classes we can
make use of and natively supports two important testing frameworks, namely Jasmine and
Karma:
We write our test scripts using the Jasmine framework.
We use the Karma framework to execute the test scripts.
About the Jasmine framework
Jasmine is a leading open source testing framework for writing and testing automated test
scripts for modern web frameworks.
Certainly, for Angular, Jasmine has become the de facto, go-to framework. The following is
taken from the official website:
"Jasmine is a behavior-driven development framework for testing JS code. It does
not depend on any other JS frameworks. It does not require a DOM. And it has a
clean, obvious syntax so that you can easily write tests."
The idea behind writing Jasmine test scripts are behaviorally and functionally driven. Test
scripts have two important elements-describe and the specs (it):
The describe function is for grouping related specs together.
The specs are defined by calling the it function.
Here's a sample test script, which is written in Jasmine:
describe("Test suite", function() {
it("contains spec with an expectation", function() {
expect(true).toBe(true);
});
});
In the process of writing test specs, we have to use a lot of conditional checks to match data,
elements, results, asserting conditions and much more. The Jasmine framework provides a
lot of matchers, which we can readily use while writing our test specs. In the preceding
sample code, toBe is one such example of a matcher.
Unit Testing Chapter 13
[ 361 ]
Here's a list of the most commonly and frequently used matchers in Jasmine:
toBe
toBeTruthy
toBeFalsy
toBeGreaterThanOrEqual
toBeLessThanOrEqual
toHaveBeenCalled
toHaveClass
toMatch
We will learn how to use these matchers in the next few sections. OK, we have written our
test specs, so now what? How do we run them? What will run them for us? The
answers can be found in the next section.
About the Karma framework
Karma is a test-runner framework for executing test scripts on a server and generating the
reports.
The following is taken from the official website:
"Karma is essentially a tool which spawns a web server that executes source code against
test code for each of the browsers connected. The results of each test against each browser
are examined and displayed via the command line to the developer such that they can see
which browsers and tests passed or failed."
The Karma framework gets added in our list of dependencies as it is included in the
Angular CLI installation. Before we proceed to write and execute our test scripts, it's good
practice to verify whether we have installed both Jasmine and Karma correctly in our
package.json file. We can also verify the version numbers of the libraries that are being
used.
I bet you figured out that this is also the place to specify any particular version of Jasmine
and Karma you want to use.
Unit Testing Chapter 13
[ 362 ]
In the following screenshot, we can verify that we have added Jasmine and Karma to our
list of devDependencies in our package.json file:
Great. Now, it's time to dig deep into Angular testing concepts and write some test scripts.
Angular test automation
I am sure you will agree with me that test automation is one of the most important aspects
of product development. In the preceding sections, we explored Jasmine and Karma
frameworks. In the sections to follow, we will work through some hands-on examples of
how we can automate various Angular framework building blocks. We will learn how to
test Angular components, directives, routing and much more. Let's jump right in.
Testing Angular components
Over the course of using the Angular CLI, we have generated multiple components and
services. Take a pause and review the files and folder structure. You will notice that, for
each component and service, a .spec.ts file has been generated.
Unit Testing Chapter 13
[ 363 ]
Eureka moment! The Angular CLI has been generating the required shell test scripts for the
respective components and services. Let's do a quick hands-on exercise here. Let's generate
a component named auto-list:
ng g component auto-list
The Angular CLI autogenerates the required files and also makes entries in the required
files (AppModule, Angular.json and so on).
The following screenshot depicts the test specs generated by the CLI:
Take a closer look at the files that were generated. You will see the following files generated
for the component:
auto-list.component.html
auto-list.component.spec.ts
auto-list.component.ts
auto-list.component.scss
Unit Testing Chapter 13
[ 364 ]
We are interested in the spec file generated by the Angular CLI. A spec file is the test script
that was generated for the corresponding component. The spec file will have the basic
required modules imported, along with the Component class. The spec file will also have
some basic test specs already written, which can be used as a starting point or,
alternatively, as our motivation.
Let's take a closer look at the code generated in the spec file:
import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { AutoListComponent } from './auto-list.component';
In the preceding code, you will notice that the required modules are imported from the
Angular testing core. This is certainly not the final list of modules we will work with but
just basic starter ones. You will also notice that the newly created component,
AutoListComponent, is also imported into our spec file, which means that we can create
an instance of our class inside the spec file and start mocking the objects for testing
purposes. Pretty cool? Moving on to the lines of code, we can see the following:
describe('AutoListComponent', () => {
let component: AutoListComponent;
let fixture: ComponentFixture<AutoListComponent>;
beforeEach(async(() => {
TestBed.configureTestingModule({
declarations: [ AutoListComponent]
})
.compileComponents();
}));
beforeEach(() => {
fixture = TestBed.createComponent(AutoListComponent);
component = fixture.componentInstance;
fixture.detectChanges();
});
In the preceding code, you will notice some key points. There is a describe statement,
which is used for grouping related test specs together. We will create test specs inside the
describe function. There are two beforeEach methods defined in the spec file.
The 1st beforeEach method is an async promise, which will set up our TestBed, which
means everything declared in it has to be resolved before moving on; otherwise, our tests
won't work. The 2nd beforeEach method will create an instance of our AutoList
component for testing. You will notice the call to fixture.detectChanges(), which
forces Angular's change detection to run and affect the elements in the test beforehand.
Unit Testing Chapter 13
[ 365 ]
Now, it's time to understand the actual test spec, which is generated in the spec file:
it('should create', () => {
expect(component).toBeTruthy();
});
As we mentioned earlier, the Jasmine test specs are written inside the it statement, which,
in this case, is just a simple assert to check whether the component exists and is true, using
the toBeTruthy matcher.
That's all about our spec file. The joy lies in seeing it work. Let's just run the default tests
that Angular has generated for us. To run the tests written inside the Angular application,
we use the ng test command on the command-line interface:
ng test
If you see a new window being opened, don't panic. You will notice that a new browser
window is opened by the Karma runner to execute the tests and the test execution report is
generated. The following screenshot displays the report that was generated for our test spec
for the component:
Unit Testing Chapter 13
[ 366 ]
So, our test passed. Now, let's modify the script a bit. We will create a variable called title
in our component and assign a value. In our test spec, we will verify whether the value
matches or not. It's a straightforward use case and, trust me, it's also the most frequent use
case you will implement in your applications. Let's open the app.component.spec.ts file
and make the changes in the test script:
it(`should have as title 'testing-app'`, () => {
const fixture = TestBed.createComponent(AppComponent);
const app = fixture.debugElement.componentInstance;
expect(app.title).toEqual('AutoStop');
});
In the preceding code, we are writing a test spec and, using TestBed, we are creating a
fixture element of AppComponent. Using the fixture element's debugElement interface, we
are getting the componentInstance property. Next, we are writing an expect statement
to assert if the value of the title variable is equal to AutoStop. That was neat. Let's try
and write one more test spec. The use case we will address is as follows: we have an H1
element and we want to assert it if the value inside the H1 tag is equal to Welcome to
Autostop. The following is the relevant sample code:
it('should render title in a h1 tag', () => {
const fixture = TestBed.createComponent(AppComponent);
fixture.detectChanges();
const compiled = fixture.debugElement.nativeElement;
expect(compiled.querySelector('h1').textContent).toContain('Welcome to
AutoStop');
});
In the preceding code, we are asserting if the textContent of the h1 element contains the
text Welcome to AutoStop. Notice that, in previous test specs, we used
the componentInstance interface and that, in this test spec, we are using
the nativeElement property. Again, run the tests using the ng test command. The
following screenshot shows the test report that was generated:
Unit Testing Chapter 13
[ 367 ]
So far, we have had an overview of the Jasmine and Karma frameworks and also learned
how to run our test scripts. We also learned about the default spec files that Angular
generates for us and learned how to modify the test specs.
In the upcoming sections, we will learn how to write test specs and scripts to test Angular
built-in directives, services, routes and much more.
Testing directives
Angular provides a lot of built-in powerful directives, such as ngFor, ngIf and so on,
which can be used to extend the behavior and functionality of the native HTML elements.
We learned about the Angular templates and directives in Chapter 7, Templates, Directives,
and Pipes. A quick recap has never hurt anyone. Angular offers us two types of directives
that we can use to develop and extend the behavior of elements:
Built-in directives
Custom-defined directives
Unit Testing Chapter 13
[ 368 ]
The focus of this section is to learn how to write test scripts for built-in Angular directives,
such as ngIf, ngFor, ngSwitch and ngModel. Before we start writing our test scripts, we
need to do some groundwork to update our component so that we can start writing the test
use cases. We will write a few variables, which will hold various types of data. We will
display the data in our template using ngFor and also write some conditional checks using
ngIf.
If you want a quick revision of Angular templates and directives, refer
to Chapter 7, Templates, Directives and Pipes.
We will continue to use the same component, AutoListComponent, which we created in
the previous section. Let's start the party. Our starting point will be
the AutoListComponent class, so let's modify the auto-list.component.ts file:
import { Component, OnInit } from '@angular/core';
@Component({
selector: 'app-auto-list',
templateUrl: './auto-list.component.html',
styleUrls: ['./auto-list.component.scss']
})
export class AutoListComponent implements OnInit {
cars = [
{ 'id': '1', 'name': 'BMW' },
{ 'id': '2', 'name': 'Force Motors' },
{ 'id': '3', 'name': 'Audi' }
];
tab = "1";
constructor() { }
ngOnInit() {
}
findAuto() {
console.log("Method findAuto has been called");
}
}
Unit Testing Chapter 13
[ 369 ]
In the preceding code, we are adding a variable of a JSON object type called cars and
assigning data to it. We will use this data by displaying it in the template. We are also
declaring a variable, tab and assigning a value, 1. We will use the tab variable for
conditional checks in the template. Finally, we are adding a method, findAuto and just
displaying the output in the console.
We have modified our component class. We will also need to update our template file in
order to process the data inside the component. The following is the sample code that we
will add in our template file, auto-list.component.html:
<h4 class="c2">ngFor directive</h4>
<ul class="cars-list">
<li *ngFor="let car of cars">
<a [routerLink]="[car.id]">{{ car.name }}</a>
</li>
</ul>
<h4 class="c1">ngIf directive</h4>
<div *ngIf="cars.length" id="carLength">
<p>You have {{cars.length}} vehicles</p>
</div>
<h4 class="c3">ngSwitch directive</h4>
<div [ngSwitch]="tab" class="data-tab">
<p>This is ngSwitch example</p>
<div *ngSwitchCase="1">ngSwitch Case 1</div>
<div *ngSwitchCase="2">ngSwitch Case 2</div>
</div>
<hr>
<button (click)="findAuto()" id="btn">Click to findAutoDealers</button>
In the preceding code, we are making the changes to the template file. 1st, we are using
the ngFor directive to loop the rows and display the cars. Next, we are adding
an ngIf condition to check whether the length of the car is more than 0 and then we will
display the count of the carLength element. We have added an ngSwitch directive to
check whether the value of the tab variable is set and, based on the value of the tab, we
will display the respective tab, accordingly. In our case, since the value assigned to the tab
is 1, we will display the 1st tab. Finally, we have added a button and associated
the findAuto method with the click event.
Unit Testing Chapter 13
[ 370 ]
Beautiful. Our component and template are ready and now it's time to write some good
test scripts to test the preceding logic and, especially, the Angular built-in directives. Some
of the use cases we will test include testing the count of cars displayed in the UI, testing
which tab is active, verifying the content inside an element and many more. Some of the
use cases follow and we will learn how to write test scripts for the use cases:
Use case #1: We have a list of cars and we want to verify that the total count is 3:
// ngFor test case to test the count is 4
it('Should have 3 Brands coming from ngFor directive', async(() => {
const fixture = TestBed.createComponent(AutoListComponent);
fixture.detectChanges();
const el = fixture.debugElement.queryAll(By.css('.cars-list > li'));
expect(el.length).toBe(3);
}));
In the preceding code, we are creating a fixture of the AutoListComponent component.
We have already learned how to target an element using debugElement and, in this test
spec, we are using the queryAll method to get the list of elements with className
.cars-list > li. Finally, we are writing an expect statement to assert if the total count
equals 3.
Run the tests using the ng test command. We should see the following output:
Unit Testing Chapter 13
[ 371 ]
Use case #2: We want to verify that the text inside an HTML element contains
the vehicles keyboard:
// ngIf test script
it('Test ngIf directive in component', async(() => {
const fixture = TestBed.createComponent(AutoListComponent);
fixture.detectChanges();
const compiled = fixture.debugElement.nativeElement;
const el = compiled.querySelector('#carLength');
fixture.detectChanges();
const content = el.textContent;
expect(content).toContain('vehicles', 'vehicles');
}));
There are some important things to note in the preceding code. We continue to use the
same fixture element of the component, AutoListComponent. This time, using the
debugElement interface, we are using the querySelector method to find an element that
has its identifier as carLength. Finally, we are writing an expect statement to assert if the
text content contains the vehicles keyword.
Let's run the tests again using the ng test command. We should see the following output:
Unit Testing Chapter 13
[ 372 ]
Use case #3: We want to use ngSwitch to verify that tab1 is selected and, if so, display the
corresponding div:
// ngSwitch test script
it('Test ngSwitch directive in component', async(() => {
const fixture = TestBed.createComponent(AutoListComponent);
fixture.detectChanges();
const compiled = fixture.debugElement.nativeElement;
const el = compiled.querySelector('.data-tab > div');
const content = el.textContent;
expect(content).toContain('ngSwitch Case 1');
}));
In the preceding code, we continue to use the fixture element of the AutoListComponent
component. Using the debugElement and querySelector methods, we are targeting the
element using className '.data-tab > div'. We are asserting whether
the ngSwitch condition is true and the corresponding div is displayed. Since we have set
the value of the tab to 1 in our component, tab1 is displayed on the screen and the test spec
passes:
Use case #4: Test the methods defined inside AutoListComponent and assert whether the
method has been called:
// Test button is clicked
it('should test the custom directive', async(() => {
Unit Testing Chapter 13
[ 373 ]
const fixture = TestBed.createComponent(AutoListComponent);
component = fixture.componentInstance;
fixture.detectChanges();
spyOn(component, 'findAuto');
component.findAuto();
expect(component.findAuto).toHaveBeenCalled();
}));
In the preceding code, we are creating a fixture of the AutoListComponent
component. We are using the spyOn method to spy on the component instance. We are
calling the findAuto() method. Finally, we are writing an expect statement to assert
whether the findAuto method, using toHaveBeenCalled, has been called or not.
Run the tests using the ng test command. We should see the following output:
In this section, we learned how to write unit test scripts for testing Angular built-in
directives, such as ngFor, ngIf, ngSwitch and finally, asserting whether a method was
clicked and called.
In the next section, we will learn about testing Angular routing.
Unit Testing Chapter 13
[ 374 ]
Testing Angular routing
Most likely, you will have multiple links throughout the application in the form of a
navigation menu or deep links. These links are treated as routes in Angular and are usually
defined in your app-routing.module.ts file.
We learned about and mastered how to use Angular routing in Chapter 4, Routing. In this
section, we will learn how to write test scripts for testing Angular routing and testing the
links and navigation in our application.
We will need a beautiful menu component for our application. Using the ng generate
component menu command, we will generate the menu component. Now, let's navigate to
menu.component.html and create a menu called navbar with two links in it:
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="#">AutoStop </a>
<button class="navbar-toggler" type="button" data-toggle="collapse"
data-target="#navbarSupportedContent" ariacontrols="
navbarSupportedContent"
aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item active">
<a class="nav-link" routerLink="/list-cars">Cars <span class="sr-only">
(current)</span></a>
</li>
<li class="nav-item">
<a class="nav-link" routerLink="/list-trucks">Trucks</a>
</li>
</ul>
</div>
</nav>
The preceding code is nothing fancy, at least not yet. It is standard code that uses Bootstrap
to generate a navbar component. Look carefully and you will see that we have defined two
links in the menu bar, list-cars and list-trucks, with the classes as nav-link.
Unit Testing Chapter 13
[ 375 ]
We can now write a few test specs around the menu functionality to test the navbar
component, which will cover navigation, the count of links and so on.
Use case #1: We need to test that the navbar menu has exactly two links.
Here's the code to check whether there are exactly two links:
// Check the app has 2 links
it('should check routerlink', () => {
const fixture = TestBed.createComponent(MenuComponent);
fixture.detectChanges();
const compiled = fixture.debugElement.nativeElement;
let linkDes = fixture.debugElement.queryAll(By.css('.nav-link'));
expect(linkDes.length).toBe(2);
});
In the preceding code, we are creating a fixture for our MenuComponent component. Since
we have assigned the nav-link class, it's easy to target the corresponding links in the
component. Using the debugElement and queryAll methods, we are finding all the links
with className as nav-link. Finally, we are writing an expect statement to assert
whether the length of the array of links returned is equal to 2.
Run the tests using the ng test command. We should see the following output:
Unit Testing Chapter 13
[ 376 ]
That's a good start to testing our menu functionality. Now that we know there are two links
in our menu, the next use case we want to test is whether the 1st link is list-cars.
The following is the code to test whether the 1st link in the array of links is list-cars:
// Check the app has 1st link as "List Cars"
it('should check that the 1st link is list-cars ', () => {
const fixture = TestBed.createComponent(MenuComponent);
fixture.detectChanges();
const compiled = fixture.debugElement.nativeElement;
let linkDes = fixture.debugElement.queryAll(By.css('.nav-link'));
expect(linkDes[0].properties.href).toBe('/list-cars', '1st link should
go to Dashboard');
});
In the preceding code, we are creating a fixture for our MenuComponent component. Using
the debugElement and queryAll methods, we are finding all the links with className as
nav-link. We will be getting all the links that have the class name as nav-link. There can
be multiple links in the menu, but we are interested in reading the href property of the
1st element through index [0] and asserting whether the value matches /list-cars.
Again, run the ng test command. We should see our test report updated, as shown in the
following screenshot:
Unit Testing Chapter 13
[ 377 ]
OK, fair enough. We got a clue that the list-cars menu link is the 1st in the menu
list. What if we don't know the index or position of the link we are searching for? Let's
tackle that use case as well.
Take a look at the following code snippet:
// Check the app if "List Cars" link exist
it('should have a link to /list-cars', () => {
const fixture = TestBed.createComponent(AppComponent);
fixture.detectChanges();
const compiled = fixture.debugElement.nativeElement;
let linkDes = fixture.debugElement.queryAll(By.css('.nav-link'));
const index = linkDes.findIndex(de => {
return de.properties['href'] === '/list-cars';
});
expect(index).toBeGreaterThan(-1);
});
Some things to note are that we are finding the index of the route path, /list-cars, and
we are also making use of the assigned classes, nav-link and getting an array of all
matching elements using the queryAll method. Using the findIndex method, we are
looping the array elements to find the index of the matching href to /list-cars.
Run the tests again using the ng test command and the updated test report should look
as follows:
Unit Testing Chapter 13
[ 378 ]
In this section, we learned about various ways to target a router link. The same principle
applies to hunting down a deep link or a child link.
That's your homework.
Testing dependency injection
In the previous sections, we learned how to write test scripts for testing Angular
components and routing. In this section, we will learn how to test dependency injection and
how to test services in Angular applications. We will also learn how to inject services into
Angular components and write test scripts to test them.
What is dependency injection?
Dependency injection (DI), in the Angular framework, is an important design pattern that
allows the flexibility to inject services, interfaces and objects into a class at runtime.
The DI pattern helps with writing efficient, flexible and maintainable code that is testable
and easy to extend.
If you need a quick recap, head over to Chapter 11, Dependency Injection
and Services, which covers and explains the DI mechanism in depth.
Testing Angular services
In this section, we will learn how to test Angular dependency injection through services
and interfaces. In order to test an Angular service, we will 1st need to create a service in
our app!
Use the ng generate command in the Angular CLI; we will generate the service in the
project folder:
ng generate service services/dealers
Upon successful execution, we should see that the following files have been created:
services/dealers.service.spec.ts
services/dealers.service.ts
Unit Testing Chapter 13
[ 379 ]
Now that we have our dealers service and the corresponding test spec file generated, we
will work on our service to add a few methods and variables, so we will use them in our
test specs. Navigate to our service class and update the dealers.service.ts file. The
updated code should look as follows:
import { Injectable } from '@angular/core';
@Injectable({
providedIn: 'root'
})
export class DealersService {
dealers: any;
constructor(private http : HttpClient) { }
getDealers(){
this.dealers = [
{ id: 1, name: 'North Auto'},
{ id: 2, name: 'South Auto'},
{ id: 3, name: 'East Auto'},
{ id: 4, name: 'West Auto'},
];
return this.dealers;
}
}
Unit Testing Chapter 13
[ 380 ]
In the preceding code, we are making simple changes so that we can write a few test specs
around the dealers service. We have defined a variable of the any type. We are defining a
getDealers method, which will return a JSON response with an id and name key pair.
Alright, now let's come up with some use cases to write our test scripts, such as getting the
count of dealers, finding a matching dealer and so on.
Use case #1: When the getDealers method is called, it should return the list of dealers,
and the count should be equal to 4.
The following is the test spec for this:
it('Test Dependency Injection to get 4 dealers', () => {
const service: DealersService = TestBed.get(DealersService);
let dealers = service.getDealers();
expect(dealers.length).toBe(4);
});
Use case #2: We want to check whether the 1st dealer name is North Auto.
The following is the test spec for this:
it('Test if the 1st Dealer is North Auto', () => {
const service: DealersService = TestBed.get(DealersService);
let dealers = service.getDealers();
expect(dealers[0].name).toBe('North Auto');
});
Amazing! So far, so good. So, we have learned how to write test specs for our newly created
dealers service. That's only one part of dependency injection. As part of dependency
injection, we may need to inject additional required classes at runtime into the service.
Let's quickly create a class called Dealers and define two variables in it, namely username
and name. Now, let's save this file as dealers.ts:
export class Dealers {
constructor(
public username: string = '',
public name: string = ''
) {};
}
Unit Testing Chapter 13
[ 381 ]
We will now include the newly created class in our dealers service and create a method to
initialize the class and create an object to return some data:
getDealerObject()
{
this.dealerObj= new Dealers('World','Auto');
return this.dealerObj;
}
That brings us to our next use case to test.
Use case #3: Testing dependency injection via classes that have been injected into a service.
Have a look at the following code:
it('Test if the dealer returned from object is World Auto', () => {
const service: DealersService = TestBed.get(DealersService);
let dealerObj = service.getDealerObject();
expect(dealerObj.name).toBe('Auto');
});
In the preceding code, we have created an instance of our service and invoked the
getDealerObject() method. We are asserting whether the value returned matches
the name property of the response to Auto.
We are calling the method defined in a service, which, internally, is dependent on
the Dealers class.
Use case #4: What if we want to test just the properties of the Dealers class?
We can test that, too. The following is the sample code for this:
it('should return the correct properties', () => {
var dealer = new Dealers();
dealer.username = 'NorthWest';
dealer.name = 'Auto';
expect(dealer.username).toBe('NorthWest');
expect(dealer.name).toBe('Auto');
});
Unit Testing Chapter 13
[ 382 ]
Now, let's run the ng test command. We should see the following output:
On the same lines, you can write test scripts to test your services, dependency classes, or
interface classes.
Use case #5: Testing Angular services inside a component.
We will continue to test Angular dependency injection. This time, we will import our
services into the component and verify that it's working as expected.
In order to implement this use case, we will need to make changes to AutoListComponent.
Unit Testing Chapter 13
[ 383 ]
Take a look at the changes we will make in the auto-list.component.ts file:
import { DealersService } from '../services/dealers.service';
constructor(private _dealersService : DealersService) { }
findAuto() {
this.dealers = this._dealersService.getDealers();
return this.dealers;
}
In the preceding code, we are importing the dealers service into the component. We are
creating an instance of the service in the constructor method. We added a
findAuto method, which calls the getDealers method using the instance of the class
_dealersService service. In order to test the service in our component, let's modify the
auto-list.component.spec.ts file by adding the following code:
import { DealersService } from '../services/dealers.service';
beforeEach(() => {
fixture = TestBed.createComponent(AutoListComponent);
component = fixture.componentInstance;
fixture.detectChanges();
service = TestBed.get(DealersService);
});
In the preceding code, we have imported our service dealers into the test spec file of
AutoListComponent. We are creating an instance of the service using TestBed in
the beforeEach method. We are now good to start writing our test specs in order to test
the service. Add the following code to auto-list.component.spec.ts:
it('should click a button and call method findAuto', async(() => {
const fixture = TestBed.createComponent(AutoListComponent);
component = fixture.componentInstance;
fixture.detectChanges();
spyOn(component, 'findAuto');
let dealers = component.findAuto();
expect(dealers.length).toEqual(4);
}));
In the preceding code, using the instance of the component, we are calling the findAuto
method, which will return the data from the service. It expects the count to be equal to 4.
Unit Testing Chapter 13
[ 384 ]
Run the tests using the ng test command. We should see the following output:
In this section, we learned about various techniques to test Angular dependency injection,
including services, dependency classes and testing services inside Angular components.
Testing HTTP
In Chapter 12, Integrating Backend Data Services, we learned about integrating backend
services and also learned about HTTPModule and HTTPClient. We also learned how to
make HTTP requests to the server and process the responses.
In this section, we will learn how to write test scripts to test HTTP requests and responses.
We will continue to use the same project we created in this chapter-the AutoStop project.
Before we proceed further, it's important to have the REST API endpoints ready so that we
can use them in our application.
Unit Testing Chapter 13
[ 385 ]
We will learn how to use the public API, https://jsonplaceholder.typicode.com/,
which is available on the internet for free. We will also create a local server to return a
mock JSON response from a local static JSON file.
We must import HttpClientModule and HttpClientTestingModule
into our app.module.ts file.
Before we proceed to write our test scripts for testing Angular HTTP, we will need to
update our dealers service, which we have used throughout this chapter. We will
implement a few methods that will make HTTP calls-POST/GET to process data to the
REST API endpoints.
We are working on the dealers.service.ts file, as follows:
import { HttpClient } from '@angular/common/http';
import { HttpHeaders, HttpParams, HttpErrorResponse } from
'@angular/common/http';
readonly REST_ENDPOINT = 'https://jsonplaceholder.typicode.com/users';
readonly DEALER_REST_ENDPOINT =
'https://jsonplaceholder.typicode.com/users/1';
private _carurl = 'http://localhost:3000/cars';
In the preceding code, we are importing the required HTTP modules; that is, HttpClient,
HttpHeaders, HttpParams and HttpErrorResponse and also defining two REST
endpoints that have the API URL for users and a specific user.
We can also have a local server up and running. You can have local APIs
using the JSON server. You can learn more about this at https://github.
com/ typicode/ json- server.
It's time to add a few methods, through which we will make the HTTP calls to the REST
endpoints:
getAllDealers()
{
this.allDealers = this.http.get(this.REST_ENDPOINT,
{
headers: new HttpHeaders().set('Accept', 'aplication/json')
});
return this.allDealers;
}
getDealerById(){
Unit Testing Chapter 13
[ 386 ]
let params = new HttpParams().set('id', '1');
this.dealerDetails = this.http.get(this.REST_ENDPOINT, {params});
return this.dealerDetails;
}
In the preceding code, we are creating two methods, which make an HTTP GET request.
The 1st method, getAllDealers, makes a call and expects a JSON response of users. The
2nd method, getDealerById, will pass id as 1 and expect a single user data response.
In the getDealerById method, we are using HttpParams to set the parameters to send to
the endpoint. We will also modify our autoListComponent component to add a few
methods to our Component class.
We are adding the following code to our auto-list.component.ts file:
findAuto() {
this.dealers = this._dealersService.getDealers();
return this.dealers;
}
listAllDealers(){
this.allDealers = this._dealersService.getAllDealers();
}
listDealerById(){
this.showDealerInfo = true;
this.dealerDetail = this._dealersService.getDealerById();
return this.dealerDetail;
}
getCarList() {
this.carList = this.http.get<Cars[]>(this._carurl);
}
In the preceding code, we are adding a few methods, namely findAuto, listDealerById,
and getCarList, which are making HTTP calls and calling methods that are in the dealers
service.
Alright, now that we have our component and services set up, which are making HTTP
calls, we are good to write our tests for HTTP.
Unit Testing Chapter 13
[ 387 ]
Use case #1: We want to test whether a GET call was made to a particular URL.
We will add the following code to the auto-list.component.spec.ts file:
// Test HTTP Request From Component
it('Test HTTP Request Method', async(() => {
const fixture = TestBed.createComponent(AutoListComponent);
component = fixture.componentInstance;
httpMock = TestBed.get(HttpTestingController);
let carList = component.getCarList();
fixture.detectChanges();
const req = httpMock.expectOne('http://localhost:3000/cars');
expect(req.request.method).toBe('GET');
req.flush({});
}));
In the preceding code, we are creating the instance of AutoListComponent, using which
we will make a call to its getCarList method. In the getCarList method, we are making
a call to the http://localhost:3000/cars URL to retrieve data. We are creating an
instance of the HttpTestingController class named httpMock. Using
the httpMock instance, we are asserting that at least one call should be made to the URL.
Use case #2: We want to expect that the data returned as the result is more than 1:
it('Test HTTP Request GET Method With subscribe', async(() => {
const fixture = TestBed.createComponent(AutoListComponent);
component = fixture.componentInstance;
component.listDealerById().subscribe(result =>
expect(result.length).toBeGreaterThan(0));
}));
In the preceding code, using the instance of AutoListComponent, we are calling the
listDealerById method. Using subscribe, we are mapping the result and verifying that
the result data length is greater than 0.
Unit Testing Chapter 13
[ 388 ]
Use case #3: We want to verify that the data returned from the HTTP call matches the
data. The following is the sample code for this use case scenario.
it('Test if the 1st Dealer is North Auto', () => {
const service: DealersService = TestBed.get(DealersService);
let dealers = service.getDealers();
expect(dealers[0].name).toBe('North Auto');
});
In the preceding code, using the DealersService instance, we are making a call to
the getDealers methods. We are asserting data of the 1st index property name to be
North Auto.
Run the tests using the ng test command. We should see the following output, as
displayed and highlighted in the following screenshot:
Unit Testing Chapter 13
[ 389 ]
If you see the preceding output, that's brilliant.
In this section, we have learned how to test components, services and methods that are
making HTTP request calls.
Summary
Testing is an important aspect of the application life cycle and writing test scripts is crucial
for application development success. We started with an overview of the frameworks
supported by Angular, namely Jasmine and Karma. We learned how to run our tests using
the ng test command. Then, we learned how to use the spec files autogenerated by
Angular for all the components and services.
We learned how to write test scripts to test Angular components, built-in directives,
services and routing. We wrote test scripts for built-in directives, such as ngFor, ngIf,
ngSwitch and ngModel. We also covered use cases for testing Angular routing. Then, we
created a menu component and wrote test scripts to test various use cases for the menu
component.
We also explored testing dependency injection and services. We learned about various use
cases and wrote test scripts for Angular services and HTTP calls.
In the next chapter, we will explore advanced Angular topics, such as custom directives
and custom form validations.
Read on!
14 Advanced Angular Topics
In previous chapters, we learned how to use directives and form validators. We will extend
our knowledge in this chapter with custom directives and custom validators. We're also
going to look at how to build single-page applications (SPAs) with Angular.
Additionally, we'll explore integrating authentication into our Angular applications with
two popular authentication providers: Google Firebase Authentication and Auth0.
This chapter will cover the following topics:
Custom directives
Custom form validators
Building SPAs
User authentication
Authentication with Firebase Authentication
Authentication with Auth0
Wiring up the client side
Custom directives
In this section, we will learn how to create custom directives.
1stly, let's understand what an Angular directive is.
Angular directives are a way to extend HTML functionality and the behavior of elements.
In previous chapters, we learned about and implemented many built-in directives, such as
*ngIf, *ngFor, *ngSwitch and ngModel.
In this section, we will learn how to create our own custom directive to extend the
functionality of HTML elements.
Advanced Angular Topics Chapter 14
[ 391 ]
Use case: We want to create a custom directive for form elements and onfocus. The
background color should be set to light blue, with the border dark blue and the
onblur event should be highlighted in red. So, let's begin:
1. Let's generate the directive using the ng command:
ng g directive onFocusBlur
On running the previous command, this is what will show up on our screen:
Notice that the directive files have been generated and that our app.module.ts
file has also been updated, which means the directive is available across the app,
to be used anywhere in any component.
2. In the directive file, on-focus-blur.directive.ts, add the following lines of
code:
import { Directive } from '@angular/core';
import { HostListener, HostBinding } from '@angular/core';
@Directive({
selector: '[appOnFocusBlur]'
})
export class OnFocusBlurDirective {
constructor() { }
@HostBinding("style.background-color") backgroundColor;
@HostListener('focus') onFocus() {
this.backgroundColor = '#19ffe4';
}
@HostListener('blur') onBlur() {
Advanced Angular Topics Chapter 14
[ 392 ]
this.backgroundColor = '#ff1934';
}
}
In the preceding code, the following important things should be noted:
We are importing the required modules, that is, Directive, HostListener, and
HostBinding.
Using the @directive decorator, we are defining the name of the directive
through the selector.
@HostBinding is used to set properties on the element.
@HostListener is used to listen to the events on the host element.
We are binding the style background color property in the preceding example.
We can bind any style, class, or event property on the host element.
Using @HostListener, we are listening to the events and, with onFocus, we are
changing the background color. By using onBlur, we reset the color.
Now, we are good to use this decorator anywhere in our application.
3. We are going to use this in our app.component.html file on a form control
input element:
<input type="text" appOnFocusBlur class="nav-search" >
4. Run the app using the ng serve command and click on the Input button. We
should see the output and behavior, as shown in the following screenshot:
Advanced Angular Topics Chapter 14
[ 393 ]
Great. Now that we know how to write our custom directives, we will go ahead and try
creating our own custom directives.
In the next section, we will learn about writing custom form validations.
Custom form validations
In previous chapters, we learned about forms and implementing form validations. We used
the built-in form validations or HTML5 attribute validations. But, in more complex
scenarios, we will need to implement custom form validations. These validations differ
from application to application. In this section, we will learn about custom form
validations. To recap quickly, Angular provides us with various options through which we
can implement form validations using the Validators module in Angular forms.
An example of using validators is shown in the following code:
loginForm = new FormGroup({
1stName: new FormControl('',[Validators.required,
Validators.maxLength(15)]),
lastName: new FormControl('',[Validators.required]),
});
In the preceding code, using the Validators module, we are applying validations of
required, maxLength and so on.
Now, let's learn how to create our own custom form validations. 1st, we will generate a
component in which we will implement a form and a few elements so that we can apply
our newly created directive:
ng g c customFormValidation
Upon running the preceding command successfully, we should see the following output:
Advanced Angular Topics Chapter 14
[ 394 ]
Now that we have generated our component, let's generate a directive in which we will
implement custom form validations.
We will implement a custom directive to check the ISBN field.
What is an ISBN? An ISBN is a unique identifier for each book that is ever published.
Here are the conditions that are required for an ISBN number:
The ISBN number should be exactly 16 characters
Only integers are allowed for ISBNs
Now, using the ng command, we will generate our directive:
ng g directive validISBN
Upon successful execution of the above command we should see the output as shown in
the screenshot below
In the valid-isbn.directive.ts file, add the following lines of code:
import { Directive } from '@angular/core';
import { NG_VALIDATORS, ValidationErrors, Validator, FormControl } from
'@angular/forms';
@Directive({
selector: '[validISBN]',
providers: [
{ provide: NG_VALIDATORS,
useExisting: ValidISBNDirective, multi: true }
]
})
export class ValidISBNDirective implements Validator {
static validateISBN(control: FormControl): ValidationErrors | null {
if (control.value.length < 13) {
return { isbn: 'ISBN number must be 13 digit long' };
}
if (!control.value.startsWith('Packt')) {
return { isbn: 'Value should start with Packt' };
}
Advanced Angular Topics Chapter 14
[ 395 ]
return null;
}
validate(c: FormControl): ValidationErrors | null {
return ValidISBNDirective.validateISBN(c);
}
}
Let's analyze the preceding code snippet in detail. 1st, using the ng CLI commands, we
have generated a directive named validISBN. The Angular CLI will autogenerate the
required file, with the basic syntax prepopulated. We are importing the required modules,
namely NG_VALIDATORS, ValidationErrors, Validator and FormControl. We are
injecting the required modules as part of our providers. Next up, we have implemented a
method named validateISBN, which is taking a parameter of the FormControl type. We
are passing our form control field to this method, which will validate whether the value of
the form control matches the conditions implemented in the method. Finally, we are
invoking the validateISBN method in the method validate.
Now, we are good to use this custom form validation in any number of places, that is,
wherever we need to verify or validate the ISBN number. Let's run the application using
the ng serve command. We should see the following output:
So far in this chapter, we have been applying some of them out of box, thinking and
learning about how to build our custom directives and custom form validations. We have
also learned how easy it is to integrate them into existing, or any new, applications
effortlessly. All this can also form parts of single-page applications. Wait. What? Singlepage
applications? What's that? In the next section, we are going to learn all about singlepage
applications and build our own.
Advanced Angular Topics Chapter 14
[ 396 ]
Building single-page applications
In this section, we will learn about building single-page applications.
What exactly is a single-page application?
A single-page application is a web application or website that interacts with the user by
dynamically rewriting the current page, rather than loading entirely new pages from a
server.
Think of it as an application with only one HTML file and the contents of the page load
dynamically based on the request made by the user. We only create templates that get
rendered in our browser dynamically at runtime.
Let me give you a good example.
In Chapter 15, Deploying Angular Applications, using the ng build command, we
generated the compiled code of an Angular app.
Take a look at the compiled source code that was generated by Angular:
In the preceding screenshot, you will see only one HTML file, named index.
Go ahead and open the file-you will see it's blank. That's because Angular applications are
single-page apps, which means the content and data will be generated on the fly
dynamically based on user actions.
It's safe to say that all Angular applications are single-page applications.
Advanced Angular Topics Chapter 14
[ 397 ]
The following are some of the advantages of building a single-page application:
The pages are rendered dynamically and therefore our application source code is
secure.
As the compiled source code renders in the user's browser, the pages load much
faster than in the traditional request and response model.
Since pages load faster, this leads to a better user experience.
Using the Router component, we only load components and modules that are
needed for certain features and do not load all of the modules and components in
one go.
Throughout the course of this book, we have created many Angular apps and each one of
them has been a single-page application.
User authentication
In this section, we will learn how to implement user authentication in our Angular
applications.
User authentication, in a broad context, consists of safely logging the user into our
application, who should be able to view, edit and create data on secure pages and finally,
log out of the application!
In a real-world application, there will be a lot of additional checks and security
implementations to be done to sanitize user inputs, as well as checking whether they're a
valid user, or verifying the authentication token for session timeouts and other data checks
to make sure no bad elements creep into the app.
The following are some important modules for user authentication:
Signing up new users
Login for existing users
Password reset
Session management for logged-in users
One-time password or dual authentication
Logging out an already logged in user
In the upcoming sections, we will learn about implementing the preceding functionality
using the Firebase and Auth0 frameworks.
Advanced Angular Topics Chapter 14
[ 398 ]
User authentication with Firebase
In this section, we will learn how to implement user authentication using Firebase.
What is Firebase?
Firebase is a managed service provided by Google. Firebase gives us functionality such as
analytics, databases, messaging and crash reporting, so that we can move quickly and
focus on our users. You can learn more about the service at https://firebase. com. Now,
let's jump right in and implement Firebase in our Angular app.
The 1st step is to create an account with Google to use the Firebase service. You can use
your Google account to log in to Firebase. Once you have successfully created your Firebase
account, you should see the following output:
To create a new project, click on the Add Project link.
Advanced Angular Topics Chapter 14
[ 399 ]
You will see the following dialog window, prompting you to enter the project's name; in
our case, we are making our project name AutoStop:
Note that Google will assign a unique project ID to your project.
Now, click on the Authentication link on the left-hand-side menu to set up user
authentication features, which we can embed and set up in our Angular application:
Advanced Angular Topics Chapter 14
[ 400 ]
We can do a lot of other cool stuff here, but we will focus on the Authentication module for
now.
Now, click on the Sign-in method tab to set up options for how to allow users to sign in to
our Angular application:
Advanced Angular Topics Chapter 14
[ 401 ]
In the preceding screenshot, you will notice the following important things:
Google Firebase provides various options that we can enable, through which we
would want users of our application to sign in.
We need to enable each provider option individually .
We have enabled Email/Password and Google options in our application.
In order to enable Facebook, Twitter and other apps, we will need to enter the
developer API keys provided by the respective services.
Now, scroll down a little bit on the page and you will see an option to set up called
Authorised Domains.
We will see two default values set up, that is, localhost and a unique subdomain, on the
Firebase application, as shown in the following screenshot:
We have made the required changes. Now, we need to set up Google Firebase's app
settings. It's time to implement the user authentication in our Angular application.
Prerequisite: We expect users to have an Angular application up and running.
Open the Angular CLI command prompt; we need to install a few modules. We will need
to install Angular Fire2 and Firebase 1st:
Please note that Angular Fire2 is now Angular Fire.
We will need to run the following command to install Angular Fire in our application:
npm install angularfire2
Advanced Angular Topics Chapter 14
[ 402 ]
Upon successful execution of the preceding command, we should see the output shown in
the following screenshot:
All set. Now, we need to create a service that will handle our authentication functionality:
ng g service appAuth
Using the ng command, we are generating a new service, named appAuth:
Now, it's time to modify the appAuth.service.ts file and add the following code to it:
import { Injectable } from '@angular/core';
import { AngularFireAuth } from '@angular/fire/auth';
import { auth } from 'firebase/app';
import { Router } from '@angular/router';
@Injectable({
providedIn: 'root'
})
export class AppAuthService {
private authUser:any;
private authState:any;
private loggedInUser = false;
private userToken ='';
Advanced Angular Topics Chapter 14
[ 403 ]
constructor(public afAuth: AngularFireAuth, private router :Router) { }
login() {
this.afAuth.auth.signInWithPopup(new auth.GoogleAuthProvider());
this.loggedInUser = true;
this.afAuth.currentUser.getIdToken(true).then(token => this.userToken =
token);
this.afAuth.authState.subscribe((auth) => {
this.authState = auth;
});
this.router.navigate(['/profile']);
}
isLoggedInUser(){
if(this.userToken != '')
return true;
else
return false;
}
logout() {
this.afAuth.auth.signOut();
this.loggedInUser = false;
this.userToken = '';
}
}
In the preceding code, we are making changes to the app-auth.service.ts file. The
following important points should be noted:
We are importing the required classes, namely AngularFireAuth, Auth, and
Router, into the service.
Using @Injectable, we are specifying that the service is injected at the root
level in the Angular tree structure.
We are defining a few private variables that we will use across our application.
In the constructor method, we are injecting the AngularFireAuth and Router
classes.
We are defining 3 methods: Login, Logout and isLoggedInUser.
Advanced Angular Topics Chapter 14
[ 404 ]
In the login method, we are using the this.afAuth instance, calling the
signInWithPopup method and passing the auth.GoogleAuthProvider
argument, which we get from the Firebase app that we installed locally:
this.afAuth.auth.signInWithPopup(new auth.GoogleAuthProvider());
When this method is invoked, a new window will open up, in which we can see
the Google sign-in option, using which we can log in to the app.
We are setting the this.loggedInUser variable to true.
We are setting the logged-in user's token to the this.userToken variable.
We are also subscribing to get the authState response.
Finally, using the router instance and using the navigate method, we are
redirecting the user to the profile page.
Inside the isLoggedInUser method, we are verifying whether the userToken is
set or not. userToken will be set if the user has logged in correctly; otherwise,
the method will return false.
In the logout method, again using the instance of afauth, we are calling the
signout method, which will log the user out.
Finally, we are setting the userToken to empty.
Awesome. We have done all the heavy lifting in our app-auth.service.ts file. Now, it's
time to call these methods in our components: login, profile and log out.
In the login.component.html file, we will add the following login form:
<div *ngIf="!_appAuthService.loggedInUser">
<form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
<label>
1st Name:
<input type="text" formControlName="1stName">
</label>
<label>
Last Name:
<input type="text" formControlName="lastName">
</label>
<button>Login</button>
</form>
</div>
Advanced Angular Topics Chapter 14
[ 405 ]
In the preceding code, we are just adding an Angular reactive login form using FormGroup
and FormControllers.
The output of the login form is shown in the following screenshot:
And in the profile.component.ts file, we are just making a call to the login method:
onSubmit(){
this._appAuthService.login();
console.warn(this.loginForm.value);
}
Now, in the profile.component.ts file, we add a check to see whether the user is logged
in or not:
<div *ngIf="_appAuthService.isLoggedInUser">
<p>
profile works!
</p>
User Token is {{_appAuthService.userToken}}
</div>
Advanced Angular Topics Chapter 14
[ 406 ]
When the user navigates to the profile page, if they are logged in, they will see the details;
otherwise, the user will be redirected to the login page.
Now, on to the final part; we will have a logout link in our app.component.html file:
<nav>
<a routerLink='/login' *ngIf="!_appAuthService.isLoggedInUser()">Login</a>
<a routerLink='/register'>Register</a>
<a routerLink='/logout'
*ngIf="_appAuthService.isLoggedInUser()">Logout</a>
</nav>
We are adding links with *ngIf conditions to show the corresponding links when the user
is logged in or not:
ngOnInit() {
this._appAuthService.logout();
this.router.navigate(['/login']);
}
When the user clicks on the logout link, we are calling the logout method of
appAuthService and, on successful logout, we are redirecting the user back to the login
page.
Now, let's run the app using the ng serve command. We should see the following output:
Advanced Angular Topics Chapter 14
[ 407 ]
User authentication with Auth0
In this section, we will learn how to implement user authentication using Auth0. Before we
go ahead and implement Auth0 in our Angular application, we will need to implement
some prerequisites. Let's get right to it:
1. 1st, we will need to create an account with Auth0 at Auth0.com. Upon
successfully logging in to the account, we should see the following dashboard
screen:
We will have to register our application so that we can create the required settings
to implement Auth0 in our app.
2. Click on the Applications link on the left-hand-side menu:
Advanced Angular Topics Chapter 14
[ 408 ]
3. Now, click on the Create Application button to create an application:
Advanced Angular Topics Chapter 14
[ 409 ]
4. We will need to enter the name of the application and select the type of
application we are building. In our case, it's a Single Page Web App, so go ahead
and select the option and click on the CREATE button.
5. The next thing we need to do is update the important settings of our application.
So, click on the application name and navigate to the Settings tab:
The following are some important things to keep in mind:
We need to update the Allowed Callback URLs, Allowed Web Origins, and
Allowed Origins (CORS).
If we do update the details for Allowed Web Origins and Allowed Origins, we
will get a cross-origin request (CORS) error.
We have adjusted the required settings in Auth0, so we are good to implement Auth0 in
our application now.
Advanced Angular Topics Chapter 14
[ 410 ]
In order to implement Auth0 in our application, we will need to install a few modules,
namely auth0-js, auth0-lock and angular2-jwt:
In the preceding screenshot, using the npm install command, we installed the required
Auth0 modules. Now, it's time to generate the services and components for our application.
1st, we will need to generate our service; let's call it authService. We need to run the
following command to generate our service:
ng g service services/auth
Upon successful execution of the preceding command, we should see the following
output:
We can verify and confirm that our service has been generated, along with the spec file (the
file used to write our test specifications). Now that we have created our service, it's time to
generate the components. We will run the following commands using the ng CLI in order
to generate the required components:
ng g c login
ng g c profile
Advanced Angular Topics Chapter 14
[ 411 ]
Upon successful execution of the preceding commands, we should see the following
output:
In the preceding screenshot, we can verify and confirm that our required components,
namely login and profile, have been generated successfully. Now, we are good to go
ahead with implementing the functionality for our components.
To make our application beautiful, let's install the bootstrap CSS framework as well:
npm i bootstrap
We will also need to install the jquery module:
npm i jquery
Upon successful execution of the preceding command, we should see the following output:
Advanced Angular Topics Chapter 14
[ 412 ]
Super cool. Now, it's time to add a few links in the Nav component:
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="#">Auth0</a>
<button class="navbar-toggler" type="button"
data-toggle="collapse" data-target="#navbarSupportedContent"
aria-controls="navbarSupportedContent" aria-expanded="false"
aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item active">
<a class="nav-link" href="#">Home
<span class="sr-only">(current)</span></a>
</li>
<li class="nav-item">
<a class="nav-link" *ngIf="!authService.isLoggedIn();"
(click)="authService.login()">Login</a>
</li>
<li class="nav-item">
<a class="nav-link" *ngIf="authService.isLoggedIn();" >Profile</a>
</li>
<li class="nav-item">
<a class="nav-link" *ngIf="!authService.isLoggedIn();"
href="#">Register</a>
</li>
<li class="nav-item">
<a class="nav-link" *ngIf="authService.isLoggedIn()"
(click)="authService.logout()">Logout</a>
</li>
</ul>
</div>
</nav>
In the preceding code, the following important points should be noted:
We are using the nav component of Bootstrap.
We are adding a few links and attaching a click event, such as login and logout
depending on the state of the user. If the user is logged in we will display logout
link, else we will display register link
We will implement these methods in our nav.component.ts file.
We are using *ngIf to check whether the user is logged in and toggle the login
and logout links accordingly
Advanced Angular Topics Chapter 14
[ 413 ]
The output of the preceding code is shown in the following screenshot:
We will now need to work on the auth service that we have generated. In the
services/auth.service.ts file, we need to import the required modules 1st and then
add our methods, login and logout:
import { tokenNotExpired } from 'angular-jwt';
import { Auth0Lock} from 'auth0-lock';
Once we have imported the Auth0Lock and TokenNotExpired classes, we will create
instances so that we can use them.
Take a look at the basic Auth0Lock object instance creation code:
var lock = new Auth0Lock(
'YOUR_CLIENT_ID',
'YOUR_AUTH0_DOMAIN'
);
In order to create a new object of the Lock class, we will need to pass the client ID and
domain name to the instance.
Let's implement this in our auth.service.ts file:
public _idToken: string;
private _accessToken: string;
private _expiresAt: number;
lock = new
Auth0Lock('XvVLuuMQr3kKAR3ECAmBZOiPPyVYehvU','srinix.auth0.com',{
allowedConnections: ["Username-Password-Authentication","google-oauth2"],
rememberLastLogin: false,
socialButtonStyle: "big",
languageDictionary: {"title":"Auth0"},
language: "en",
responseType: 'token id_token',
theme: {}
});
Advanced Angular Topics Chapter 14
[ 414 ]
In the preceding code, the following important points should be noted:
We are creating 3 variables, namely _idToken, _accessToken, and
_expiresAt.
We are creating an instance of Auth0Lock and we need to pass params to the
object.
The Auth0Lock object will require two mandatory params to be passed. The 1st
param is ClientId and the 2nd is the domain name.
The 3rd param includes options such as allowedConnections, theme and so
on, as it says they are optional.
Client Id and Domain can be obtained from the Auth0 app settings, as shown in
the following screenshot:
We can now listen to events attached to the lock object:
constructor(private router: Router) {
this.lock.on('authenticated', (authResult: any) => {
localStorage.setItem("userToken", authResult.accessToken);
this.router.navigate(['/profile']);
});
Advanced Angular Topics Chapter 14
[ 415 ]
this.lock.on('authorization_error', error => {
console.log('sth went wrong', error);
});
}
In the preceding code, we are performing the following steps:
1. In the constructor method, we are listening to the on event for
the authenticated and authorization_error states.
2. When we get an authenticated message from the lock instance, we are storing a
localStorage item called userToken and setting accessToken as its value.
3. We are also listening to the error message and logging the message in the
console.
Now, it's time to implement the login and logout methods:
login() {
this.lock.show(function(err, profile, token){
console.log(err);
console.log(profile);
console.log(token);
});
}
In the login method, we are calling the show method of the lock object. This will bring
you to the dialog box of Auth0, with options to Log In, Sign Up, or Don't remember your
password? The login dialog box will have social options if you selected any.
For the logout method, we just clear the userToken that we set when the user logs in and
redirect the user back to the home login page:
logout(){
localStorage.setItem('userToken','');
this.router.navigate(['/']);
}
Once we clear userToken, the application will know that the user is not logged in.
We have implemented the login and logout methods, but we also need a method to
check whether the user is logged in or not:
isLoggedIn() {
var token = localStorage.getItem('userToken');
if(token != '')
{
Advanced Angular Topics Chapter 14
[ 416 ]
return true;
}
else {
return false;
}
}
In the isLoggedIn method, we are checking whether the value of the userToken
variable in local storage is set or not. If the value is set, it means that the user is logged in;
otherwise, the user is not logged in.
Just import the service into our app.component.ts file and inject it into the constructor:
import { Component } from '@angular/core';
import { AuthService } from './services/auth.service';
@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.scss']
})
export class AppComponent {
title = 'Auth0 Tutorial';
userToken:string;
constructor(private authService: AuthService) {}
}
That's it. Wasn't that simple?
We should see the following output:
Advanced Angular Topics Chapter 14
[ 417 ]
If we click on the Login link, we should see the Auth0 dialog window pop up:
Now, go ahead and click on the Sign Up tab to create an account and, once registered
successfully, you should see that the user has been added to the Auth0 dashboard as well:
Advanced Angular Topics Chapter 14
[ 418 ]
Once we log in successfully, we should see only the Logout link, as shown in the following
screenshot:
When we click on the Logout link, the user should be taken back to the default landing
page and should see the login and register options. Also, notice the params provided in the
URL, such as access_token expires_in and so on.
Awesome! We just implemented the entire user authentication using Auth0 in our
application.
Summary
In this chapter, we learned about some advanced Angular topics, from creating custom
directives that are way too cool, to extending the behavior of our native HTML elements.
We also created custom form validations, which are really useful when developing a really
complex application with a lot of validations and compliance requirements. We dove into
Angular single-page applications and looked at how they work and behave. We
implemented user authentication in our Angular applications through native code.
We also learned how to build and implement a secure user authentication management
system using the available frameworks, that is, Firebase and Auth0. We then learned to
implement login, registration and logout features to make sure we can secure the data and
features of applications. Now that we have mastered the preceding concepts, we are good
to implement a complete, wired end-to-end Angular application.
Now that we have learned how to develop our Angular applications, the only thing
between our applications and real users is the deployment of our applications. That's the
focus of our next chapter. In the next and final chapter of this book, we will learn all about
deploying our Angular applications.
15 Deploying Angular Applications
Once you have completed building your application, it then has to be deployed to your
test environment for the testing team to test it before deploying the application to your
production environment for your users to use it. Although you can host your application
virtually anywhere you like, there are 3 main ways in which you can package and
deploy your Angular application. We'll explore these methods in this chapter:
Deploying Angular applications
Deploying composite Angular applications
Deploying to GitHub Pages
Deploying Angular applications
Deploying our app is just as important as building the app itself. After all, our users need to
access it; otherwise, it's not worth building, right?
Before we learn and explore how to deploy apps in detail, it's a prerequisite to have a server
up and running. The server can be hosted on any operating system, be it Windows or
Linux and can be run on any application server, such as Apache Tomcat or IIS.
Alternatively, we can opt to choose any reliable cloud provider, such as AWS, Azure, or
Bluehost, which offer hosting capabilities.
Technology stacks can vary from project to project; some clients prefer Java-based
microservices, some may prefer .NET and others may prefer Ruby on Rails. We will need
to integrate our Angular applications with the backend APIs. The client-side code will
mostly be Angular, which essentially means that Angular apps can be deployed and run on
any server with any backend API services.
In this chapter, we are going to use the XAMPP server. XAMPP is a free distribution of
Apache, MySQL, which makes it easy to set up our local server instantly and easily. You
can download it at https://www. apachefriends. org/ download. html.
Deploying Angular Applications Chapter 15
[ 420 ]
Compilation options for Angular applications
I am sure by now you are aware that all the code we write for Angular is in TS and
that we will need to compile and generate deployable files using the ng command: ng
build. This command will generate the corresponding equivalent JS code that can
just be copied into the environment we are trying to deploy.
Deploying Angular applications is very simple and easy. In real-time scenarios, the build
and deploy commands are integrated into the build pipelines. A common practice is to
have a single Angular project running in one repository. However, we can also run
multiple projects in a single repository.
In this section, we will 1st learn about various compilation options we can consider for the
deployment of our Angular applications. In the sections to follow, we will learn how to
deploy a standalone application and also how to deploy composite Angular
applications. Before we learn how to deploy our app, it's important to understand what
happens when we build the application source code.
Angular has two compilation options, which are applied based on the commands and meta
flags we use:
Just-in-time compilation
Ahead-of-time compilation
What is just-in-time compilation?
The Angular just-in-time (JIT) compilation refers to compiling the code in the browser at
runtime. This is the default behavior whenever we run the ng build command:
ng build
This mechanism will add overhead to the request and Bootstrap time. The changes are
reflected during runtime in our browser, which is great when developing an application.
This option allows developers to quickly test changes while developing.
Deploying Angular Applications Chapter 15
[ 421 ]
What is ahead-of-time compilation?
Angular's ahead-of-time (AOT) compilation means compiling the source TS code,
components, Angular HTML, libraries and modules into the native JS so that it can
run on any browser smoothly. In other words, Angular will covert the code before it's
downloaded by the browser.
Let's take a look at some of the benefits of AOT:
Better security
Faster rendering
Smaller framework and application size
Finds errors well in advance
Ahead Of Time or just AOT compilation is applied by default when we run the ng build
--prod meta flag:
ng build --prod
Now that we have understood the different types of compilations offered by Angular, it's
finally time to actually deploy an Angular app. In the next section, we will learn how to
deploy the Angular application.
Deploying a standalone Angular application
Armed with knowledge about deployment and compilation strategies, it's time to deploy
our Angular application. When we run the ng build and ng build --prod commands,
the native JS files are generated, which we can deploy to our server. This is good if
we are trying to deploy a single project application.
In this section, we will learn how to deploy more complex use cases, such as when we have
multiple projects in our Angular application.
Deploying Angular Applications Chapter 15
[ 422 ]
We are going to keep our applications simple in order for our readers to be able to follow
along with these steps easily. However, you can practice the deployment commands by
deploying the Angular projects you have developed so far. Let's get started by creating a
new Angular app:
1. To install Angular CLI, let's quickly use the following command:
npm i -g @angular/cli
The following screenshot shows the output of the preceding run command. We
have just installed the Angular CLI, which we will use to generate our
application:
2. Now that we have successfully installed the Angular CLI, it's time to create an
Angular app and call it prod-ready:
ng new prod-ready
Using the preceding command, we have generated a new project. The
following screenshot shows the output that is generated:
Deploying Angular Applications Chapter 15
[ 423 ]
Beautiful! We have our newly generated application.
3. Now, let's navigate to the prod-ready application folder, as follows:
cd prod-ready
4. All done. We are not going to change or add any new components. For now, I
want you to understand the simplest way to deploy an app. Now, fire up the app
using the ng serve command:
ng serve
Deploying Angular Applications Chapter 15
[ 424 ]
The preceding command will get the application started and we should see the
output displayed in the following screenshot:
5. Launch the browser and then type http://localhost:4200. The default
vanilla application should be displayed as follows:
Deploying Angular Applications Chapter 15
[ 425 ]
Awesome. So far, so good. We got our app working on our local environment and
now it's time to deploy it to our application-that's right!
To make you comfortable with the whole deployment process, we will deploy the
vanilla application as it is, without making any changes.
6. To deploy, run the following ng command:
ng build --prod
Deploying Angular Applications Chapter 15
[ 426 ]
Once the command runs successfully, you should see that the following folders
and files have been created. Let's take a look at some of the important things to
note:
You should notice a new folder called dist/<defaultProject>.
You should also notice the following files created inside the dist folder:
runtime
main
polyfills
styles
The output of the preceding build command is given as follows. The output will
be under the dist folder with the same application name:
7. We don't have to necessarily use the default folder name; that is, we can provide
the output path and folder name as an argument and Angular will generate the
code in that folder. It's easy to customize the output directory where we would
want our files to be generated:
ng build --prod --output-path dist/compiled
Deploying Angular Applications Chapter 15
[ 427 ]
Run the preceding command and we should see our custom folder and files generated
in our folder. In the preceding command, we specified that we want our files to be
generated in the folder named compiled and we provided the path. The following is
a screenshot after the command has run successfully:
That's all we need to do to generate and deploy our Angular application. Just copy all the
files to the root directory on your server and that's it.
In the next section, we will learn how to deploy a more complex architecture of an Angular
application and we will then go on to deploy the composite application in multiple ways.
Deploying composite Angular applications
In the previous section, we learned how to deploy a standalone Angular application, which
is fairly straightforward. However, we can be in situations where we may have to build and
deploy multiple applications all running in a single repository. Is it possible? Certainly. In
this section, we will create an Angular repository with multiple projects and learn how to
deploy a composite application.
Deploying Angular Applications Chapter 15
[ 428 ]
Creating and deploying multiple Angular
applications
In a more realistic real-world application, we will need to run multiple Angular
applications, which will be composed of multiple projects, libraries, modules, and
microservices, as shown in the following diagram:
In the preceding diagram, some of the important things to note are detailed as follows:
There are multiple Angular projects and applications.
Library #1 and Library #2 can be reused in multiple projects simply by importing
the libraries.
During the development phase, we will create multiple modules that can also be
reused in multiple projects.
So, let's jump right into it and create multiple projects, libraries and modules. Finally, we'll
package the app in different ways. So, let's begin by getting our Angular application up and
running:
1. 1st things 1st. We will need to generate an application and we are going to
use Angular CLI to generate the application. We will 1st need to install the
Angular CLI using the following command:
npm install @angular/cli
Upon successful execution of the preceding command, we should see the
following output:
Deploying Angular Applications Chapter 15
[ 429 ]
2. Now that we have installed Angular CLI, let's create the app using the following
command. We are calling it shopping-cart. Now, run the following ng
command to generate the new project:
ng new shopping-cart
Using the preceding command, we are generating a new application called
shopping-cart. The output of the preceding command is given as follows:
Deploying Angular Applications Chapter 15
[ 430 ]
3. We have now created our new app called shopping cart. Let's
modify app.component.html and add two routerLink hyperlinks named
list-jackets and list-vendors:
<div style="text-align:center">
<h1>
Welcome to {{ title }}!
</h1>
</div>
<ul>
<li>
<h2><a routerLink="/list-jackets" class="nav-link">List
Jackets</a></h2>
</li>
<li>
<h2><a routerLink="/list-vendors" class="nav-link">List
Vendors</a></h2>
</li>
</ul><router-outlet></router-outlet>
In the preceding code, we have created two links in the app.component.html
file. The result is displayed as follows:
So far, so good. Essentially, we have an Angular application up and running. Now, we are
going to learn how to run and deploy multiple Angular projects inside the same repository.
In order to do so, we will follow these steps:
1. Let's create a new application in the same repository using the following
command. We are generating a new application called jackets:
ng g application jackets
Deploying Angular Applications Chapter 15
[ 431 ]
We are creating a new application using the ng command, which we'll
name jackets. We should see the following output:
2. Woohoo! With the Angular CLI schematics, it's really simple to create multiple
projects inside the same app. Take a look at the files that have been
autogenerated and some of the files that have been updated by the Angular CLI
for us:
If you look carefully, you'll notice that the following are some of the important
things that have happened to our application structure and files:
A new folder called Projects is auto-created and its corresponding entry is
generated in the angular.json file.
In the Projects folder, we will see the new Jackets project with the same
default vanilla application files that have been generated.
Deploying Angular Applications Chapter 15
[ 432 ]
3. Now, to verify whether the new Jackets project was added, let's check out the
Angular.json file:
You will notice inside the Angular.json file that we have project-specific entries
for shopping-cart, shopping-cart-e2e, jackets and jackets-e2e. Beautiful.
Technically speaking, we are now running two apps inside the same repository.
4. It's now time to extend our application by adding a few components, libraries,
and modules. 1st, we will need to create a component inside our
jackets project. Run the following ng command to generate the component:
ng g c jacket-list --skip-import
Run the preceding command and we should see the component and respective
files generated. We should see the following output:
Deploying Angular Applications Chapter 15
[ 433 ]
5. Now that we have created a new component inside the Jackets project, it's time
to add it to app-routing.module.ts so that it's available to use across the
Jackets project.
In the following code snippet, we are importing the newly created component
inside the app-routing.module.ts file:
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { AppComponent } from './app.component';
import { JacketListComponent } from
'../../projects/jackets/src/app/jacket-list/jacket-list.component';
import { VendorsComponent } from
'../../projects/vendors/src/lib/vendors.component';
6. After importing the component, it's time to create a route for our component:
const routes: Routes = [
{
path:'home',
component:AppComponent
},
{
path:'list-jackets',
component:JacketListComponent
},
Deploying Angular Applications Chapter 15
[ 434 ]
{
path:'list-vendors',
component:VendorsComponent
}
];
In the preceding code snippet, we are creating list-jackets and listvendors
routes that are mapped to the respective JacketListComponent and
VendorsComponent components. Here are two important things to note in the
preceding code snippet:
We are running multiple Angular projects.
We are linking components from various projects inside each other.
7. We have already added the router links to app.component.html. Now, let's fire
up our application by running the ng serve command:
ng serve
8. Launch the http://localhost:4200 browser and we should see the following
output displayed:
Deploying Angular Applications Chapter 15
[ 435 ]
So, now we have two apps running and we have components that are shared across
different projects.
Great. Now, why don't we add a few libraries that we can share between multiple projects?
Let's begin:
1. We will create a new Angular library called vendors. We will use the ng
command and call the library vendors. Let's run the following command to
generate the library:
ng g library vendors --prefix=my
On running the preceding command successfully, we should see the
following output:
Deploying Angular Applications Chapter 15
[ 436 ]
2. Once the library is generated, Angular CLI will create the following folders and
files:
3. Here are some important things to note once the command runs successfully:
Under Projects, a new Vendors library project is created.
Angular will also make the necessary changes and entries in the Angular.json
file.
Note that projecType is of the library type.
Deploying Angular Applications Chapter 15
[ 437 ]
The following screenshot shows the data displayed for the newly created library project:
4. Now, open the vendors folder and, under src/lib, edit the
vendors.component.ts file and add some fancy text:
import { Component, OnInit } from '@angular/core';
@Component({
selector: 'my-vendors',
template: `
<p>
vendors works!
</p>
`,
styles: []
})
export class VendorsComponent implements OnInit {
constructor() { }
Deploying Angular Applications Chapter 15
[ 438 ]
ngOnInit() {
}
}
5. Remember, we have created the router link for the vendor component earlier, so
we should see the changes reflected in the application:
Now that we have built an Angular app that has multiple projects, libraries and routing
systems to share different components, it's time to deploy the app.
Deployment is simple and is just like what we did for a standalone app:
ng build --prod --base-href "http://localhost/deploy-angular-app/"
Once you run the command, here are some important things that will happen:
To generate the final deployment files, we are running the ng build command.
We are using the --prod meta flag, to which we will apply AOT compilation
while compiling.
Most importantly, we need to pass the --base-href meta flag, which will point
to the server's root folder/path.
Without a proper --base-href value, Angular applications will not
work properly and will give you errors to link the generated files.
Deploying Angular Applications Chapter 15
[ 439 ]
From the previous section, we already know that after we run the build command,
Angular will generate the compiled folders and files, as shown in the following screenshot:
Here are some important points to note from the preceding screenshot:
The command will generate the output of compiled files that have multiple
projects, libraries and components.
Carefully consider the --base-href value we have set. We are running XAMPP
locally, hence the path is pointing to the localhost.
Deploying Angular Applications Chapter 15
[ 440 ]
Now, let's copy all the code from the dist folder and paste it into our XAMPP folder.
Launch the Angular application using the local server and you should see the output
displayed as follows:
That's really cool! Even so, we can improve this a lot. In a more realistic setup, any large
Angular implementations will have feature teams and the library or module developed by
one team should be easily shareable with other teams as a module. That's where writing
reusable modules comes into the picture. We are going to learn how to distribute Angular
modules as npm modules.
Packing the Angular project as an npm package
Now, let's learn how to export our Angular project as an npm module. We will continue to
use the same vendors library that we created in the previous example:
1. Note that we do not wish to deploy the entire application, rather, we only want to
deploy the vendors library. We will use the same ng build command to build
the vendors Angular project:
ng build vendors
2. Once the command is successfully executed, we will see that Angular will
generate the compiled files for our vendors project under the dist folder, as
follows:
Deploying Angular Applications Chapter 15
[ 441 ]
3. Navigate to the dist/vendors folder and run the following command:
npm pack
We are using the npm pack command to generate a package out of the current
folder, which is compiled of files from the vendors project. We should see the
following output:
Deploying Angular Applications Chapter 15
[ 442 ]
4. Upon successful execution, we will see the vendors-0.01.tgz file created in
the folder. We can now distribute this file as an npm package, which can be
reused across any projects:
5. Let's now give it a test drive, by installing the newly generated npm module into
our application. To install the package, run the npm install command by
pointing to vendors-0.0.1.tgz:
npm install dist\vendors\vendors-0.0.1.tgz
6. Upon completion, we should see the following output informing us that the
package has been added:
Deploying Angular Applications Chapter 15
[ 443 ]
7. We can also verify whether the package was added successfully to the
package.json file. We should see an entry in package.json displayed as
follows:
Awesome! In this section, we learned how to deploy the Angular application as a
standalone app and also as a composite app.
We also learned how to create a package of the Angular project that can be distributed and
used in multiple Angular projects.
Deploying Angular apps to GitHub Pages
In previous sections, we learned about deploying our standalone app and deploying the
composite app to any server by exporting the compiled source files for the application.
In this section, we will learn how to deploy our Angular app to GitHub Pages.
Deploying Angular Applications Chapter 15
[ 444 ]
Throughout the book, we have created many Angular projects and now it's time to host
them, for free!
Creating and deploying applications in GitHub
Pages
GitHub Pages are websites for your projects hosted on GitHub. Did we say free? Of course,
the GitHub Pages are free! Just edit, push and view the changes live on your free website.
Let's take a look at how to create and host our application on GitHub Pages step by step:
1. Let's get started by installing Angular CLI using the npm install command:
npm install @angular/cli
2. Upon completion of the command, it's time to create a new Angular project. Let's
call it deploying-angular:
ng new deploying-angular
Once the command is executed successfully, we should see the following
screenshot:
Deploying Angular Applications Chapter 15
[ 445 ]
3. Now it's time to initiate a Git repository. We can do that by executing the
following command:
git init
4. Upon successful execution, you will see the repository initialized or, in the
following case, if a repository already exists, then it will be reinitialized as
follows:
5. Feel free to make any changes to app.component.html or any files that you
would want to modify. Then, once you are ready to deploy, 1st commit the
code/changes by executing the commit Git command. We can also pass the -m
meta flag and add a message to the commit:
git commit -m "deploying angular"
6. Next, we need to set the origin to the repository. The following command sets
the remote origin to the repository:
git remote add origin
https://<token>@github.com/<username>/<repo-name>
All right. All set.
7. Now, the superpowers come in. To deploy your Angular app to GitHub directly,
we will need to install a package called angular-cli-ghpages. This is an
official distribution to deploy Angular apps to GitHub Pages directly:
npm install -g angular-cli-ghpages
Deploying Angular Applications Chapter 15
[ 446 ]
This is the output we will get up on running the preceding code:
Now that we have angular-cli-ghpages installed, it's time to build our
application and get the compiled source files.
8. Let's run the ng build command with the --prod meta flag and also set --
base-href:
ng build --prod --base-href
"https://<username>.github.io/deploying-angular"
The --base-href flag is pointing to the source repository on GitHub.
You will need to register with GitHub and get your authorization token in
order to host your application.
9. Here is the base href URL, which is the author's GitHub home page and the
corresponding deploying-angular repository:
ng build --prod --base-href
"https://srinixrao.github.io/deploying-angular"
Deploying Angular Applications Chapter 15
[ 447 ]
10. Once we build the Angular application, we will see that the compiled source
code is generated under dist/<defaultProject> -defaultProject. The
compiled source is usually the folder name that we specify as the application
name:
11. Now that we have our compiled files generated, it's time to deploy the
application to GitHub Pages. We do this by running the npx ngh --nosilent
command:
npx ngh --no-silent --dir=dist/deploying-angular
Deploying Angular Applications Chapter 15
[ 448 ]
12. remember, that, optionally, we will need to mention the corresponding dist
folder that we want to deploy:
13. Upon successful execution of the command, the package we installed for
deploying the Angular application to GitHub Pages will run the required jobs,
such as cleaning, fetching the origin, checking out the code, and, finally, pushing
the latest code to the repository and will then be ready to host in GitHub Pages:
Deploying Angular Applications Chapter 15
[ 449 ]
14. Once the commands are executed, navigate to your GitHub account and click on
Settings under the repository. You will see the site published to the URL:
15. Click on the link displayed under the repository and we should see that our app
is up and running!
Deploying Angular Applications Chapter 15
[ 450 ]
Congratulations! We just published our 1st Angular application to GitHub Pages:
In the preceding series of steps, we learned how to deploy our Angular application to
GitHub Pages. In more realistic scenarios, we will also need to deploy the APIs or backend
services to our server. We can do that by deploying our APIs to either Firebase or selfhosted
servers.
Now, go ahead and just repeat the same for all the projects and applications created so far.
Deploying Angular Applications Chapter 15
[ 451 ]
Summary
Deploying an application holds extreme importance: all our hard work of developing will
show up once the site is alive.
Deploying Angular applications is pretty straightforward if you generate the required
compiled source code, and, with latest versions of Angular, the AOT compilation defaults
to any build generated with the --prod meta flag. We learned about the importance of
AOT and how critical it is to have it for overall application performance and security. We
learned to deploy a standalone Angular application and also composite Angular
applications with multiple projects, libraries and components.
Finally, we learned about deploying our Angular application to GitHub Pages using the
official angular-cli-ghpages package.
That brings us to the conclusion of our last chapter in this book. We have come a long way
in our learning journey, from understanding the basics of the TS language to
learning how to build our Angular applications by implementing the Angular framework's
components, routing systems, directives, pipes, forms, backend services and much more.
We also learned about implementing various CSS frameworks, such as Bootstrap, Angular
Material and Flex layout with our Angular applications. Additionally, we learned how to
design and make our application's UI much more appealing and interactive.
We explored unit testing using the Jasmine and Karma frameworks, which ensures that our
applications are well-tested and are rock-solid implementations.
We have also implemented the user authentication mechanism using Auth0 and Firebase as
part of learning Angular Advanced topics. Finally, we covered the deployment of Angular
applications.
That is a 360-degree overview of all aspects of application development using the Angular
framework. We hope you now feel empowered to build world-class products using the
Angular framework.
We wish you all the best and look forward to hearing about your success stories soon.
Good luck! Onward and upward.